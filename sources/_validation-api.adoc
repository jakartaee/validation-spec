// Jakarta Validation
//
// License: Apache License, Version 2.0
// See the license.txt file in the root directory or <http://www.apache.org/licenses/LICENSE-2.0>.
:validation-api-source-dir: ../target/validation-api/
:spec-examples-source-dir: ../src/test/java/

[[validationapi]]

== Validation APIs

The default package for the {spec-name-bv} APIs is [classname]`jakarta.validation`.

[[validationapi-validatorapi]]

=== Validator API

The main {spec-name-bv} API is the [classname]`jakarta.validation.Validator` interface.

A [classname]`Validator` instance is able to validate instances of beans and their associated objects if any. It is recommended to leave the caching of [classname]`Validator` instances to the [classname]`ValidatorFactory`. [tck-not-testable]#[classname]`Validator` implementations must be thread-safe.#

[role="api"]
.`Validator` interface
====

[source, JAVA, indent=0]
----
include::{validation-api-source-dir}jakarta/validation/Validator.java[lines=15..-1]
----

====

The methods [methodname]`validate()`, [methodname]`validateProperty()` and [methodname]`validateValue()` are used for the validation of Java beans respectively single bean properties. See the next section for more details.

[methodname]`forExecutables()` provides access to the contract for validating method and constructor parameters and return values. The individual methods for method and constructor validation are described in <<validationapi-validatorapi-methodlevelvalidationmethods>>.

[methodname]`getConstraintsForClass()` returns constraint-related metadata for given types and is described in detail in <<constraintmetadata>>.

[methodname]`unwrap()` is provided as a way to access objects of a given type specific to a {spec-name-bv} provider typically as a complement to the [classname]`Validator` contract. Using this method makes your code non portable.

.Using unwrap to access a provider specific contract
====

[source, JAVA]
----
//if using the ACME provider
ACMEValidator acmeValidator = factory.unwrap(ACMEValidator.class);
acmeValidator.setSpecificConfiguration( [...] );
----

====

[[validationapi-validatorapi-validationmethods]]

==== Validation methods

[tck-testable]#[methodname]`<T> Set<ConstraintViolation<T>> validate(T object, Class<?>\... groups)` is used to validate a given object.# This method implements the logic described in <<constraintdeclarationvalidationprocess-validationroutine>>. [tck-testable]#An [classname]`IllegalArgumentException` is thrown when null is passed for the [varname]`object` parameter or the varargs [varname]`groups` parameter.# [tck-testable]#A [classname]`Set` containing all [classname]`ConstraintViolation` objects representing the failing constraints is returned, an empty [classname]`Set` is returned otherwise.#

[tck-testable]#[methodname]`<T> Set<ConstraintViolation<T>> validateProperty(T object, String propertyName, Class<?>\... groups)` validates a given field or property of an object.# [tck-testable]#An [classname]`IllegalArgumentException` is thrown when [methodname]`validateProperty()` is called and [varname]`object` is null or [varname]`propertyName` is null, empty or invalid or null is passed to the varargs [varname]`groups` parameter.# [tck-testable]#The property name is the JavaBeans property name (as defined by the JavaBeans [classname]`Introspector` class).# This method implements the logic described in <<constraintdeclarationvalidationprocess-validationroutine>> but only to the given property. [tck-testable]#`@Valid` is not honored by this method.# This method is useful for partial object validation.

[tck-testable]#[methodname]`<T> Set<ConstraintViolation<T>> validateValue(Class<T> beanType, String propertyName, Object value, Class<?>\... groups)` validates the property referenced by [parameter]`propertyName` present on `beanType` or any of its superclasses, if the property value were [parameter]`value`.# [tck-testable]#An [classname]`IllegalArgumentException` is thrown when [methodname]`validateValue()` is called and [varname]`beanType` is null or [varname]`propertyName` is null, empty or invalid or null is passed to the varargs [varname]`groups` parameter.# This method implements the logic described in <<constraintdeclarationvalidationprocess-validationroutine>> and apply it only to the given property and for the given value. [tck-testable]#`@Valid` is not honored by this method.# This method is useful for ahead of time validation (i.e. before the JavaBean is populated or updated).

[NOTE]
====
If multiple constrained fields or getters share the same name and hide one another in the class hierarchy according to the Java visibility rules, the list of constraints evaluated is unspecified. This will be clarified in a later version of this specification. Note that method overriding is not impacted.

If getters and fields share the same name and are present at different levels of the hierarchy, the list of constraints evaluated is unspecified. This will be clarified in a later version of this specification.

However, constraints hosted on the most specific (hierarchy wise) element type are always evaluated.
====

[NOTE]
====
[methodname]`validateProperty()` and [methodname]`validateValue()` accept property names and not full paths. {spec-name-bv} implementations might accept string representations of paths but this behavior is not portable.
====

[tck-testable]#If some unrecoverable failure happens during validation, a [classname]`ValidationException` is raised.# This exception can be specialized in some situations (invalid group definition, invalid constraint definition, invalid constraint declaration). See <<exception>> or the relative sections for more information.

[[validationapi-validatorapi-validationmethods-examples]]
===== Examples

All the examples will be based on the following class definition, constraint declarations and address instance.

[source, JAVA]
----
public class Address {
    @NotNull @Size(max=30)
    private String addressline1;

    @Size(max=30)
    private String addressline2;

    private String zipCode;

    private String city;

    public String getAddressline1() {
        return addressline1;
    }

    public void setAddressline1(String addressline1) {
        this.addressline1 = addressline1;
    }

    public String getAddressline2() {
        return addressline2;
    }

    public void setAddressline2(String addressline2) {
        this.addressline2 = addressline2;
    }

    public String getZipCode() {
        return zipCode;
    }

    public void setZipCode(String zipCode) {
        this.zipCode = zipCode;
    }

    @Size(max=30) @NotNull
    public String getCity() {
        return city;
    }

    public void setCity(String city) {
        this.city = city;
    }
}

Address address = new Address();
address.setAddressline1( null );
address.setAddressline2( null );
address.setCity("Llanfairpwllgwyngyllgogerychwyrndrobwyll-llantysiliogogogoch");
//town in North Wales
----

The following code will return two [classname]`ConstraintViolation` objects. One for `addressline1` violating `@NotNull` and one for `city` violating `@Size`.

[source, JAVA]
----
validator.validate(address).size() == 2
----

The following code will return one [classname]`ConstraintViolation` since `city` violates `@Size` and only `city` is validated.

[source, JAVA]
----
validator.validateProperty(address, "city").size() == 1
----

The following code will return no [classname]`ConstraintViolation` objects because the value "Paris" for `city` would not raise any constraint failures.

[source, JAVA]
----
validator.validateValue(Address.class, "city", "Paris").size() == 0
----

[[validationapi-validatorapi-methodlevelvalidationmethods]]

==== Methods for validating method and constructor constraints

The methods for the validation of parameters and return values of methods and constructors can be found on the interface [classname]`jakarta.validation.executable.ExecutableValidator`.

[role="api"]
.`ExecutableValidator` interface
====

[source, JAVA, indent=0]
----
include::{validation-api-source-dir}jakarta/validation/executable/ExecutableValidator.java[lines=7..8;16..-1]
----

====

[tck-testable]#[methodname]`<T> Set<ConstraintViolation<T>> validateParameters(T object, Method method, Object[] parameterValues, Class<?>\... groups)` validates the arguments (as given in [varname]`parameterValues`) for the parameters of a given method (identified by [varname]`method`). Cross-parameter constraints are also validated.# [tck-testable]#A set containing all [classname]`ConstraintViolation` objects representing the failing constraints is returned, an empty set is returned if no constraint violations occurred.# [tck-testable]#An [classname]`IllegalArgumentException` will be thrown if null is passed for any of the parameters or if the parameters don't match with each other (i.e. `object` and `method` don't match, `parameterValues` and `method` don't match).#

[tck-testable]#[methodname]`<T> Set<ConstraintViolation<T>> validateReturnValue(T object, Method method, Object returnValue, Class<?>\... groups)` validates the return value (specified by [varname]`returnValue`) of a given method (identified by [varname]`method`).# [tck-testable]#A set containing all [classname]`ConstraintViolation` objects representing the failing constraints is returned, an empty set is returned if no constraint violations occurred.# [tck-testable]#An [classname]`IllegalArgumentException` will be thrown if null is passed for any of the parameters [varname]`object`, [varname]`method` and [varname]`groups` or if the parameters don't match with each other (i.e. `object` and `method` don't match, `returnValue` and `method` don't match).#

[tck-testable]#[methodname]`<T> Set<ConstraintViolation<T>> validateConstructorParameters(Constructor<T> constructor, Object[] parameterValues, Class<?>\... groups)` validates the arguments (as given in [varname]`parameterValues`) for the parameters of a given constructor (identified by [varname]`constructor`). Cross-parameter constraints are also validated.# [tck-testable]#A set containing all [classname]`ConstraintViolation` objects representing the failing constraints is returned, an empty set is returned if no constraint violations occurred.# [tck-testable]#An [classname]`IllegalArgumentException` will be thrown if null is passed for any of the parameters or if the parameters don't match with each other (i.e. `parameterValues` and `constructor` don't match).#

[tck-testable]#[methodname]`<T> Set<ConstraintViolation<T>> validateConstructorReturnValue(Constructor<T> constructor, T createdObject, Class<?>\... groups)` validates the object (specified by [varname]`createdObject`) of a given constructor (identified by [varname]`constructor`).# [tck-testable]#A set containing all [classname]`ConstraintViolation` objects representing the failing constraints is returned, an empty set is returned if no constraint violations occurred.# [tck-testable]#An [classname]`IllegalArgumentException` will be thrown if null is passed for any of the parameters or if the parameters don't match with each other (i.e. `createdObject` and `constructor` don't match).#

[tck-testable]#None of those methods honor the XML configuration around executable validation nor the presence of [classname]`@ValidateOnExecution`. In other words, elements will be validated regardless of these settings when explicitly calling the validation methods.#

[[validationapi-validatorapi-methodlevelvalidationmethods-examples]]
===== Examples

All the examples will be based on the following class definitions, constraint declarations and instances.

[source, JAVA]
----
public class OrderService {

    @NotNull
    private CreditCardProcessor creditCardProcessor;

    @Valid
    public OrderService(@NotNull CreditCardProcessor creditCardProcessor) {
        [...]
    }

    @NotNull
    public Order placeOrder(
        @NotNull @Size(min=3, max=20) String customerCode,
        @NotNull @Valid Item item,
        @Min(1) int quantity) {

        [...]
    }
}

public class Item {

    @NotNull;
    private String name;

    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
}

Item item1 = new Item();
item1.setName("Kiwi");

Item item2 = new Item();
item2.setName(null);

Constructor<OrderService> constructor = [...]; //get constructor object
Method placeOrder = [...]; //get method object

OrderService orderService = new OrderService(new DefaultCreditCardProcessor());

ExecutableValidator executableValidator = Validation
    .buildDefaultValidatorFactory().getValidator().forExecutables();
----

The following method parameter validation will return one [classname]`ConstraintViolation` object as the customer code is null:

[source, JAVA]
----
//orderService.placeOrder(null, item1, 1);
executableValidator.validateParameters(
    orderService, placeOrder, new Object[] { null, item1, 1 }).size() == 1;
----

The following method parameter validation will return one [classname]`ConstraintViolation` object as the [varname]`item` parameter is marked for cascaded validation and the given [classname]`Item` instance is not valid (its name is null):

[source, JAVA]
----
//orderService.placeOrder("CUST-123", item2, 1);
executableValidator.validateParameters(
    orderService, placeOrder, new Object[] { "CUST-123", item2, 1 }).size() == 1;
----

The following constructor parameter validation will return one [classname]`ConstraintViolation` object as null is passed for the [varname]`creditCardProcessor` parameter:

[source, JAVA]
----
//new OrderService(null);
executableValidator.validateConstructorParameters(constructor, new Object[] { null })
    .size() == 1;
----

Assuming the [methodname]`placeOrder()` method returned [varname]`null`, the following return value validation will return one [classname]`ConstraintViolation`:

[source, JAVA]
----
executableValidator.validateReturnValue(orderService, placeOrder, null).size() == 1;
----

Assuming the constructor of [classname]`OrderService` failed to store the given credit card processor into the [varname]`creditCardProcessor` field, the following validation of the constructor return value would fail as the constructor is marked with [classname]`@Valid` and the [classname]`@NotNull` constraint of the [classname]`OrderService` class would be violated:

[source, JAVA]
----
executableValidator.validateConstructorReturnValue(constructor, orderService).size() == 1;
----

Let's now look at how a validation interceptor would use these methods.

[source, JAVA]
----
@Interceptor
public class SampleMethodInterceptor {
    @Inject
    private Validator validator;

    @AroundInvoke
    public Object validateMethodInvocation(InvocationContext ctx) throws Exception {
        //validate parameters
        Set<ConstraintViolation<Object>> violations;
        violations = validator.forExecutables().validateParameters(
                ctx.getTarget(),
                ctx.getMethod(),
                ctx.getParameters()
        );

        //if a violation occurs for parameters, raise an exception
        if ( !violations.isEmpty() ) {
            throw new ConstraintViolationException(
                    buildMessage( ctx.getMethod(), ctx.getParameters(), violations ),
                    violations
            );
        }

        //execute the method proper
        Object result = ctx.proceed();

        //validate the return type
        violations = validator.forExecutables().validateReturnValue(
                ctx.getTarget(),
                ctx.getMethod(),
                result
        );

        //if a violation occurs for the return type, raise an exception
        if ( !violations.isEmpty() ) {
            throw new ConstraintViolationException(
                    buildMessage( ctx.getMethod(), ctx.getParameters(), violations ),
                    violations
            );
        }

        //return the result
        return result;
    }
}
----

[[validationapi-validatorapi-groups]]

==== groups

Groups allow you to restrict the set of constraints applied during validation. Groups targeted are passed as parameters to the [methodname]`validate()`, [methodname]`validateProperty()` and [methodname]`validateValue()` methods as well as the methods to validate method/constructor constraints (see <<validationapi-validatorapi-methodlevelvalidationmethods>>). [tck-testable]#All constraints belonging to the targeted group(s) are applied during the <<constraintdeclarationvalidationprocess-validationroutine>>.# [tck-testable]#If no group is passed, the `Default` group is assumed.# <<constraintsdefinitionimplementation-constraintdefinition-properties-groups>> describes how to define groups on constraints.

[tck-not-testable]#When more than one group is evaluated and passed to the various validate methods, order is not constrained.# It is equivalent to the validation of a group `G` inheriting all groups (i.e. implementing all interfaces) passed to the validation method.

[[validationapi-validatorapi-groups-examples]]
===== Examples

[source, JAVA]
----
/** Validates a minimal set of constraints */
public interface Minimal {}

public class Address {

    @NonEmpty(groups = Minimal.class)
    @Size(max=50)
    private String street1;

    @NonEmpty
    private String city;

    @NonEmpty(groups = {Minimal.class, Default.class})
    private String zipCode;

    [...]
}
----

In the previous example, [classname]`@NonEmpty` (and its composing constraints, assuming the definition given in chapter <<constraintdeclarationvalidationprocess>>) on [methodname]`street1` applies to the group [classname]`Minimal`, [classname]`@Size` on [methodname]`street1` applies to the group `Default` and [classname]`@NonEmpty`(and its composing constraints) on [methodname]`zipCode` applies to the groups `Default` and `Minimal`.

[source, JAVA]
----
validator.validate(address);
----

validates the group [classname]`Default` (implicitly) and applies [classname]`@Size` on [methodname]`street1`, [classname]`@NonEmpty` (and its composing constraints) on [methodname]`city`, [classname]`@NonEmpty` (and its composing constraints) on [methodname]`zipCode`. Particularly, [classname]`@NonEmpty` (and its composing constraints) on [methodname]`street1` are not applied.

[source, JAVA]
----
validator.validate(address, Minimal.class);
----

applies [classname]`@NonEmpty` (and its composing constraints) on [methodname]`street1` and [classname]`@NonEmpty` (and its composing constraints) on [methodname]`zipCode` because they belong to the [classname]`Minimal` group.

[source, JAVA]
----
validator.validate(address, Minimal.class, Default.class);
----

validates both [classname]`Default` and [classname]`Minimal` groups. The routine applies [classname]`@NonEmpty` (and its composing constraints) and [classname]`@Size` on [methodname]`street1`, [classname]`@NonEmpty` (and its composing constraints) on [methodname]`city`, [classname]`@NonEmpty` (and its composing constraints) on [methodname]`zipCode`. Note that if [methodname]`zipCode` is empty, only one [classname]`ConstraintViolation` object will represent the failure and the not empty validation will only be executed once.

Let's look at a more complex example involving group sequence.

[source, JAVA]
----
public class Address {
    @NonEmpty(groups = Minimal.class)
    @Size(max=50, groups=FirstStep.class)
    private String street1;

    @NonEmpty(groups=SecondStep.class)
    private String city;

    @NonEmpty(groups = {Minimal.class, SecondStep.class})
    private String zipCode;

    [...]

    public interface FirstStep {}

    public interface SecondStep {}

    @GroupSequence({Firststep.class, SecondStep.class})
    public interface Total {}
}
----

When running:

[source, JAVA]
----
validator.validate(address, Minimal.class, Total.class);
----

the validation process will process [classname]`@NonEmpty` (and its composing constraints) and [classname]`@Size` from [methodname]`street1` and [classname]`@NonEmpty` (and its composing constraints) from [methodname]`zipCode`. If [classname]`@Size` from [methodname]`street1` does not generate a failure, then [classname]`@NonEmpty` (and its composing constraints) from [methodname]`city` will be processed as part of [classname]`SecondStep`. Note that [classname]`@NonEmpty` (and its composing constraints) from [methodname]`zipCode` are not reprocessed as they have already been processed before.

When running:

[source, JAVA]
----
validator.validate(address, Total.class, SecondStep.class);
----

[classname]`@NonEmpty` (and its composing constraints) from [methodname]`city` and [classname]`@NonEmpty` (and its composing constraints) from [methodname]`zipCode` will be processed even if [classname]`@Size` from [methodname]`street1` fails: while `SecondStep` is in the `Total` group sequence and hence should not be triggered if `FirstStep` has a failure, it also has been requested outside the sequence (in this case explicitly).

[NOTE]
====
If the group definition is invalid, a [classname]`GroupDefinitionException` is raised.
====

[[validationapi-constraintviolation]]

=== ConstraintViolation

[classname]`ConstraintViolation` is the class describing a single constraint failure. A set of [classname]`ConstraintViolation` is returned for an object validation.

[role="api"]
.`ConstraintViolation` interface
====
[source, JAVA, indent=0]
----
include::{validation-api-source-dir}jakarta/validation/ConstraintViolation.java[lines=11..-1]
----
====

[tck-testable]#The [methodname]`getMessage()` method returns the interpolated (localized) message for the failing constraint# (see <<validationapi-message>> for more information on message interpolator). This can be used by clients to expose user friendly messages.

[tck-testable]#The [methodname]`getMessageTemplate()` method returns the non-interpolated error message# (usually the `message` attribute on the constraint declaration). Frameworks can use this as an error code key.

[tck-testable]#The [methodname]`getRootBean()` method returns the root object being validated that led to the failing constraint# (i.e. the object the client code passes to the [methodname]`Validator.validate()` method). [tck-testable]#For method validation, returns the object the method is executed on. For constructors or when [methodname]`Validator.validateValue()` is used, returns `null`.#

[tck-testable]#The [methodname]`getRootBeanClass()` method returns the class of the root bean being validated. For method validation, this is the object class the method is executed on. For constructor validation, this is the class the constructor is declared on.#

[tck-testable]
--
The [methodname]`getLeafBean()` method returns the following object:

* If a bean constraint, the bean instance the constraint is applied on.
* If a property constraint or a <<constraintdeclarationvalidationprocess-containerelementconstraints,container element constraint>> hosted on a property, the bean instance hosting the property the constraint is applied on.
* If a property constraint, `null` when the [classname]`ConstraintViolation` is returned after calling [methodname]`Validator.validateValue()`.
* If a method parameter, cross-parameter or return value constraint or a container element constraint hosted on a method parameter or return value, the object the method is executed on.
* If a constructor parameter or cross-parameter constraint or a container element constraint hosted on a constructor parameter, `null`.
* If a constructor return value constraint, the object the constructor has created.
--

[tck-testable]#The [methodname]`getExecutableParameters()` returns the parameters provided to the method or constructor invocation or `null` if not validating a method or constructor parameters.#

[tck-testable]#The [methodname]`getExecutableReturnValue()` returns the return value of the method or constructor invocation or `null` if the method has no return value or if not validating a method or constructor return value.#

[tck-testable]#The [methodname]`getInvalidValue()` method returns the value (field, property, method/constructor parameter, method/constructor return value, container element or validated object) being passed to [methodname]`isValid()`.# [tck-testable]#For a cross-parameter constraint failure, an [code]`Object[]` representing the method/constructor invocation arguments is returned.#
[tck-testable]#In case a constraint given on a container is subject to implicit application to the container element(s) (see <<constraintdeclarationvalidationprocess-containerelementconstraints-implicitunwrapping>>), `getInvalidValue()` returns the invalid container element value.#

[tck-testable]#[methodname]`getConstraintDescriptor()` provides access to the failing constraint metadata# (see <<constraintmetadata-constraintdescriptor>>).

[tck-testable]#The [methodname]`getPropertyPath()` method returns the [classname]`Path` object representing the navigation path from the root object to the failing object.#

[methodname]`unwrap()` is provided as a way to access objects of a given type specific to a {spec-name-bv} provider typically as a complement to the [classname]`ConstraintViolation` contract. Using this method makes your code non portable.

[role="api"]
.`Path` and `Node` interfaces and `ElementKind` enum
====

[source, JAVA]
----
include::{validation-api-source-dir}jakarta/validation/Path.java[lines=13..-1]
----

[source, JAVA, indent=0]
----
include::{validation-api-source-dir}jakarta/validation/ElementKind.java[lines=9..-1]
----

====

[classname]`Path` is an iterable of [classname]`Node` objects. [classname]`Node` offers the following methods:

* [tck-testable]#[methodname]`getName()` returns the name of the element which the node represents:#
** `null` if it is a leaf node which represents an entity / bean. In particular, the node representing the root object.
** The property name for a property.
** The method name for a method.
** The unqualified name of the type declaring the constructor for a constructor.
** The parameter named as defined by the [classname]`ParameterNameProvider` (see <<constraintdeclarationvalidationprocess-methodlevelconstraints-parameterconstraints-namingparameters>>) for a method or constructor parameter.
** The literal `<cross-parameter>` for a method or constructor cross-parameter.
** The literal `<return value>` for a method or constructor return value.
** The name set by the applied value extractor for a container element constraint;
specifically, when applying the default value extractor for iterable elements, list elements, map keys or map values, the literal `<iterable element>`, `<list element>`, `<map key>` or `<map value>`, respectively.

* [tck-testable]#[methodname]`isInIterable()` returns `true` if the node represents an object contained in an array or in a multi-valued container such as [classname]`Iterable` or [classname]`Map`, `false` otherwise.#
* [tck-testable]#[methodname]`getIndex()` returns the index of the node if it is contained in an array, [classname]`List` or any other container supporting indexed access. Returns `null` otherwise.#
* [tck-testable]#[methodname]`getKey()` returns the key of the node if it is contained in a [classname]`Map` or any other container supporting keyed access. Returns `null` otherwise.#
* [tck-testable]#[methodname]`getKind()` returns the [classname]`ElementKind` corresponding to the actual node type. This can be used in conjunction with the method [methodname]`as()` to narrow the type and access node specific methods#
* [tck-testable]#[methodname]`as(Class<? extends Node>)` returns the node instance narrowed to the type passed as a parameter or throws a [classname]`ClassCastException` if the type and node don't match.#

Nodes are of the following possible types:

* [classname]`BeanNode`
* [classname]`PropertyNode`
* [classname]`MethodNode`
* [classname]`ConstructorNode`
* [classname]`ParameterNode`
* [classname]`CrossParameterNode`
* [classname]`ReturnValueNode`
* [classname]`ContainerElementNode`

It is possible to narrow a node instance to its precise type and extract node specific information by the use of [methodname]`Node.getKind()` and [methodname]`Node.as(Class<? extends Node>)`.

[tck-testable]#In particular, [classname]`MethodNode` and [classname]`ConstructorNode` host [methodname]`getParameterTypes()` which return the method or constructor parameter list.#
[tck-testable]#Likewise [classname]`ParameterNode` hosts [methodname]`getParameterIndex()` which returns the parameter index in the method or constructor parameter list.#
[tck-testable]
--
`BeanNode`, `PropertyNode` and `ContainerElementNode` host `getContainerClass()` and `getTypeArgumentIndex()`.
If the node represents an element that is contained in a container such as `Optional`, `List` or `Map`,
the former returns the declared type of the container and, if the container is of a generic type, the latter returns the index of the affected type argument.
--

.Narrow a node to its specific type
====

[source, JAVA]
----
Node node = [...];
switch ( node.getKind() ) {
case METHOD:
    MethodNode methodNode = node.as(MethodNode.class);
    methodName = methodNode.getName();
    params = methodNode.getParameterTypes().toArray(
        new Class<?>[methodNode.getParameterTypes().size()] );
    break;
case CONSTRUCTOR:
    ConstructorNode constructorNode = node.as(ConstructorNode.class);
    methodName = constructorNode.getName();
    params = constructorNode.getParameterTypes().toArray(
        new Class<?>[constructorNode.getParameterTypes().size()] );
    break;
case PARAMETER:
    arg = node.as(ParameterNode.class).getParameterIndex();
    break;
case CONTAINER_ELEMENT:
    ContainerElementNode containerElementNode = node.as(ContainerElementNode.class);
    containerClass = containerElementNode.getContainerClass();
    typeArgumentIndex = containerElementNode.getTypeArgumentIndex();
    break;
case CROSS_PARAMETER:
    [...]
case RETURN_VALUE:
    [...]
case PARAMETER:
    [...]
case BEAN:
    [...]
case PROPERTY:
    [...]
}
----

====

[classname]`Path` objects are built according to the following rules:

* [tck-testable]#The runtime type is considered, not the static type. For example if a property is declared [classname]`Collection<String>` but its runtime type is [classname]`ArrayList<String>`, the property is considered an [classname]`ArrayList<String>`.#
* [tck-testable]#If the failing object is the root object, a [classname]`BeanNode` with name set to [classname]`null` is added to the [classname]`Path`. The [classname]`ElementKind` of the node is [varname]`ElementKind.BEAN`.#
* When an association is traversed:
** [tck-testable]#a [classname]`PropertyNode` object whose `name` equals the name of the association property (field name or Java Bean property name) is added to [classname]`Path`. The [classname]`ElementKind` of the node is [varname]`ElementKind.PROPERTY`.#
** [tck-testable]#if the association is an array, a [classname]`List` or any other container whose value extractor invokes `ValueReceiver#indexedValue()` (see <<valueextractordefinition>>), the following [classname]`Node` object added contains the index value in [methodname]`getIndex()`#
** [tck-testable]#if the association is a [classname]`Map` or any other container whose value extractor invokes `ValueReceiver#keyedValue()`, the following [classname]`Node` object added (representing a given map entry) contains the key value in [methodname]`getKey()`#
** [tck-testable]#for all [classname]`Iterable`, [classname]`Map` or other container whose value extractor invokes `ValueReceiver#indexedValue()`, `ValueReceiver#keyedValue()` or `ValueReceiver#iterableValue()`, the following [classname]`Node` object added is marked as `inIterable` ([methodname]`isInIterable()`)#
** [tck-testable]#if the traversed object is of a container type (e.g. a `List` or `Map`), the following `Node` object added returns the declared type of the traversed container via `getContainerClass()` and the index of the affected type argument via `getTypeArgumentIndex()`#
* When a nested container is traversed (e.g. when traversing into the elements of the lists in `Map<String, List<@Valid Address>>`):
** [tck-testable]#if the value extractor of the outer container has provided a non-null node name, a `ContainerElementNode` object whose `name` equals that name is added to `Path`. The `ElementKind` of the node is `ElementKind.CONTAINER_ELEMENT`#
** [tck-testable]#if the container is a `List` or any other container whose value extractor invokes `ValueReceiver#indexedValue()`, the following `Node` object added contains the index value in `getIndex()`#
** [tck-testable]#if the container is a `Map` or any other container whose value extractor invokes `ValueReceiver#keyedValue()`, the following `Node` object added (representing a given map entry) contains the key value in `getKey()`#
** [tck-testable]#for all `Iterable`, `Map` or other container whose value extractor invokes `ValueReceiver#indexedValue()`, `ValueReceiver#keyedValue()` or `ValueReceiver#iterableValue()`, the following `Node` object added is marked as `inIterable` (`isInIterable()`)#
** [tck-testable]#the following `Node` object added returns the declared type of the traversed container via `getContainerClass()` and the index of the affected type argument via `getTypeArgumentIndex()`#

[tck-testable]
--
* For a property level constraint (field and getter)

** a [classname]`PropertyNode` object is added to [classname]`Path` whose `name` equals the name of the property (field name or Java Bean property name). The [classname]`ElementKind` of the node is [varname]`ElementKind.PROPERTY`.
** the property path is considered complete
--

[tck-testable]
--
* For a class level constraint:

** a [classname]`BeanNode` object is added to [classname]`Path` whose `name` is null. The [classname]`ElementKind` of the node is [varname]`ElementKind.BEAN`.
** the property path is considered complete
--

* For a method/constructor constraint (parameter, cross-parameter or return value constraint on a method or constructor):
** [tck-testable]#a [classname]`MethodNode` respectively a [classname]`ConstructorNode` object is added to the [classname]`Path` which represents the validated method respectively constructor. The `name` of the node equals the validated method name or the validated constructor's unqualified class name, the [classname]`ElementKind` of the node is [varname]`ElementKind.METHOD` respectively [varname]`ElementKind.CONSTRUCTOR`.#
** [tck-testable]#if the constraint is on a parameter, a [classname]`ParameterNode` object is added to the [classname]`Path` which represents the validated parameter. The `name` of the node equals the parameter name as determined by the current parameter name provider (see <<constraintdeclarationvalidationprocess-methodlevelconstraints-parameterconstraints-namingparameters>>). The [classname]`ElementKind` of the node is [varname]`ElementKind.PARAMETER`.#
** [tck-testable]#if the constraint is a cross-parameter constraint, a [classname]`CrossParameterNode` object is added to the [classname]`Path` which represents the validated cross-parameter element. The `name` of the node has the constant value `<cross-parameter>`. The [classname]`ElementKind` of the node is [varname]`ElementKind.CROSS_PARAMETER.`#
** [tck-testable]#if the constraint is on the return value, a [classname]`ReturnValueNode` object is added to the [classname]`Path` which represents the validated return value. The `name` of the node has the constant value `<return value>`. The [classname]`ElementKind` of the node is [varname]`ElementKind.RETURN_VALUE.`#
** [tck-testable]#the property path is considered complete#


* If a parameter or the return value of a method or constructor is traversed:
** [tck-testable]#a [classname]`MethodNode` respectively [classname]`ConstructorNode` object is added to the [classname]`Path` which represents the concerned method respectively constructor. The `name` of the node equals the concerned method name or the constructor's unqualified class name, the [classname]`ElementKind` of the node is [varname]`ElementKind.METHOD` or [varname]`ElementKind.CONSTRUCTOR`, respectively.#
** [tck-testable]#if a parameter is traversed, a [classname]`ParameterNode` object is added to the [classname]`Path` which represents the traversed parameter. The `name` of the node equals the parameter name as determined by the current parameter name provider. The [classname]`ElementKind` of the node is [varname]`ElementKind.PARAMETER`.#
** [tck-testable]#if a return value is traversed, a [classname]`ReturnValueNode` object is added to the [classname]`Path` which represents the traversed return value. The `name` of the node has the constant value `<return value>`. The [classname]`ElementKind` of the node is [varname]`ElementKind.RETURN_VALUE.`#
** [tck-testable]#if the parameter/return value is a [classname]`List` or an array, the following [classname]`Node` object added contains the index value in [methodname]`getIndex()`.#
** [tck-testable]#if the parameter/return value is a [classname]`Map`, the following [classname]`Node` object added (representing a given map entry) contains the key value in [methodname]`getKey()`.#
** [tck-testable]#for all [classname]`Iterable` or [classname]`Map`, the following [classname]`Node` object added is marked as `inIterable` ([methodname]`isInIterable()`).#

[tck-testable]
--
* For a container element constraint:

** if the corresponding value extractor (see <<valueextractordefinition>>) has specified a node name when calling one of the receiver methods, a [classname]`ContainerElementNode` object with that name is added to the `Path`.
The [classname]`ElementKind` of the node is [varname]`ElementKind.CONTAINER_ELEMENT`.
`getContainerClass()` returns the declared type of the container hosting the constraint.
`getTypeArgumentIndex()` returns the index of the type argument hosting the constraint.
If the constraint is given on a container and is subject to implicit application to the container's element(s) (see <<constraintdeclarationvalidationprocess-containerelementconstraints-implicitunwrapping>>) and the applied value extractor is not tied to a type parameter, `getTypeArgumentIndex()` returns null.
** if the corresponding value extractor has passed no node name to the called receiver method, no node is appended.
** the property path is considered complete
--

[tck-testable]
--
If additional path nodes are added in a constraint validator implementation using the node builder API (see <<constraintsdefinitionimplementation-validationimplementation>>), the following rules apply:

* if the default path ends with a [classname]`BeanNode`, this node is removed and the first added node (a [classname]`PropertyNode`) inherits its `inIterable`, `key` and `index` values. `inIterable`, `key` and `index` value must not be specified directly on this first node by the user.
* if the default path ends with a [classname]`CrossParameterNode`, this node is removed.
* then the additional nodes are appended to the (possibly amended) path generated by the {spec-name-bv} engine as previously described:
--

** [tck-testable]#A [classname]`PropertyNode` is appended in case [methodname]`addPropertyNode(String)` is invoked. The node name is equal to the name provided. The [classname]`ElementKind` of the node is `ElementKind.PROPERTY`.#
** [tck-testable]#A [classname]`BeanNode` is appended in case [methodname]`addBeanNode()` is invoked. The node name is `null`. The [classname]`ElementKind` of the node is `ElementKind.BEAN`.#
** [tck-testable]#A [classname]`ParameterNode` is appended in case [methodname]`addParameterNode(int)` is invoked. The node name is equal to the parameter name at the provided index. The name is determined by the current parameter name provider. The [classname]`ElementKind` of the node is `ElementKind.PARAMETER`. The previous node (removed) must be a [classname]`CrossParameterNode`.#
** [tck-testable]#A [classname]`ContainerElementNode` is appended in case [methodname]`addContainerElementNode(String, Class, Integer)` is invoked. The name, container type and type argument index of the node are equal to the values provided. The [classname]`ElementKind` of the node is `ElementKind.CONTAINER_ELEMENT`.#
** [tck-testable]#If [methodname]`inIterable()` is invoked, the node returns `true` for [methodname]`isInIterable()`, `false` otherwise.#
** [tck-testable]#If [methodname]`inContainer(Class, Integer)` is invoked, the node returns the passed container type and type argument index from `getContainerClass()` and `getTypeArgumentIndex()`, respectively.#
** [tck-testable]#If [methodname]`atIndex(Integer)` is invoked, the node returns the provided integer for [methodname]`getIndex()`, `null` otherwise.#
** [tck-testable]#If [methodname]`atKey(Object)` is invoked, the node returns the provided object for [methodname]`getKey()`, `null` otherwise.#

[NOTE]
====
A given [classname]`Node` object derives its `inIterable`, `key` and `index` properties from the previous association, method parameter or return value traversed.
The same applies to `typeArgumentIndex` and `containerClass` if the given node type defines these properties.
====

[NOTE]
====
From [methodname]`getRootBean()`, [methodname]`getPropertyPath()`, [methodname]`getExecutableParameters()` and [methodname]`getExecutableReturnValue()`, it is possible to rebuild the context of the failure.
====

[NOTE]
====
[classname]``ConstraintViolation``s occurred during standard {spec-name-bv} can be distinguished from violations occurred during method/constructor validation by analyzing the [classname]`ElementKind` of the [classname]`Node` of the first node in the violation's property path. In case of constructor or method validation, that [classname]`ElementKind` will be either [varname]`CONSTRUCTOR` or [varname]`METHOD`.
====

Let there be the following object definitions:

.Object model definition for examples
====

[source, JAVA]
----
@SecurityChecking
public class Author {
    private String firstName;

    @NonEmpty(message="lastname must not be null")
    private String lastName;

    @Size(max=30)
    private String company;

    [...]

    @OldAndNewPasswordsDifferent
    @NewPasswordsIdentical
    public void renewPassword(
            String oldPassword, String newPassword, String retypedNewPassword) {
        [...]
    }
}

@AvailableInStore(groups={Availability.class})
public class Book {
    @NonEmpty(groups={FirstLevelCheck.class, Default.class})
    private String title;

    @Valid
    @NotNull
    private List<Author> authors;

    @Valid
    private Map<String, Review> reviewsPerSource;

    @Valid
    private Review pickedReview;

    private List<@NotBlank String> tags;

    private Map<Integer, List<@NotBlank String>> tagsByChapter;

    private List<@Valid Category> categories;

    private Map<Integer, List<@Valid Author>> authorsByChapter;

    [...]
}

public class Review {

    @Min(0)
    private int rating;
    [...]
}

public class Category {

	@Size(min=3)
	private String name;

	// [...]
}

public class Library {

    public Library(@NotNull String name, @NotNull String location) {
        [...]
    }

    public void addBook(@NotNull @Valid Book book) {
        [...]
    }

    public void addAllBooks(@NotNull List<@Valid Book> books) {
        [...]
    }

    @NotNull public String getLocation() {
        [...]
    }

    public Map<Author, @Valid Book> getMostPopularBookPerAuthor() {
        [...]
    }
}
----

====

Assuming a [classname]`Book` instance gets validated, the property paths to the different constraints would be as described in <<table-propertypath>>:

[[table-propertypath]]

.propertyPath examples
[options="header"]
|===============
|Constraint|propertyPath
|[classname]`@AvailableInStore`  on [classname]`Book`|
BeanNode(name=null, inIterable=false, index=null, key=null, containerClass=null, typeArgumentIndex=null, kind=ElementKind.BEAN)

|[classname]`@NonEmpty`  on [classname]`Book.title`|
PropertyNode(name=title, inIterable=false, index=null, key=null, containerClass=null, typeArgumentIndex=null, kind=ElementKind.PROPERTY)

|[classname]`@NotNull`  on [classname]`Book.authors`|
PropertyNode(name=authors, inIterable=false, index=null, key=null, containerClass=null, typeArgumentIndex=null, kind=ElementKind.PROPERTY)

|[classname]`@SecurityChecking`  on the fourth author, [classname]`Author`|
PropertyNode(name=authors, inIterable=false, index=null, key=null, containerClass=null, typeArgumentIndex=null, kind=ElementKind.PROPERTY)

BeanNode(name=null, inIterable=true, index=3, key=null, containerClass=List.class, typeArgumentIndex=0, kind=ElementKind.BEAN)

|[classname]`@NonEmpty`  on the fourth author, [classname]`Author.lastname`|
PropertyNode(name=authors, inIterable=false, index=null, key=null, containerClass=null, typeArgumentIndex=null, kind=ElementKind.PROPERTY)

PropertyNode(name=lastName, inIterable=true, index=3, key=null, containerClass=List.class, typeArgumentIndex=0, kind=ElementKind.PROPERTY)

|[classname]`@Size`  on the first author, [classname]`Author.company`|
PropertyNode(name=authors, inIterable=false, index=null, key=null, containerClass=null, typeArgumentIndex=null, kind=ElementKind.PROPERTY)

PropertyNode(name=company, inIterable=true, index=0, key=null, containerClass=List.class, typeArgumentIndex=0, kind=ElementKind.PROPERTY)

|[classname]`@Min`  on the review associated to Consumer Report, [classname]`Review.rating`|
PropertyNode(name=reviewsPerSource, inIterable=false, index=null, key=null, containerClass=null, typeArgumentIndex=null, kind=ElementKind.PROPERTY)

PropertyNode(name=rating, inIterable=true, index=null, key="Consumer Report", containerClass=Map.class, typeArgumentIndex=1, kind=ElementKind.PROPERTY)

|[classname]`@Min`  on the picked review, [classname]`Review.rating`|
PropertyNode(name=pickedReview, inIterable=false, index=null, key=null, containerClass=null, typeArgumentIndex=null, kind=ElementKind.PROPERTY)

PropertyNode(name=rating, inIterable=false, index=null, key=null, containerClass=null, typeArgumentIndex=null, kind=ElementKind.PROPERTY)

|`@NotBlank` on the second tag, `Book.tags`|
PropertyNode(name=tags, inIterable=false, index=null, key=null, containerClass=null, typeArgumentIndex=null, kind=ElementKind.PROPERTY)

ContainerElementNode(name=<list element>, inIterable=true, index=1, key=null, containerClass=List.class, typeArgumentIndex=0, kind=ElementKind.CONTAINER_ELEMENT)

|`@NotBlank` on the third tag of chapter 4, `Book.tagsByChapter`|
PropertyNode(name=tagsByChapter, inIterable=false, index=null, key=null, containerClass=null, typeArgumentIndex=null, kind=ElementKind.PROPERTY)

ContainerElementNode(name=<map value>, inIterable=true, index=null, key=4, containerClass=Map.class, typeArgumentIndex=1, kind=ElementKind.CONTAINER_ELEMENT)

ContainerElementNode(name=<list element>, inIterable=true, index=2, key=null, containerClass=List.class, typeArgumentIndex=0, kind=ElementKind.CONTAINER_ELEMENT)

|`@Size` on the name of the second category, `Category.name`|
PropertyNode(name=categories, inIterable=false, index=null, key=null, containerClass=null, typeArgumentIndex=null, kind=ElementKind.PROPERTY)

PropertyNode(name=name, inIterable=true, index=1, key=null, containerClass=List.class, typeArgumentIndex=0, kind=ElementKind.PROPERTY)

|`@NonEmpty` on the last name of the third author of chapter 4, `Author.lastname`|
PropertyNode(name=authorsByChapter, inIterable=false, index=null, key=null, containerClass=null, typeArgumentIndex=null, kind=ElementKind.PROPERTY)

ContainerElementNode(name=<map value>, inIterable=true, index=null, key=4, containerClass=Map.class, typeArgumentIndex=1, kind=ElementKind.CONTAINER_ELEMENT)

PropertyNode(name=lastName, inIterable=true, index=2, key=null, containerClass=List.class, typeArgumentIndex=0, kind=ElementKind.PROPERTY)
|===============

Assuming the constructor and methods of the [classname]`Library` class are subject to method constraint validation and parameter names can be obtained for them, the following property paths would exist for the different constraints:

[[table-method-level-propertypath]]

.Property path examples for constrained methods or constructors
[options="header"]
|===============
|Constraint|propertyPath
|[classname]`@NotNull`  on the [varname]`location` parameter of the constructor|ConstructorNode(name=Library, inIterable=false, index=null, key=null, kind=ElementKind.CONSTRUCTOR, parameterTypes=[String.class,String.class])

ParameterNode(name=location, inIterable=false, index=null, key=null, kind=ElementKind.PARAMETER, parameterIndex=1)
|[classname]`@NotNull` on the [varname]`book` parameter of the [methodname]`addBook()`
              method|MethodNode(name=addBook, inIterable=false, index=null, key=null, kind=ElementKind.METHOD, parameterTypes=[Book.class])

ParameterNode(name=book, inIterable=false, index=null, key=null, kind=ElementKind.PARAMETER, parameterIndex=0)
|[classname]`@NonEmpty`  on
              [classname]`Book.title`  during validation of
              [methodname]`addBook()`|MethodNode(name=addBook, inIterable=false, index=null, key=null, kind=ElementKind.METHOD, parameterTypes=[Book.class])

ParameterNode(name=book, inIterable=false, index=null, key=null, kind=ElementKind.PARAMETER, parameterIndex=0)

PropertyNode(name=title, inIterable=false, index=null, key=null, containerClass=null, typeArgumentIndex=null, kind=ElementKind.PROPERTY)
|[classname]`@NonEmpty`  on fourth book,
              [classname]`Book.title`  during validation of
              [methodname]`addAllBooks()`|MethodNode(name=addAllBooks, inIterable=false, index=null, key=null, kind=ElementKind.METHOD, parameterTypes=[List.class])

ParameterNode(name=books, inIterable=false, index=null, key=null, kind=ElementKind.PARAMETER, parameterIndex=0)

PropertyNode(name=title, inIterable=true, index=3, key=null, containerClass=List.class, typeArgumentIndex=0, kind=ElementKind.PROPERTY)
|[classname]`@NotNull`  on the return value of
              the [methodname]`getLocation()`  method|MethodNode(name=getLocation, inIterable=false, index=null, key=null, kind=ElementKind.METHOD, parameterTypes=[])

ReturnValueNode(name=<return value>, inIterable=false, index=null, key=null, kind=ElementKind.RETURN_VALUE)
|[classname]`@NonEmpty`  on most popular book of
              author "John Doe", [classname]`Book.title`  during
              validation of
              [methodname]`getMostPopularBookPerAuthor()`|MethodNode(name=getMostPopularBookPerAuthor, inIterable=false, index=null, key=null, kind=ElementKind.METHOD, parameterTypes=[])

ReturnValueNode(name=<return value>, inIterable=false, index=null, key=null, kind=ElementKind.RETURN_VALUE)

PropertyNode(name=title, inIterable=true, index=null, key=Author(firstName=John, lastName=Doe), containerClass=Map.class, typeArgumentIndex=1, kind=ElementKind.PROPERTY)
|[classname]`@OldAndNewPasswordsDifferent`  when
              executing [methodname]`Author.renewPassword()`  with
              `oldPassword`, `newPassword`
              and `retypedNewPassword`  set to "foo".
              [classname]`@OldAndNewPasswordsDifferent`  is a
              cross-parameter constraint.|MethodNode(name=renewPassword, inIterable=false, index=null, key=null, kind=ElementKind.METHOD, parameterTypes=[String.class, String.class, String.class])

CrossParameterNode(name=<cross-parameter>, inIterable=false, index=null, key=null, kind=ElementKind.CROSS_PARAMETER)
|[classname]`@NewPasswordsIdentical`  when
              executing [methodname]`Author.renewPassword()`  with
              `oldPassword`  as "foo",
              `newPassword`  as "bar" and
              `retypedNewPassword`  as "baz".
              [classname]`@NewPasswordsIdentical`  is a
              cross-parameter constraint creating a constraint violation on
              the `retypedNewPassword`  parameter.|MethodNode(name=renewPassword, inIterable=false, index=null, key=null, kind=ElementKind.METHOD, parameterTypes=[String.class, String.class, String.class])

ParameterNode(name=retypedNewPassword, inIterable=false, index=null, key=null, kind=ElementKind.PARAMETER, parameterIndex=2)
|===============

[NOTE]
====
[tck-not-testable]#{spec-name-bv} implementations should ensure that a [classname]`ConstraintViolation` implementation is [classname]`Serializable` provided that the root bean, the leaf bean, the invalid value and keys in the [classname]`Path` object are [classname]`Serializable` objects.#

If a user wishes to send [classname]`ConstraintViolation` remotely, it should make sure the object graph validated is itself [classname]`Serializable`.
====

[[validationapi-constraintviolation-examples]]
==== Examples

These examples assume the following definition of [classname]`@NonEmpty`:

[source, JAVA, indent=0]
----
package com.acme.constraint;

include::{spec-examples-source-dir}org/beanvalidation/specexamples/validationapi/NonEmpty.java[tags=include]
----

And the following class definitions:

[source, JAVA, indent=0]
----
include::{spec-examples-source-dir}org/beanvalidation/specexamples/validationapi/Author.java[tags=include]
----

[source, JAVA, indent=0]
----
include::{spec-examples-source-dir}org/beanvalidation/specexamples/validationapi/Book.java[tags=include]
----

When executing the following validation:

[source, JAVA, indent=0]
----
include::{spec-examples-source-dir}org/beanvalidation/specexamples/validationapi/ValidationApiTest.java[tags=invocation]
----

Then `constraintViolations` is a set of size 3. One of the entries represents the failure of `@NonEmpty` (or more precisely [classname]`@Size(min=1)` a composing constraint of [classname]`@NonEmpty`) on the `title` property.

The [classname]`ConstraintViolation` object for this failure passes the following assertions:

.Test assertions on `ContraintViolation` for `title`
====

[source, JAVA, indent=0]
----
include::{spec-examples-source-dir}org/beanvalidation/specexamples/validationapi/ValidationApiTest.java[tags=title]
----

====

The second failure, `@NonEmpty` (or more precisely [classname]`@NotNull` a composing constraint of [classname]`@NonEmpty`) on the author's [methodname]`lastname`, will produce the [classname]`ConstraintViolation` object satisfying the following assertions:

.Test assertions on `ContraintViolation` for `lastName`
====

[source, JAVA, indent=0]
----
include::{spec-examples-source-dir}org/beanvalidation/specexamples/validationapi/ValidationApiTest.java[tags=lastName]
----

====

The third failure, `@Size` on one of the book's `tags`, will produce a `ConstraintViolation` object satisfying the following assertions:

.Test assertions on `ContraintViolation` for `tags`
====

[source, JAVA, indent=0]
----
include::{spec-examples-source-dir}org/beanvalidation/specexamples/validationapi/ValidationApiTest.java[tags=tags]
----

====

[[validationapi-constraintviolation-examplesexecutables]]
==== Examples for method and constructor constraint violations

The following examples assume the constraint, class and object definitions given in the previous section. Additionally the following class and object definitions are assumed:

[source, JAVA]
----
public class Library {

    @PublicLibrary
    public Library() {
        [...]
    }

    public Library(@NotNull List<@Valid Book> books) {
        [...]
    }

    public void addBook(@NotNull @Valid Book book) {
        [...]
    }

    @Valid public Map<Author, Book> getMostPopularBookPerAuthor() {
        [...]
    }
}

public class User {

    @OldAndNewPasswordsDifferent
    public void renewPassword(String oldPassword, String newPassword, String retypedNewPassword);
}

Library library = new Library();
author.setLastName("Doe");
----

Assuming the following invocation of [methodname]`addBook()` is subject to method parameter validation:

[source, JAVA]
----
library.addBook(null);
----

Then one [classname]`ConstraintViolation` object would be returned by [methodname]`ExecutableValidator.validateParameters()` which satisfies the following assertions:

[source, JAVA]
----
//assuming an english locale, the interpolated message is returned
assert "must not be null".equals( constraintViolation.getMessage() );

assert library == constraintViolation.getRootBean();
assert Library.class == constraintViolation.getRootBeanClass();
assert library == constraintViolation.getLeafBean();
assert null == constraintViolation.getInvalidValue();

assert new Object[]{ null }.equals( constraintViolation.getExecutableParameters() );
assert null == constraintViolation.getExecutableReturnValue();

Iterator<Node> nodeIter = constraintViolation.getPropertyPath().iterator();

Node node = nodeIter.next();
assert "addBook".equals( node.getName() );
assert ElementKind.METHOD.equals( node.getKind() );

node = nodeIter.next();
//assuming the default parameter name provider is used and parameter names can
//be obtained
assert "book".equals( node.getName() );
assert ElementKind.PARAMETER.equals( node.getKind() );

assert false == nodeIter.hasNext();
----

Assuming the following invocation of [methodname]`addBook()` is subject to method parameter validation:

[source, JAVA]
----
library.addBook(book);
----

Then one [classname]`ConstraintViolation` object would be returned by [methodname]`ExecutableValidator.validateParameters()` which satisfies the following assertions:

[source, JAVA]
----
//assuming an english locale, the interpolated message is returned
assert "may not be null or empty".equals( constraintViolation.getMessage() );

assert library == constraintViolation.getRootBean();
assert Library.class == constraintViolation.getRootBeanClass();
assert book == constraintViolation.getLeafBean();
assert book.getTitle().equals( constraintViolation.getInvalidValue() );

assert new Object[]{ book }.equals( constraintViolation.getExecutableParameters() );
assert null == constraintViolation.getExecutableReturnValue();

Iterator<Node> nodeIter = constraintViolation.getPropertyPath().iterator();

Node node = nodeIter.next();
assert "addBook".equals( node.getName() );
assert ElementKind.METHOD.equals( node.getKind() );

node = nodeIter.next();
//assuming the default parameter name provider is used and parameter names can
//be obtained
assert "book".equals( node.getName() );
assert ElementKind.PARAMETER.equals( node.getKind() );

node = nodeIter.next();
assert "title".equals( node.getName() );
assert ElementKind.PROPERTY.equals( node.getKind() );

assert false == nodeIter.hasNext();
----

Assuming the following invocation of [methodname]`User.renewPassword()` is subject to method parameter validation and the [classname]`@OldAndNewPasswordsDifferent` constraint is violated:

[source, JAVA]
----
User user = [...];
user.renewPassword("foo", "foo", "foo");
----

Then one [classname]`ConstraintViolation` object would be returned by [methodname]`ExecutableValidator.validateParameters()` which satisfies the following assertions:

[source, JAVA]
----
assert user == constraintViolation.getRootBean();
assert User.class == constraintViolation.getRootBeanClass();
assert user == getLeafBean();
assert new Object[]{ "foo", "foo", "foo" }.equals( constraintViolation.getInvalidValue() );

assert new Object[]{ "foo", "foo", "foo" }.equals( constraintViolation.getExecutableParameters() );
assert null == constraintViolation.getExecutableReturnValue();

Iterator<Node> nodeIter = constraintViolation.getPropertyPath().iterator();

Node node = nodeIter.next();
assert "renewPassword".equals( node.getName() );
assert ElementKind.METHOD.equals( node.getKind() );

node = nodeIter.next();
assert "<cross-parameter>" == node.getName();
assert ElementKind.CROSS_PARAMETER.equals( node.getKind() );

assert false == nodeIter.hasNext();
----

Assuming the following invocation of the [classname]`Library` constructor accepting a list of books is subject to constructor parameter validation:

[source, JAVA]
----
Library anotherLibrary = new Library(null);
----

Then one [classname]`ConstraintViolation` object would be returned by [methodname]`ExecutableValidator.validateConstructorParameters()` which satisfies the following assertions:

[source, JAVA]
----
//assuming an english locale, the interpolated message is returned
assert "must not be null".equals( constraintViolation.getMessage() );

assert null == constraintViolation.getRootBean();
assert Library.class == constraintViolation.getRootBeanClass();
assert null == constraintViolation.getLeafBean();
assert null == constraintViolation.getInvalidValue();

assert new Object[]{ null }.equals( constraintViolation.getExecutableParameters() );
assert null == constraintViolation.getExecutableReturnValue();

Iterator<Node> nodeIter = constraintViolation.getPropertyPath().iterator();

Node node = nodeIter.next();
assert "Library".equals( node.getName() );
assert ElementKind.CONSTRUCTOR.equals( node.getKind() );

node = nodeIter.next();
//assuming the default parameter name provider is used and parameter names can
//be obtained
assert "books".equals( node.getName() );
assert ElementKind.PARAMETER.equals( node.getKind() );

assert false == nodeIter.hasNext();
----

Assuming the following invocation of [methodname]`getMostPopularBookPerAuthor()` is subject to method return value validation and returns a [classname]`Map` containing one entry with key [varname]`author` and value [varname]`book`:

[source, JAVA]
----
Map<Author, Book> mostPopularBookPerAuthor = library.getMostPopularBookPerAuthor();
----

Then one [classname]`ConstraintViolation` object would be returned by [methodname]`ExecutableValidator.validateReturnValue()` which satisfies the following assertions:

[source, JAVA]
----
//assuming an english locale, the interpolated message is returned
assert "may not be null or empty".equals( constraintViolation.getMessage() );

assert library == constraintViolation.getRootBean();
assert Library.class == constraintViolation.getRootBeanClass();
assert book == constraintViolation.getLeafBean();
assert book.getTitle().equals( constraintViolation.getInvalidValue() );

assert null == constraintViolation.getExecutableParameters();
assert mostPopularBookPerAuthor == constraintViolation.getExecutableReturnValue();

Iterator<Node> nodeIter = constraintViolation.getPropertyPath().iterator();

Node node = nodeIter.next();
assert "getMostPopularBookPerAuthor".equals( node.getName() );
assert ElementKind.METHOD.equals( node.getKind() );

node = nodeIter.next();
assert "<return value>" == node.getName();
assert ElementKind.RETURN_VALUE.equals( node.getKind() );

node = nodeIter.next();
assert "title".equals( node.getName() );
assert ElementKind.PROPERTY.equals( node.getKind() );
assert author.equals( node.getKey() );
assert true == node.isInIterable();

assert false == nodeIter.hasNext();
----

Assuming the following invocation of the [classname]`Library` default constructor is subject to constructor return value validation and returns an instance which violates the [classname]`@PublicLibrary` constraint:

[source, JAVA]
----
Library publicLibrary = new Library();
----

Then one [classname]`ConstraintViolation` object would be returned by [methodname]`ExecutableValidator.validateConstructorReturnValue()` which satisfies the following assertions:

[source, JAVA]
----
assert null == constraintViolation.getRootBean();
assert Library.class == constraintViolation.getRootBeanClass();
assert publicLibrary == constraintViolation.getLeafBean();
assert publicLibrary == constraintViolation.getInvalidValue();

assert null == constraintViolation.getExecutableParameters();
assert library == constraintViolation.getExecutableReturnValue();

Iterator<Node> nodeIter = constraintViolation.getPropertyPath().iterator();

Node node = nodeIter.next();
assert "Library".equals( node.getName() );
assert ElementKind.CONSTRUCTOR.equals( node.getKind() );

node = nodeIter.next();
assert "<return value>" == node.getName();
assert ElementKind.RETURN_VALUE.equals( node.getKind() );

assert false == nodeIter.hasNext();
----

[[validationapi-message]]

=== Message interpolation

A message interpolator is responsible for transforming the so called message descriptor specified via the message attribute of the constraint into a fully expanded, human-readable error message.

[[validationapi-message-defaultmessageinterpolation]]

==== Default message interpolation

[tck-testable]#Every conforming {spec-name-bv} implementation includes a default message interpolator which has to comply with the algorithm defined here to interpolate message descriptors.# As precondition for message interpolation the following applies:

* [tck-testable]#Each constraint defines a message descriptor via its [methodname]`message` property.#
* [tck-testable]#Every constraint definition defines a default message descriptor for that constraint.#
* [tck-testable]#Messages can be overridden at constraint declaration time by setting the [methodname]`message` property on the constraint.#


[tck-testable]#The message descriptor is a string literal and may contain one or more message parameters or expressions. Message parameters and expressions are string literals enclosed in `{}` or `${}` respectively.# The following character escaping rules apply:

* [tck-testable]#[code]`\{` is considered as the literal `{` instead of being considered as the beginning of a message parameter#
* [tck-testable]#[code]`\}` is considered as the literal `}` instead of being considered as the end of a message parameter#
* [tck-testable]#[code]`\\` is considered as the literal `\` instead of being considered as the escaping character#
* [tck-testable]#[code]`\$` is considered as the literal `$` instead of being considered as the beginning of a message expression#


Below are two examples using message parameters and expressions. The second is evaluated using {spec-name-expressionlanguage} as defined in <<validationapi-message-defaultmessageinterpolation-expressionlanguage>>.

.Message using parameters
====

[source, JAVA]
----
Value must be between {min} and {max}
----

====

.Message using expressions
====

[source, JAVA]
----
Must be greater than ${inclusive == true ? 'or equal to ' : ''}{value}
----

====

[[validationapi-message-defaultmessageinterpolation-resolutionalgorithm]]

===== Default message interpolation algorithm

The default message interpolator uses the following steps:

. [tck-testable]#Message parameters are extracted from the message string and used as keys to search the [classname]`ResourceBundle` named `ValidationMessages`# (often materialized as the property file [filename]`/ValidationMessages.properties` and its locale variations) using the defined locale (see <<validationapi-message-defaultmessageinterpolation-locale>>). If a property is found, the message parameter is replaced with the property value in the message string. [tck-testable]#Step 1 is applied recursively until no replacement is performed# (i.e. a message parameter value can itself contain a message parameter).


. [tck-testable]#Message parameters are extracted from the message string and used as keys to search the {spec-name-bv} provider's built-in [classname]`ResourceBundle` using the defined locale (see <<validationapi-message-defaultmessageinterpolation-locale>>). If a property is found, the message parameter is replaced with the property value in the message string.# [tck-not-testable]#Contrary to step 1, step 2 is not processed recursively.#


. [tck-not-testable]#If step 2 triggers a replacement, then step 1 is applied again.# Otherwise step 4 is performed.


. [tck-testable]#Message parameters are extracted from the message string. Those matching the name of an attribute of the constraint are replaced by the value of that attribute in the constraint declaration. Parameter interpolation has precedence over message expressions. For example for the message descriptor `${value}`, trying to evaluate `{value}` as message parameter has precedence over evaluating `${value}` as message expression.#


. [tck-testable]#Message expressions are extracted from the message string and evaluated using {spec-name-expressionlanguage}. See also <<validationapi-message-defaultmessageinterpolation-expressionlanguage>>.#


[NOTE]
====
The proposed algorithm ensures that custom resource bundle always have priority over built-in resource bundle at all level of the recursive resolution. It also ensures that constraint declarations attributes values are not interpolated further.
====

[NOTE]
====
The precedence of message parameter over expression interpolation ensures backwards compatibility to {spec-name-bv} 1.0.
====

[[validationapi-message-defaultmessageinterpolation-locale]]

===== Locale for default message interpolation

The locale to be used for message interpolation is defined as following:

* [tck-testable]#if the locale is passed explicitly to the interpolator method via [methodname]`interpolate(String, Context, Locale)`, this provided instance is used.#
* [tck-testable]#otherwise, the default [classname]`Locale` as provided by [methodname]`Locale.getDefault()` is used.#




[[validationapi-message-defaultmessageinterpolation-expressionlanguage]]

===== Message expressions using {spec-name-expressionlanguage}

[tck-testable]#The default message interpolation allows the use of {spec-name-expressionlanguage}.# [tck-testable]#Expressions to be evaluated by {spec-name-expressionlanguage} need to be enclosed in `${}` within the message descriptor# . The following properties and beans have to be made available in the {spec-name-expressionlanguage} context:

* [tck-testable]#the attribute values of the constraint declaration mapped to their attribute name#
* [tck-testable]#the validated value mapped under the name `validatedValue`.#
* [tck-testable]#a bean mapped to the name `formatter` exposing the vararg method [methodname]`format(String format, Object\... args)`. This method must behave like [methodname]`java.util.Formatter.format(String format, Object\... args)`. The locale used for formatting is defined by <<validationapi-message-defaultmessageinterpolation-locale>>. The `formatter` bean allows to format property values, for example in the case of the validated value being 98.12345678, `${formatter.format('%1$.2f', validatedValue)}` would format it to 98.12 (two digits after the decimal point, where the use of '.' vs ',' would be locale specific).#


[tck-testable]#If an exception occurs during message interpolation, e.g. due to invalid expressions or references to an unknown property, the message expression stays unchanged.#

[[validationapi-message-customresolution]]

==== Custom message interpolation

A custom message interpolator may be provided (e.g., to interpolate contextual data, or to adjust the default [classname]`Locale` used). A message interpolator implements the [classname]`MessageInterpolator` interface.

[role="api"]
.`MessageInterpolator` interface
====
[source, JAVA, indent=0]
----
include::{validation-api-source-dir}jakarta/validation/MessageInterpolator.java[lines=12..-1]
----
====

[tck-testable]#[parameter]`messageTemplate` is the value of the `message` attribute of the constraint declaration or provided to the [classname]`ConstraintValidatorContext` methods.#

The [classname]`Context` object contains contextual information related to the interpolation.

[tck-testable]#[methodname]`getConstraintDescriptor()` returns the [classname]`ConstraintDescriptor` object representing the metadata of the failing constraint (see <<constraintmetadata>>).#

[tck-testable]#[methodname]`getValidatedValue()` returns the value being validated.#

[methodname]`MessageInterpolator.interpolate(String, Context)` is invoked for each constraint violation report generated. The default [classname]`Locale` of custom message interpolators is implementation specific.

[methodname]`MessageInterpolator.interpolate(String, Context, Locale)` can be invoked by a wrapping [classname]`MessageInterpolator` to enforce a specific [classname]`Locale` value by bypassing or overriding the default [classname]`Locale` strategy (see <<validationapi-message-examples-specificlocale>>).

[tck-not-testable]#A message interpolator implementation must be thread-safe.#

The message interpolator is provided to the [classname]`ValidatorFactory` at construction time using [methodname]`Configuration.messageInterpolator(MessageInterpolator)`. This message interpolator is shared by all [classname]`Validator` objects generated by this [classname]`ValidatorFactory`.

[tck-testable]#It is possible to override the [classname]`MessageInterpolator` implementation for a given [classname]`Validator` instance by invoking [methodname]`ValidatorFactory.usingContext().messageInterpolator(messageInterpolator).getValidator()`.#

It is recommended that [classname]`MessageInterpolator` implementations delegate final interpolation to the {spec-name-bv} default [classname]`MessageInterpolator` to ensure standard {spec-name-bv} interpolation rules are followed, [tck-testable]#The default implementation is accessible through [methodname]`Configuration.getDefaultMessageInterpolator()`.#

[tck-testable]#If the interpolation process leads to an exception, the exception is wrapped into a [classname]`ValidationException`.#

[[validationapi-message-examples]]

==== Examples

These examples describe message interpolation based on the default message interpolator's built-in messages (see <<standard-resolver-messages>>), and the [filename]`ValidationMessages.properties` file shown in table <<table-messageinterpolation>>. The current locale is assumed English.

[source, JAVA]
----
//ValidationMessages.properties
myapp.creditcard.error=credit card number not valid
----

[[table-messageinterpolation]]

.message interpolation
|===============
|Failing constraint declaration|interpolated message
|[classname]`@NotNull`|must not be null
|[classname]`@Max(30)`|must be less than or equal to 30
|[classname]`@Size(min=5, max=15, message="Key must have \\{{min}\\} \\ \\{{max}\\} characters")`|Key must have {5} \ {15} characters
|[classname]`@Digits(integer=9, fraction=2)`|numeric value out of bounds (<9 digits>.<2
              digits> expected)
|[classname]`@CreditCard(message={myapp.creditcard.error})`|credit card number not valid
|===============

Here is an approach to specify the [classname]`Locale` value to choose on a given [classname]`Validator` using a [classname]`Locale` aware [classname]`MessageInterpolator`. See <<validationapi-bootstrapping>> for more details on the APIs.

[[validationapi-message-examples-specificlocale]]

.Use MessageInterpolator to use a specific Locale value
====

[source, JAVA]
----
/**
 * Delegates to a MessageInterpolator implementation but enforces a given Locale
 */
public class LocaleSpecificMessageInterpolator implements MessageInterpolator {
    private final MessageInterpolator defaultInterpolator;
    private final Locale defaultLocale;

    public LocaleSpecificMessageInterpolator(MessageInterpolator interpolator, Locale locale) {
        this.defaultLocale = locale;
        this.defaultInterpolator = interpolator;
    }

    /**
     * enforces the locale passed to the interpolator
     */
    @Override
    public String interpolate(String message,
                              Context context) {
        return defaultInterpolator.interpolate(message,
                                               context,
                                               this.defaultLocale);
    }

    // no real use, implemented for completeness
    @Override
    public String interpolate(String message,
                              Context context,
                              Locale locale) {
        return defaultInterpolator.interpolate(message, context, locale);
    }
}


Locale locale = getMyCurrentLocale();
MessageInterpolator interpolator = new LocaleSpecificMessageInterpolator(
                                       validatorFactory.getMessageInterpolator(),
                                       locale);

Validator validator = validatorFactory.usingContext()
                                      .messageInterpolator(interpolator)
                                      .getValidator();
----

====

Most of the time, however, the relevant [classname]`Locale` will be provided by your application framework transparently. This framework will implement its own version of [classname]`MessageInterpolator` and pass it during the [classname]`ValidatorFactory` configuration. The application will not have to set the [classname]`Locale` itself. This example shows how a container framework would implement [classname]`MessageInterpolator` to provide a user specific default locale.

[[validationapi-message-examples-faceslocale]]

.Contextual container possible [classname]`MessageInterpolator` implementation
====

[source, JAVA]
----
public class ContextualMessageInterpolator implements MessageInterpolator {
    private final MessageInterpolator delegate;

    public ContextualMessageInterpolator(MessageInterpolator delegate) {
        this.delegate = delegate;
    }

    @Override
    public String interpolate(String message, Context context) {
        Locale locale = Container.getManager().getUserLocale();
        return this.delegate.interpolate(
                        message, context, locale );
    }

    @Override
    public String interpolate(String message, Context context, Locale locale) {
        return this.delegate.interpolate(message, context, locale);
    }
}


//Build the ValidatorFactory
Configuration<?> configuration = Validation.byDefaultProvider().configure();
ValidatorFactory factory = configuration
    .messageInterpolator(
        new ContextualMessageInterpolator(
                configuration.getDefaultMessageInterpolator() ) )
    .buildValidatorFactory();

//The container uses the factory to validate constraints using the specific MessageInterpolator
Validator validator = factory.getValidator();
----

====

[[validationapi-triggeringmethodvalidation]]

=== Triggering method validation

{spec-name-bv} itself doesn't trigger the evaluation of method constraints. That is, just annotating any methods or constructors with parameter or return value constraints doesn't automatically enforce these constraints, just as annotating any fields or properties with bean constraints doesn't enforce these either.

Instead method constraints must be validated by invoking the appropriate methods on [classname]`jakarta.validation.executable.ExecutableValidator`. Typically this won't happen by manually calling these methods but rather automatically upon invocation of the constrained methods or constructors, using approaches and techniques such as {spec-name-di}/{spec-name-enterprisebeans} interceptors, aspect-oriented programming or dynamic proxies.

[tck-testable]
--
The validation of method / constructor constraints comprises the following steps:

* Intercept the method call to be validated
* Validate the parameter values provided by the method caller using [methodname]`ExecutableValidator.validateParameters()` or [methodname]`ExecutableValidator.validateConstructorParameters()`.
* If this validation yields a non-empty set of constraint violations, throw a [classname]`ConstraintViolationException` wrapping the violations. Otherwise proceed with the actual method invocation.
* Validate the result returned by the invoked method using [methodname]`ExecutableValidator.validateReturnValue()` or [methodname]`ExecutableValidator.validateConstructorReturnValue()`.
* If this validation yields a non-empty set of constraint violations, throw a [classname]`ConstraintViolationException` wrapping the violations. Otherwise return the invocation result to the method caller.
--

By throwing a [classname]`ConstraintViolationException` if either of the validation steps fails, it is ensured that the control flow

* only arrives at the method's body if the caller has satisfied the method's preconditions and
* only returns to the method caller if the method's postconditions are guaranteed.


By default, integrators intercept and validate methods either hosting a constraint or being marked for cascaded validation ([classname]`@Valid`) whether it be on the method itself or on any of its parameters. [tck-testable]#The [classname]`Default` group is used for validation out of the box.#

Integrators are encouraged to use {spec-name-bv}'s metadata API to find whether or not a method or a constructor should be intercepted. This guarantees that XML descriptors as well as future mapping strategies are taken into account. Note that the metadata API does not take into account the fact that a method or constructor validation has been enabled or disabled by the techniques described in <<integration-general-executable>>.

Here is an example of what such metadata usage would be:

.Using metadata API to figure out if method interception is required
====

[source, JAVA]
----
//For methods

// is there any constrained method on this type
// assuming we don't validate on getter execution
public boolean interceptMethods(Class<?> type) {
    return validator.getConstraintsForClass( type ).getConstrainedMethods(MethodType.NON_GETTER).size() > 0;
}

// is this method constrained
public boolean interceptMethod(Class<?> type, Method method) {
    BeanDescriptor bean = validator.getConstraintsForClass( type );
    MethodDescriptor methodDescriptor = bean.getConstraintsForMethod(
        method.getName(), method.getParameterTypes() );
    return methodDescriptor != null;
}

// should method parameters be validated
public boolean requiresParametersValidation(Class<?> type, Method method) {
    BeanDescriptor bean = validator.getConstraintsForClass( type );
    MethodDescriptor methodDescriptor = bean.getConstraintsForMethod(
        method.getName(), method.getParameterTypes() );
    if ( methodDescriptor != null ) {
        return methodDescriptor.hasConstrainedParameters();
    }
    else {
        return false;
    }
}

// should method return value be validated?
public boolean requiresReturnValueValidation(Class<?> type, Method method) {
    BeanDescriptor bean = validator.getConstraintsForClass( type );
    MethodDescriptor methodDescriptor = bean.getConstraintsForMethod(
        method.getName(), method.getParameterTypes() );
    if ( methodDescriptor != null ) {
        return methodDescriptor.hasConstrainedReturnValue();
    }
    else {
        return false;
    }
}
----

====

.Using metadata API to figure out if constructor interception is required
====

[source, JAVA]
----
//For constructors

// is there any constrained constructor on this type
public <T> boolean interceptConstructors(Class<T> type) {
    BeanDescriptor bean = validator.getConstraintsForClass( type );
    return bean.getConstrainedConstructors().size() > 0;
}

// is this constructor constrained
public <T> boolean interceptConstructor(Class<T> type, Constructor<T> ctor) {
    BeanDescriptor bean = validator.getConstraintsForClass( type );
    ConstructorDescriptor constructorDescriptor = bean.getConstraintsForConstructor(
        ctor.getParameterTypes() );
    return constructorDescriptor != null;
}

// should constructor parameters be validated
public <T> boolean requiresParametersValidation(Class<T> type, Constructor<T> ctor) {
    BeanDescriptor bean = validator.getConstraintsForClass( type );
    ConstructorDescriptor constructorDescriptor = bean.getConstraintsForConstructor(
        ctor.getParameterTypes() );
    if ( constructorDescriptor != null ) {
        return constructorDescriptor.hasConstrainedParameters();
    }
    else {
        return false;
    }
}

// should constructor return value be validated?
public <T> boolean requiresReturnValueValidation(Class<T> type, Constructor<T> ctor) {
    BeanDescriptor bean = validator.getConstraintsForClass( type );
    ConstructorDescriptor constructorDescriptor = bean.getConstraintsForConstructor(
        ctor.getName(),
        ctor.getParameterTypes()
    );
    if ( constructorDescriptor != null ) {
        return constructorDescriptor.hasConstrainedReturnValue();
    }
    else {
        return false;
    }
}
----

====

[NOTE]
====
Calls to the metadata API is likely only going to be needed during the initialization phase of the interception framework. Results can then be cached.
====

[NOTE]
====
Only methods or constructors intercepted by the underlying interception technology can be validated.
====

The integration technology must put the validation interceptor as late as possible (if not last) in the interception stack. In particular, validation of parameters should be done after the security and transaction start logic. Likewise, return value validation should be done before the transaction stop logic. Putting the validation interceptor as late as possible in the stack ensures this.

[NOTE]
.Why have the validation interceptor after other interceptors?
====
There are several reasons for delaying validation compared to other interceptors:

* You don't want to start business code before security has been cleared
* You might need transaction support in your validations
* You want transaction to fail if the return value is invalid
* Generally speaking, it makes more sense to apply technical layers around the more business focused constraints



====

[[validationapi-bootstrapping]]

=== Bootstrapping

The bootstrapping API aims at providing a [classname]`ValidatorFactory` object which is used to create [classname]`Validator` instances. The bootstrap process is decoupled from the provider implementation initialization: [tck-testable]#a bootstrap implementation must be able to bootstrap any {spec-name-bv} provider implementation.# The bootstrap sequence has been designed to achieve several goals:

* plug multiple implementations
* choose a specific implementation
* extensibility: an application using a specific provider implementation can use specific configurations
* share and reuse of metadata across [classname]``Validator``s
* leave as much freedom as possible to implementations
* provide integration mechanisms to {spec-name-eeplatform} (starting from version 6) and other containers
* type safety


The main artifacts involved in the bootstrap process are:

* [classname]`Validation`: API entry point. Lets you optionally define the {spec-name-bv} provider targeted as well as a provider resolution strategy. [classname]`Validation` generates [classname]`Configuration` objects and can bootstrap any provider implementation.
* [classname]`ValidationProvider`: contract between the bootstrap procedure and a {spec-name-bv} provider implementation.
* [classname]`ValidationProviderResolver`: returns a list of all {spec-name-bv} providers available in the execution context (generally the classpath).
* [classname]`Configuration`: collects the configuration details that will be used to build [classname]`ValidatorFactory`. A specific sub interface of [classname]`Configuration` must be provided by {spec-name-bv} providers. This sub interface typically hosts provider specific configurations.
* [classname]`ValidatorFactory`: result of the bootstrap process. Build [classname]`Validator` instances from a given {spec-name-bv} provider.
* [filename]`META-INF/validation.xml`: a configuration file {spec-name-bv} users can use to customize the configuration of the default [classname]`ValidatorFactory`.


Let's first see the API in action through some examples before diving into the concrete definitions.

[[validationapi-bootstrapping-examples]]
==== Examples

The most simple approach is to initialize the default {spec-name-bv} provider or the one defined in the XML configuration file. The [classname]`ValidatorFactory` is then ready to provide [classname]`Validator` instances.

.Simple {spec-name-bv} bootstrap sequence
====

[source, JAVA]
----
ValidatorFactory factory = Validation.buildDefaultValidatorFactory();

//cache the factory somewhere
Validator validator = factory.getValidator();

//when the application shuts down, close ValidatorFactory
factory.close();
----

====

[tck-not-testable]#The [classname]`ValidatorFactory` object is thread-safe.# Building [classname]`Validator` instances is typically a cheap operation. Building a [classname]`ValidatorFactory` is typically more expensive. Make sure to check your {spec-name-bv} implementation documentation for more accurate details.

The second example shows how a container can customize aspects like message interpolation, constraint validator instantiation and others.

.Customize message resolution, traversable resolver etc.
====

[source, JAVA]
----
//some customization from a container
ValidatorFactory factory = Validation
       .byDefaultProvider().configure()
          .messageInterpolator( new ContainerMessageInterpolator() )
          .constraintValidatorFactory( new ContainerComponentConstraintValidatorFactory() )
          .traversableResolver( new JPAAwareTraversableResolver() )
          .parameterNameProvider( new AnnotationBasedParameterNameProvider() )
          .clockProvider( new BatchJobClockProvider() )
          .addValueExtractor( new TableValueExtractor() )
          .addValueExtractor( new MultiMapValueExtractor() )
          .buildValidatorFactory();

//cache the factory somewhere
Validator validator = factory.getValidator();

//when the application shuts down, close ValidatorFactory
factory.close();
----

====

The third example shows how to bootstrap {spec-name-bv} in an environment not following the traditional Java class loader strategies (such as tools or alternative service containers like OSGi). They can provide some alternative provider resolution strategy to discover {spec-name-bv} providers.

.Customize the {spec-name-bv} provider resolution mechanism
====

[source, JAVA]
----
//osgi environment
ValidatorFactory factory = Validation
       .byDefaultProvider()
          .providerResolver( new OSGiServiceDiscoverer() )
          .configure()
             .buildValidatorFactory();

//cache the factory somewhere
Validator validator = factory.getValidator();

//when the bundle shuts down, close ValidatorFactory
factory.close();
----

====

The next example shows how a client can choose a specific {spec-name-bv} provider and configure provider specific properties programmatically in a type-safe way.

.Use a specific provider and add specific configuration
====

[source, JAVA]
----
ValidatorFactory factory = Validation
       .byProvider( ACMEProvider.class )  //chose a specific provider
       .configure()
          .messageInterpolator( new ContainerMessageInterpolator() ) //default configuration option
          .addConstraint(Address.class, customConstraintDescriptor) //ACME specific method
          .buildValidatorFactory();

//same initialization decomposing calls
ACMEConfiguration acmeConfiguration = Validation
       .byProvider( ACMEProvider.class )
       .configure();

ValidatorFactory factory = acmeConfiguration
          .messageInterpolator( new ContainerMessageInterpolator() ) //default configuration option
          .addConstraint(Address.class, customConstraintDescriptor) //ACME specific method
          .buildValidatorFactory();

/**
 * ACME specific validator configuration and configuration options
 */
public interface ACMEConfiguration extends Configuration<ACMEConfiguration> {
    /**
     * Programmatically add constraints. Specific to the ACME provider.
     */
    ACMEConfiguration addConstraint(Class<?> entity,
                                    ACMEConstraintDescriptor constraintDescriptor);
}

/**
 * ACME validation provider
 * Note how ACMEConfiguration and ACMEProvider are linked together
 * via the generic parameter.
 */
public class ACMEProvider implements ValidationProvider<ACMEConfiguration> {
    [...]
}
----

====

The last example shows how a [classname]`Validator` can use a specific [classname]`MessageInterpolator` implementation.

.Use a specific MessageInterpolator instance for a given Validator
====

[source, JAVA]
----
ValidatorFactory factory = [...];
MessageInterpolator customInterpolator = new LocaleSpecificMessageInterpolator(
    locale,
    factory.getMessageInterpolator()
);

Validator localizedValidator =
    factory.usingContext()
                   .messageInterpolator(customInterpolator)
                   .getValidator();
----

====

In the same way, a custom [classname]`TraversableResolver` can be passed.

We will now explore the various interfaces, their constraints and usage. We will go from the [classname]`ValidatorFactory` to the [classname]`Validation` class walking up the bootstrap chain.

[[validationapi-bootstrapping-validatorfactory]]
==== ValidatorFactory

[classname]`ValidatorFactory` objects build and provide initialized instances of [classname]`Validator` to {spec-name-bv} clients. Each [classname]`Validator` instance is configured for a given context (message interpolator, traversable resolver etc.). Clients should cache [classname]`ValidatorFactory` objects and reuse them for optimal performances. The API is designed to allow implementors to share constraint metadata in [classname]`ValidatorFactory`. [classname]`ValidatorFactory` instances must be closed (by calling the [methodname]`close()` method) by its creator when no longer in use.

[tck-not-testable]#[classname]`ValidatorFactory` implementations must be thread-safe.# [classname]`ValidatorFactory` implementations can cache [classname]`Validator` instances if needed.

[role="api"]
.`ValidatorFactory` interface
====

[source, JAVA]
----
include::{validation-api-source-dir}jakarta/validation/ValidatorFactory.java[lines=9..-1]
----

====

A [classname]`ValidatorFactory` is provided by a [classname]`Configuration` object.

[methodname]`unwrap()` is provided as a way to access objects of a given type specific to a {spec-name-bv} provider typically as a complement to the [classname]`ValidatorFactory` contract. Using this method makes your code non portable.

.Using unwrap to access a provider specific contract
====

[source, JAVA]
----
//if using the ACME provider
ACMEValidatorFactory acmeFactory = factory.unwrap(ACMEValidatorFactory.class);
acmeFactory.setSpecificConfiguration( [...] );
----

====

[methodname]`close()` closes the [classname]`ValidatorFactory` instance which becomes unavailable and should be immediately discarded. This is also true of all the [classname]`Validator` instances it has spawned. The behavior is undefined and non portable if these instances are used after the [classname]`ValidatorFactory` has been closed.

[tck-testable]#[methodname]`getMessageInterpolator()` returns the [classname]`MessageInterpolator` instance configured during the initialization of the [classname]`ValidatorFactory`.# It is particularly useful to build a [classname]`Validator` specific [classname]`MessageInterpolator` wrapping the one from the [classname]`ValidatorFactory`.

[tck-testable]#[methodname]`getTraversableResolver()` returns the [classname]`TraversableResolver` instance configured during the initialization of the [classname]`ValidatorFactory`.# It is particularly useful to build a [classname]`Validator` specific [classname]`TraversableResolver` wrapping the one from the [classname]`ValidatorFactory`.

[tck-testable]#[methodname]`getConstraintValidatorFactory()` returns the [classname]`ConstraintValidatorFactory` instance configured during the initialization of the [classname]`ValidatorFactory`.# It is particularly useful to build a [classname]`Validator` specific [classname]`ConstraintValidatorFactory` wrapping the one from the [classname]`ValidatorFactory`.

[tck-testable]#[methodname]`getParameterNameProvider()` returns the [classname]`ParameterNameProvider` instance configured during the initialization of the [classname]`ValidatorFactory`.# It is particularly useful to build a [classname]`Validator` specific [classname]`ParameterNameProvider` wrapping the one from the [classname]`ValidatorFactory`.

[tck-testable]#[methodname]`getClockProvider()` returns the [classname]`ClockProvider` instance configured during the initialization of the [classname]`ValidatorFactory`.# It is particularly useful to build a [classname]`Validator` specific [classname]`ClockProvider` wrapping the one from the [classname]`ValidatorFactory`.

[classname]`ValidatorContext` returned by [methodname]`usingContext()` can be used to customize the state in which the [classname]`Validator` must be initialized. This is used to customize the [classname]`MessageInterpolator`, the [classname]`TraversableResolver`, the [classname]`ParameterNameProvider`, the  [classname]`ClockProvider` or the [classname]`ConstraintValidatorFactory`.

[role="api"]
.`ValidatorContext` interface
====

[source, JAVA]
----
include::{validation-api-source-dir}jakarta/validation/ValidatorContext.java[lines=12..-1]
----

====

[tck-testable]#The `MessageInterpolator`, the `TraversableResolver`, the `ConstraintValidatorFactory`, the `ParameterNameProvider` or the `ClockProvider` passed to the `ValidatorContext` are used instead of the ``ValidatorFactory``'s `MessageInterpolator`, `TraversableResolver`, `ConstraintValidatorFactory`, `ParameterNameProvider` or `ClockProvider` instances.#
[tck-testable]#A `ValueExtractorDeclarationException` is raised if more than one extractor for the same type and type parameter is added via `addValueExtractor()`.#

.Use of ValidatorFactory
====

[source, JAVA]
----
ValidatorFactory factory = [...];
Validator validatorUsingDefaults = factory.getValidator();
Validator validatorUsingCustomTraversable = factory
                     .usingContext()
                     .traversableResolver( new JPATraversableResolver() )
                     .getValidator();
----

====

See <<validationapi-message-examples-specificlocale>> for an example using [methodname]`ValidatorFactory.getMessageInterpolator()`.

[[validationapi-bootstrapping-configuration]]
==== Configuration

The responsibility of the [classname]`Configuration` is to collect configuration information, to determine the correct provider implementation and to delegate the [classname]`ValidatorFactory` creation to the selected provider. More concretely [classname]`Configuration` lets you define:

* the message interpolator instance
* the traversable resolver instance
* the constraint validator factory instance
* the parameter name provider instance
* the clock provider instance
* value extractor instances
* XML constraint mappings
* provider specific properties
* whether or not [classname]`META-INF/validation.xml` is considered

[tck-testable]#[classname]`Configuration` does provide a [classname]`MessageInterpolator` implementation following the default {spec-name-bv} [classname]`MessageInterpolator` rules as defined in <<validationapi-message-defaultmessageinterpolation>>. You can access it by calling [methodname]`getDefaultMessageInterpolator()`.# Such an implementation is useful to let a custom [classname]`MessageInterpolator` delegate to the standard [classname]`MessageInterpolator` (see <<validationapi-message-customresolution>> and an example making use of [methodname]`getDefaultMessageInterpolator()` in <<validationapi-message-examples-faceslocale>>).

[tck-testable]#[classname]`Configuration` does provide a [classname]`TraversableResolver` implementation following the default {spec-name-bv} [classname]`TraversableResolver` rules as defined in <<constraintdeclarationvalidationprocess-validationroutine-traversable>>. You can access it by calling [methodname]`getDefaultTraversableResolver()`.# Such an implementation is useful to let a custom [classname]`TraversableResolver` delegate to the standard [classname]`TraversableResolver`.

[tck-testable]#[classname]`Configuration` does provide a [classname]`ConstraintValidatorFactory` implementation following the default {spec-name-bv} [classname]`ConstraintValidatorFactory` rules as defined in <<constraintsdefinitionimplementation-constraintfactory>>. You can access it by calling [methodname]`getDefaultConstraintValidatorFactory()`.# Such an implementation is useful to let a custom [classname]`ConstraintValidatorFactory` delegate to the standard [classname]`ConstraintValidatorFactory`.

[tck-testable]#[classname]`Configuration` does provide a [classname]`ParameterNameProvider` implementation following the default {spec-name-bv} [classname]`ParameterNameProvider` rules as defined in <<constraintdeclarationvalidationprocess-methodlevelconstraints-parameterconstraints-namingparameters>>. You can access it by calling [methodname]`getDefaultParameterNameProvider()`.# Such an implementation is useful to let a custom [classname]`ParameterNameProvider` delegate to the standard [classname]`ParameterNameProvider`.

[tck-testable]#[classname]`Configuration` does provide a [classname]`ClockProvider` implementation following the default {spec-name-bv} [classname]`ClockProvider` rules as defined in <<constraintsdefinitionimplementation-validationimplementation-temporalvalidators>>. You can access it by calling [methodname]`getDefaultClockProvider()`.#

[tck-testable]#Via [classname]`getBootstrapConfiguration()`, [classname]`Configuration` also exposes data stored in [classname]`META-INF/validation.xml`# (see <<validationapi-bootstrapping-xmlconfiguration>>). This is particularly useful for containers wishing to control the instance creation and lifecycle (more information at <<validationapi-bootstrapping-usageandcontainerexpectation>>).

[NOTE]
====
[methodname]`BootstrapConfiguration.getDefaultValidatedExecutableTypes()` and [methodname]`BootstrapConfiguration.isExecutableValidationEnabled()` are not used by the {spec-name-bv} engine but exposed here for interception technologies - see <<integration-general-executable>>.
====

[tck-testable]#Via `addValueExtractor()`, additional value extractor implementations can be added to the configuration.
A value extractor for a given type and type parameter takes precedence over any extractor for the same type and type parameter
detected through the service loader or given in the XML configuration.#
[tck-testable]#A `ValueExtractorDeclarationException` is raised if more than one extractor for the same type and type parameter is added.#

[tck-testable]#Using [methodname]`addMapping()`, additional constraint mapping XML descriptors can be added to the configuration# (see <<validationapi-bootstrapping-xmlconfiguration>>). The given input streams should support the [methodname]`mark()` and [methodname]`reset()` methods defined by [classname]`java.io.InputStream`. [tck-testable]#Streams not supporting the [methodname]`mark()` and [methodname]`reset()` methods will be wrapped with an [classname]`InputStream` implementation supporting these methods by the {spec-name-bv} provider in order to allow the streams to be read several times.#

Clients call [methodname]`Configuration.buildValidatorFactory()` to retrieve the initialized [classname]`ValidatorFactory` instance. [tck-testable]#It is legal to invoke [methodname]`buildValidatorFactory()` several times, e.g. in order to retrieve several [classname]`ValidatorFactory` instances with a slightly different configuration (see <<using-configuration-several-times>>).#

[role="api"]
.`Configuration` and `BootstrapConfiguration` interfaces
====

[source, JAVA]
----
include::{validation-api-source-dir}jakarta/validation/Configuration.java[lines=15..-1]
----

[source, JAVA]
----
include::{validation-api-source-dir}jakarta/validation/BootstrapConfiguration.java[lines=17..-1]
----

====

[tck-testable]#A {spec-name-bv} provider must define a sub interface of [classname]`Configuration` uniquely identifying the provider.# This subclass is linked to its provider via the [classname]`ValidationProvider` generic parameter. The [classname]`Configuration` sub interface typically hosts provider specific configuration methods.

To facilitate the use of provider specific configuration methods, [classname]`Configuration` uses generics: [classname]`Configuration<T extends Configuration<T>>` ; the generic return type [classname]`T` is returned by chaining methods. The provider specific sub interface must resolve the generic T as itself as shown in <<example-providerspecific-config>>.

[[example-providerspecific-config]]

.Example of provider specific Configuration sub interface
====

[source, JAVA]
----
/**
 * Unique identifier of the ACME provider
 * also hosts some provider specific configuration methods
 */
public interface ACMEConfiguration
    extends Configuration<ACMEConfiguration> {

    /**
     * Enables constraints implementation dynamic reloading when using ACME
     * default to false
     */
    ACMEConfiguration enableDynamicReloading(boolean);

}
----

====

When [methodname]`Configuration.buildValidatorFactory()` is called, the initialized [classname]`ValidatorFactory` is returned. More specifically, the requested {spec-name-bv} provider is determined and the result of [code]`validationProvider.buildValidatorFactory(ConfigurationState)` is returned. [classname]`ConfigurationState` gives access to the configuration artifacts defined in [filename]`META-INF/validation.xml` (unless XML configuration is ignored) and provided programmatically to [classname]`Configuration`. Generally speaking, programmatically defined elements have priority over XML defined configuration elements (read the [classname]`Configuration` JavaDoc and see <<validationapi-bootstrapping-xmlconfiguration>> for more information).

[NOTE]
====
A typical implementation of [classname]`Configuration` also implements [classname]`ConfigurationState`, hence [code]`this` can be passed to [methodname]`buildValidatorFactory(ConfigurationState)`.
====

[tck-not-testable]#Streams represented in the XML configuration and opened by the [classname]`Configuration` implementation must be closed by the [classname]`Configuration` implementation after the [classname]`ValidatorFactory` creation (or if an exception occurs).# Streams provided programmatically are the responsibility of the application.

[role="api"]
.`ConfigurationState` interface
====

[source, JAVA]
----
include::{validation-api-source-dir}jakarta/validation/spi/ConfigurationState.java[lines=7..8;21..-1]
----

====

[tck-testable]
--
The requested provider implementation is resolved according to the following rules in the following order:

* Use the provider implementation requested if [classname]`Configuration` has been created from [classname]`Validation.byProvider(Class)`.
* Use the provider implementation described in the XML configuration (under `validation-config.default-provider` see <<validationapi-bootstrapping-xmlconfiguration>>) if defined: the value of this element is the fully qualified class name of the [classname]`ValidationProvider` implementation uniquely identifying the provider.
* Use the first provider implementation returned by [classname]`validationProviderResolver.getValidationProviders()`.
--

The [classname]`ValidationProviderResolver` is specified when [classname]`Configuration` instances are created (see [classname]`ValidationProvider`). [tck-not-testable]#If no [classname]`ValidationProviderResolver` instance has been specified, the default [classname]`ValidationProviderResolver` is used.#

[classname]`Configuration` instances are provided to the {spec-name-bv} client through the [classname]`Validation` methods. [classname]`Configuration` instances are created by [classname]`ValidationProvider`.

If a problem occurs while building the [classname]`ValidatorFactory`, a [classname]`ValidationException` is raised. This can be due to various reasons including:

* malformed XML configuration
* malformed XML mapping
* inability to find the provider (or a provider)
* inability to instantiate extension classes provided in the XML configuration
* inconsistent XML mapping (entity declared more than once, incorrect field etc.)
* invalid constraint declaration or definition


Other exception causes may occur.

Here is an example of [classname]`Configuration` use.

.Use Configuration
====

[source, JAVA]
----
Configuration<?> configuration = [...];
ValidatorFactory factory = configuration
              .messageInterpolator( new WBMessageInterpolator() )
              .traversableResolver( new JPAAwareTraversableResolver() )
              .buildValidatorFactory();
----

====

The following shows an example of setting up a [classname]`Configuration`, retrieving a validator factory from it, subsequently altering the configuration and then retrieving another factory:

[[using-configuration-several-times]]

.Using Configuration to create several validator factories
====

[source, JAVA]
----
Configuration<?> configuration = [...];
ValidatorFactory factory1 = configuration
              .messageInterpolator( new WBMessageInterpolator() )
              .buildValidatorFactory();

ValidatorFactory factory2 = configuration
              .traversableResolver( new JPAAwareTraversableResolver() )
              .buildValidatorFactory();
----

====

Here, [varname]`factory1` is set up using a custom message interpolator, while [varname]`factory2` is set up using the same message interpolator and additionally using a custom traversable resolver.

[[validationapi-bootstrapping-validationprovider]]
==== ValidationProvider and ValidationProviderResolver

[classname]`ValidationProvider` is the contract between the bootstrap process and a specific {spec-name-bv} provider. [classname]`ValidationProviderResolver` implements the discovery mechanism for {spec-name-bv} provider implementations. Any {spec-name-bv} client can implement such a discovery mechanism but it is typically implemented by containers having specific class loader structures and restrictions.

[[validationapi-bootstrapping-validationprovider-resolver]]
===== ValidationProviderResolver

[tck-testable]#[classname]`ValidationProviderResolver` returns the list of {spec-name-bv} providers available at runtime and more specifically a [classname]`ValidationProvider` instance for each provider available in the context.# This service can be customized by implementing [classname]`ValidationProviderResolver`. [tck-not-testable]#Implementations must be thread-safe.#

[role="api"]
.`ValidationProviderResolver` interface
====

[source, JAVA, indent=0]
----
include::{validation-api-source-dir}jakarta/validation/ValidationProviderResolver.java[lines=12..-1]
----

====

By default, providers are resolved using the Service Provider pattern described in http://docs.oracle.com/javase/6/docs/technotes/guides/jar/jar.html#Service%20Provider. [tck-not-testable]#{spec-name-bv} providers must supply a service provider configuration file by creating a text file [filename]`jakarta.validation.spi.ValidationProvider` and placing it in the [filename]`META-INF/services` directory of one of its jar files.# The content of the file contains the name of the provider implementation class of the [classname]`jakarta.validation.spi.ValidationProvider` interface.

{spec-name-bv} provider jars may be installed or made available in the same ways as other service providers, e.g. as extensions or added to the application classpath according to the guidelines in the JAR file specification.

The default [classname]`ValidationProviderResolver` implementation will locate all the {spec-name-bv} providers by their provider configuration files visible in the classpath. The default [classname]`ValidationProviderResolver` implementation is recommended and custom [classname]`ValidationProviderResolver` implementations should be rarely used. A typical use of a custom resolution is resolving providers in a class loader constrained container like OSGi or in a tool environment (IDE).

The default [classname]`ValidationProviderResolver` can be accessed via [classname]`BootStrapState.getDefaultValidationProviderResolver()`. This method is typically used by the {spec-name-bv} provider [classname]`Configuration` implementation.

[[validationapi-bootstrapping-validationprovider-provider]]
===== ValidationProvider

[classname]`ValidationProvider` represents the SPI (Service Provider Interface) defining the contract between the provider discovery and initialization mechanism, and the provider. A [classname]`ValidationProvider` does:

* Provide a generic [classname]`Configuration` implementation (i.e. not tied to a given provider).
* Provide a provider specific [classname]`Configuration` implementation. This [classname]`Configuration` will specifically build [classname]`ValidatorFactory` instances of the provider it comes from.
* Build a [classname]`ValidatorFactory` object from the configuration provided by [classname]`ConfigurationState`.

[role="api"]
.`ValidationProvider` interface
====

[source, JAVA, indent=0]
----
include::{validation-api-source-dir}jakarta/validation/spi/ValidationProvider.java[lines=7..8;14..-1]
----

====

[role="api"]
.`BootstrapState` interface
====

[source, JAVA, indent=0]
----
include::{validation-api-source-dir}jakarta/validation/spi/BootstrapState.java[lines=7..8;12..-1]
----

====

[tck-testable]#A client can request a specific {spec-name-bv} provider by using [classname]`<T extends Configuration<T>, U extends ValidationProvider<T>> Validation.byProvider(Class<U>)` or by defining the provider in the XML configuration file.# The key uniquely identifying a {spec-name-bv} provider is the [classname]`ValidationProvider` implementation specific to this provider.

A [classname]`ValidationProvider` implementation is linked (via its generic parameter) to a specific sub interface of [classname]`Configuration`. The {spec-name-bv} bootstrap API makes use of this link to return the specific [classname]`Configuration` subinterface implementation in a type-safe way when a specific provider is requested. The sub interface does not have to add any new methods but is the natural holder for provider specific configuration methods.

.Example of provider specific Configuration sub interface
====

[source, JAVA]
----
/**
 * Unique identifier of the ACME provider
 * also hosts some provider specific configuration methods
 */
public interface ACMEConfiguration
    extends Configuration<ACMEConfiguration> {

    /**
     * Enables constraints implementation dynamic reloading when using ACME
     * default to false
     */
    ACMEConfiguration enableDynamicReloading(boolean);

}

/**
 * ACME validation provider
 * Note how ACMEConfiguration and ACMEProvider are linked together
 * via the generic parameter.
 */
public class ACMEProvider implements ValidationProvider<ACMEConfiguration> {
    [...]
}
----

====

[NOTE]
====
[classname]`Configuration` references itself in the generic definition. Methods of [classname]`Configuration` will return the [classname]`ACMEConfiguration` making the API easy to use even for vendor specific extensions.
====

[tck-testable]
--
The provider discovery mechanism uses the following algorithm:

* Retrieve available providers using [methodname]`ValidationProviderResolver.getValidationProviders()`.
* The first [classname]`ValidationProvider` matching the requested provider is returned. Providers are evaluated in the order they are returned by [classname]`ValidationProviderResolver`. A provider instance is considered matching if it is assignable to the requested provider class.
--

[tck-testable]#When the default {spec-name-bv} provider is requested, the first [classname]`ValidationProvider` returned by the [classname]`ValidationProviderResolver` strategy is returned.#

[tck-testable]#Every {spec-name-bv} provider must provide a [classname]`ValidationProvider` implementation containing a public no-arg constructor# and add the corresponding [filename]`META-INF/services/jakarta.validation.spi.ValidationProvider` file descriptor in one of its jars.

[tck-testable]#If a problem occurs while building the [classname]`ValidatorFactory`, a [classname]`ValidationException` is raised.# This can be due to various reasons including:

* malformed XML mapping
* inability to find the provider (or a provider)
* inability to instantiate extension classes provided in the XML configuration
* inconsistent XML mapping (entity declared more than once, incorrect field etc.)
* invalid constraint declaration or definition


[[validationapi-bootstrapping-validation]]

==== Validation

The [classname]`Validation` class is the entry point used to bootstrap {spec-name-bv} providers. [tck-testable]#The first entry point, [methodname]`buildDefaultValidatorFactory()`, is considered to be the default [classname]`ValidatorFactory` and is equivalent to the [classname]`ValidatorFactory` returned by [code]`Validation.byDefaultProvider().configure().buildValidatorFactory()`.#

.Validation methods available
====

[source, JAVA]
----
include::{validation-api-source-dir}jakarta/validation/Validation.java[lines=24..102]
        [...]
include::{validation-api-source-dir}jakarta/validation/Validation.java[lines=104..123]
        [...]
include::{validation-api-source-dir}jakarta/validation/Validation.java[lines=125..153]
        [...]
    }

    [...]
}
----

====

[tck-testable]#The second entry point lets the client provide a custom [classname]`ValidationProviderResolver` instance. This instance is passed to [classname]`GenericBootstrap`. [classname]`GenericBootstrap` builds a generic [classname]`Configuration` using the first [classname]`ValidationProvider` returned by [classname]`ValidationProviderResolution` and calling [code]`ValidationProvider.createGenericConfiguration(BootstrapState state)`.# [classname]`BootstrapState` holds the [classname]`ValidationProviderResolution` instance passed to [classname]`GenericBootstrap` and will be used by the [classname]`Configuration` instance when resolving the provider to use. Note that [code]`ValidationProvider.createGenericConfiguration` returns a [classname]`Configuration` object not bound to any particular provider.

[role="api"]
.`GenericBootstrap` interface
====

[source, JAVA]
----
include::{validation-api-source-dir}jakarta/validation/bootstrap/GenericBootstrap.java[lines=7..8;15..-1]
----

====

[tck-testable]#The last entry point lets the client define the specific {spec-name-bv} provider requested as well as a custom [classname]`ValidationProviderResolver` implementation if needed. The entry point method, [methodname]`Validation.byProvider(Class<U> providerType)`, takes the provider specific [classname]`ValidationProvider` implementation type and returns a [classname]`ProviderSpecificBootstrap` object that guarantees to return an instance of the specific [classname]`Configuration` sub interface.# Thanks to the use of generics, the client API does not have to cast to the [classname]`Configuration` sub interface.

A [classname]`ProviderSpecificBootstrap` object can optionally receive a [classname]`ValidationProviderResolver` instance.

[role="api"]
.`ProviderSpecificBootstrap` interface
====

[source, JAVA, indent=0]
----
include::{validation-api-source-dir}jakarta/validation/bootstrap/ProviderSpecificBootstrap.java[lines=7..8;14..-1]
----

====

[methodname]`ProviderSpecificBootstrap.configure()` must return the result of [methodname]`ValidationProvider.createSpecializedConfiguration(BootstrapState state)`. The state parameter holds the [classname]`ValidationProviderResolver` passed to [classname]`ProviderSpecificBootstrap`. The validation provider instance used is the one assignable to the type passed as a parameter in [methodname]`Validation.byProvider(Class)`. The validation provider is selected according to the algorithm described in <<validationapi-bootstrapping-validationprovider-provider>>.

[tck-testable]#The [classname]`Validation` implementation must not contain any non private attribute or method aside from the three public static bootstrap methods:#

* [methodname]`public static ValidatorFactory buildDefaultValidatorFactory()`
* [methodname]`public static GenericBootstrap byDefaultProvider()`
* [methodname]`public static <T extends Configuration<T>, U extends ValidationProvider<T>> ProviderSpecificBootstrap<T> byProvider(Class<U> providerType)`


The bootstrap API is designed to allow complete portability among {spec-name-bv} provider implementations. [tck-testable]#The bootstrap implementation must ensure it can bootstrap third party providers.#

[tck-testable]#When bootstrapping a {spec-name-bv} provider, if the [classname]`ValidationProviderResolver` either fails or if the expected provider is not found, a [classname]`ValidationException` is raised.#

[[validationapi-bootstrapping-xmlconfiguration]]
==== XML configuration: META-INF/validation.xml

[tck-testable]#Unless explicitly ignored by calling [classname]`Configuration.ignoreXMLConfiguration()`, a [classname]`Configuration` takes into account the configuration available in [filename]`META-INF/validation.xml`.# [tck-testable]#This configuration file is optional# but can be used by applications to refine some of the {spec-name-bv} behavior. [tck-not-testable]#If more than one [filename]`META-INF/validation.xml` file is found in the classpath, a [classname]`ValidationException` is raised.#

[tck-testable]#Unless stated otherwise, XML based configuration settings are overridden by values explicitly set via the [classname]`Configuration` API.# For example, the [classname]`MessageInterpolator` defined via [methodname]`Configuration.messageInterpolator(MessageInterpolator)` has priority over the `message-interpolator` definition.

[tck-testable]#`default-provider`: represents the class name of the provider specific [classname]`ValidationProvider` implementation class. If defined, the specific provider is used# (unless a specific provider has been chosen via the programmatic approach).

[tck-testable]#`message-interpolator`: represents the fully qualified class name of the [classname]`MessageInterpolator` implementation. When defined in XML, the implementation must have a public no-arg constructor.#

[tck-testable]#`traversable-resolver`: represents the fully qualified class name of the [classname]`TraversableResolver` implementation. When defined in XML, the implementation must have a public no-arg constructor.#

[tck-testable]#`constraint-validator-factory`: represents the fully qualified class name of the [classname]`ConstraintValidatorFactory` implementation. When defined in XML, the implementation must have a public no-arg constructor.#

[tck-testable]#`parameter-name-provider`: represents the fully qualified class name of the [classname]`ParameterNameProvider` implementation. When defined in XML, the implementation must have a public no-arg constructor.#

[tck-testable]#`clock-provider`: represents the fully qualified class name of the [classname]`ClockProvider` implementation. When defined in XML, the implementation must have a public no-arg constructor.#

[tck-testable]#`value-extractor`: represents the fully qualified class name of a [classname]`ValueExtractor` implementation.#
[tck-testable]#`value-extractor` can be given several times for declaring multiple extractors.#
[tck-testable]#When defined in XML, the implementation must have a public no-arg constructor.#
[tck-testable]#An extractor for a given type and type parameter configured via XML takes precedence
over any extractor for the same type and type parameter detected through the service loader or provided by the {spec-name-bv} implementation itself.#
[tck-testable]#If more than one value extractor for the same type and type parameter is configured via XML, a `ValueExtractorDeclarationException` is raised.#

[tck-testable]#`executable-validation`: allows to disable executable validation entirely via its attribute [code]`enabled="false"` and optionally contains `default-validated-executable-types`. `enabled` defaults to `true`.#

[tck-testable]#`default-validated-executable-types`: declared under `executable-validation`, contains the list of `executable-type` that are considered by default by the integration technology validating executables upon execution.#

[tck-testable]#`constraint-mapping`: represents the resource path of an XML mapping file.# [tck-testable]#More than one `constraint-mapping` element can be present.# [tck-testable]#Mappings provided via [methodname]`Configuration.addMapping(InputStream)` are added to the list of mappings described via `constraint-mapping`.#

`property`: represents a key/value pair property providing room to provider specific configurations. Vendors should use vendor namespaces for properties (e.g., `com.acme.validation.logging`). Entries that make use of the namespace `jakarta.validation` and its subnamespaces must not be used for vendor-specific information. [tck-not-testable]#The namespace `jakarta.validation` is reserved for use by this specification.# [tck-not-testable]#Properties defined via [methodname]`Configuration.addProperty(String, String)` are added to the properties defined via `property`.# [tck-not-testable]#If a property with the same name are defined in both XML and via the programmatic API, the value provided via programmatic API has priority.#

[tck-testable]#All these top level elements are optional.#

[tck-testable]#If a public no-arg constructor is missing on any of the classes referenced by the relevant XML elements, a [classname]`ValidationException` is raised during the [methodname]`Configuration.buildValidatorFactory()` call.#

.Example of META-INF/validation.xml file
====

[source, XML]
----
<?xml version="1.0" encoding="UTF-8"?>
<validation-config
        xmlns="https://jakarta.ee/xml/ns/validation/configuration"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="https://jakarta.ee/xml/ns/validation/configuration
            https://jakarta.ee/xml/ns/validation/configuration/validation-configuration-3.0.xsd"
        version="3.0">
    <default-provider>com.acme.ACMEProvider</default-provider>
    <message-interpolator>com.acme.ACMEAwareMessageInterpolator</message-interpolator>

    <executable-validation>
        <default-validated-executable-types>
            <executable-type>NONE</executable-type>
        </default-validated-executable-types>
    </executable-validation>

    <constraint-mapping>META-INF/validation/order-constraints.xml</constraint-mapping>
    <constraint-mapping>META-INF/validation/catalog-constraints.xml</constraint-mapping>
    <constraint-mapping>META-INF/validation/customer-constraints.xml</constraint-mapping>

    <property name="com.acme.validation.logging">WARN</property>
    <property name="com.acme.validation.safetyChecking">failOnError</property>

</validation-config>
----

====

The XML schema is described in <<xml-config-xsd>>.

[[validationapi-bootstrapping-usageandcontainerexpectation]]

==== Bootstrapping considerations

The {spec-name-bv} bootstrap API can be used directly by any application or made available through a container or other framework. In all cases, the following rules apply:

* [tck-not-testable]#[classname]`ValidatorFactory` is a thread-safe object that should be built once per deployment unit.#
* [classname]`ValidatorFactory` should be closed when it is no longer needed (e.g. when the unit is undeployed or the server stopped).
* [tck-not-testable]#[classname]`Validator` is a thread-safe and lightweight object which can be cached by the [classname]`ValidatorFactory` instance.#
