// Jakarta Validation
//
// License: Apache License, Version 2.0
// See the license.txt file in the root directory or <http://www.apache.org/licenses/LICENSE-2.0>.
:validation-api-source-dir: ../target/validation-api/
:spec-examples-source-dir: ../spec-examples/src/test/java/

[[constraintdeclarationvalidationprocess]]

== Constraint declaration and validation process

The {spec-name-bv} specification defines a framework for declaring constraints on JavaBean classes, fields and properties. Constraints are declared on types and evaluated against instances or graphs of instances.

{spec-name-bv} also offers a way to declare constructor and method constraints where parameters and return values are the constrained elements. We will discuss method constraints declaration in detail in <<constraintdeclarationvalidationprocess-methodlevelconstraints>>.

Furthermore, constraints can be applied to the elements of generic container types such as `Map`, `List` or `Optional` or of non-generic container types such as `OptionalInt`.
Container element constraints are discussed in detail in <<constraintdeclarationvalidationprocess-containerelementconstraints>>.

[[constraintdeclarationvalidationprocess-requirements]]

=== Requirements on classes to be validated

Objects hosting constraints and expecting to be validated by {spec-name-bv} providers must fulfill the following requirements:

* [tck-testable]#Properties to be validated must follow the method signature conventions for JavaBeans read properties, as defined by the link:$$http://download.oracle.com/otndocs/jcp/7224-javabeans-1.01-fr-spec-oth-JSpec/$$[JavaBeans specification]. These properties are commonly referred as getters.#
* [tck-not-testable]#Static fields and static methods are excluded from validation.#
* [tck-testable]#Constraints can be applied to interfaces and superclasses.#


[NOTE]
.What is a getter?
====
[tck-testable]
--
The JavaBeans specification specifies that a getter is a method whose

* name starts with `get` and has a return type but no parameter
* name starts with `is`, has no parameter and is returning [classname]`boolean`
--

====

[tck-testable]
--
The target of an annotation definition can be a

* type
* field or property
* constructor or method return value
* constructor or method parameter
* constructor or method cross-parameter
* container element

provided that:

* the constraint definition supports the specified target ([classname]`java.lang.annotation.Target`)
* one of the [classname]``ConstraintValidator``s declared on the constraint supports the declared type of the target or in the case of cross-parameter, one cross-parameter [classname]`ConstraintValidator` is present (see <<constraintdeclarationvalidationprocess-validationroutine-typevalidatorresolution>> to learn about [classname]`ConstraintValidator` resolution)
* in the case of container element constraints, a corresponding value extractor exists (see <<constraintdeclarationvalidationprocess-validationroutine-valueextractorresolution>> for the details of value extractor resolution)
--

[[constraintdeclarationvalidationprocess-requirements-objectvalidation]]

==== Object validation

[tck-testable]#Constraint declarations can be applied to a class or an interface.# [tck-testable]#Applying a constraint to a class or interface expresses a validation over the state of the class or the class implementing the interface.#

[[constraintdeclarationvalidationprocess-requirements-propertyvalidation]]

==== Field and property validation

[tck-testable]#Constraint declarations can be applied on both fields and properties for the same object type.# [tck-testable]#The same constraint should however not be duplicated between a field and its associated property (the constraint validation would be applied twice).# It is recommended for objects holding constraint declarations to adhere to a single state access strategy (either annotated fields or properties).

[NOTE]
.{spec-name-persistence} and {spec-name-bv}
====
For maximum portability, persistent properties hosting {spec-name-bv} constraints should use the same access strategy used in {spec-name-persistence}. In other words, place your {spec-name-bv} constraint annotations on the same element (field or getter) as your {spec-name-persistence} annotations.
====

[tck-testable]#When a field is annotated with a constraint declaration, field access strategy is used to access the state validated by such constraint.#

[tck-testable]#When a property is annotated with a constraint declaration, property access strategy is used to access the state validated by such constraint.#

When using field access strategy, the {spec-name-bv} provider accesses the instance variable directly. When using the property access strategy, the {spec-name-bv} provider accesses the state via the property accessor method. It is required that the class follows the method signature conventions for JavaBeans read properties (as defined by the JavaBeans [classname]`Introspector` class) for constrained properties when constrained properties are used. In this case, for every constraint property of type [classname]`T`, there is a getter method named [methodname]`get<Property-name>`. The method must have no parameters. For [code]`boolean` properties, [methodname]`is<Property-name>` is an alternative name for the getter method. Specifically, if [methodname]`getX` is the name of the getter method, where [classname]`X` is a string, the name of the persistent property is defined by the result of [code]`java.beans.Introspector.decapitalize(X)`.

[tck-testable]#The fields or methods visibility are not constrained.#

[[constraintdeclarationvalidationprocess-requirements-graphvalidation]]

==== Graph validation

In addition to supporting instance validation, validation of graphs of objects is also supported. The result of a graph validation is returned as a unified set of constraint violations. [classname]`@Valid` is used to express validation traversal of an association.

[role="api"]
.[classname]`@Valid` annotation
====
[source, JAVA, indent=0]
----
include::{validation-api-source-dir}jakarta/validation/Valid.java[lines=20..-1]
----

====

[tck-testable]#Consider the situation where bean [classname]`X` contains a field of type [classname]`Y`. By annotating field [classname]`Y` with the [classname]`@Valid` annotation, the Validator will validate [classname]`Y` (and its properties) when [classname]`X` is validated.# [tck-testable]#The exact type [classname]`Z` of the value contained in the field declared of type [classname]`Y` (subclass, implementation) is determined at runtime. The constraint definitions of [classname]`Z` are used.# This ensures proper polymorphic behavior for associations marked with [classname]`@Valid`.

Collection-valued, array-valued and generally [classname]`Iterable` fields and properties may also be decorated with the [classname]`@Valid` annotation. This causes the contents of the iterator to be validated. [tck-testable]#Any object implementing [classname]`java.lang.Iterable` is supported.# This includes specifically:

* [tck-testable]#arrays of objects#
* [tck-testable]#[classname]`java.util.Collection`#
* [tck-testable]#[classname]`java.util.Set`#
* [tck-testable]#[classname]`java.util.List`#
* [tck-testable]#[classname]`java.util.Map`# (special treatment see below)

[tck-testable]#Each object provided by the iterator is validated.# [tck-testable]#For [classname]`Map`, the value (retrieved by [methodname]`getValue`) of each [classname]`Map.Entry` is validated (the key is not validated).#

[tck-testable]#Like regular references, its type is determined at runtime and the constraint definitions for this particular type are used.#

[tck-testable]#As of {spec-name-bv} 2.0, `@Valid` can be applied to the elements of any generic container by putting it to the type argument(s) when using such container (e.g. `MultiMap<String, @Valid Address> addressesByType`),
provided a value extractor implementation (see <<valueextractordefinition>>) for that container type and the targeted type argument is present.#
There are built-in value extractors for the generic collection types listed above.
In addition, there is a built-in extractor for the key objects of maps.
See <<valueextractordefinition-builtinvalueextractors>> for the complete list of built-in value extractors.

[tck-testable]#`@Valid` also allows the validation of the elements of nested generic containers. `@Valid` must be put to a type argument of that nested container type in order to trigger validation of the elements of all the nested containers.#

For a given container, the `@Valid` annotation should either be put to the container itself _or_ to the type argument(s) of the container,
but not both (in order to prevent the container elements from being validated twice).

[tck-testable]#The [classname]`@Valid` annotation is applied recursively.# A conforming implementation avoids infinite loops according to the rules described in <<constraintdeclarationvalidationprocess-validationroutine-graphvalidation>>.

[tck-not-testable]#It is not supported to put `@Valid` to the type parameters of generic types or methods.#
[tck-not-testable]#It is also not supported to put `@Valid` to type arguments within the `extends` or `implements` clauses of type definitions.#
A future revision of this specification might define support for such usages of `@Valid`.

[[constraintdeclarationvalidationprocess-requirements-graphvalidation-examples]]
===== Examples

.Making elements of a list subject to graph validation
====
[source, JAVA]
----
public class User {

    // preferred style as of Jakarta Validation 2.0
    private List<@Valid PhoneNumber> phoneNumbers;

    // traditional style; continues to be supported
    @Valid
    private List<PhoneNumber> phoneNumbers;

    // discouraged; either the container or the type argument(s) should be
    // annotated with @Valid, but not both
    @Valid
    private List<@Valid PhoneNumber> phoneNumbers;
}
----
====

.Making values of a map subject to graph validation
====
[source, JAVA]
----
public class User {

    // preferred style as of Jakarta Validation 2.0
    private Map<AddressType, @Valid Address> addressesByType;

    // traditional style; continues to be supported
    @Valid
    private Map<AddressType, Address> addressesByType;

    // discouraged; either the map or the map value type argument should be
    // annotated with @Valid, but not both
    @Valid
    private Map<AddressType, @Valid Address> addressesByType;
}
----
====

.Making keys and values of a map subject to graph validation
====
[source, JAVA]
----
public class User {

    private Map<@Valid AddressType, @Valid Address> addressesByType;
}
----
====

.Making elements of a nested list subject to graph validation
====
[source, JAVA]
----
public class User {
    private Map<String, List<@Valid Address>> addressesByType;
}
----
====

In this example, all `Address` objects contained in the lists of the `addressesByType` map will be validated.
Two value extractors are invoked for this:

* the extractor for `Map` values will be invoked to obtain all map values (lists of `Address`)
* for each extracted list of addresses, the extractor for `List` elements will be invoked, providing the `Address` objects from each list in the map

.Making keys and values of a nested map subject to graph validation
====
[source, JAVA]
----
public class User {
    private Map<String, Map<@Valid AddressType, @Valid Address>> addressesByUserAndType;
}
----
====

In this example, all `AddressType` objects and all `Address` objects contained in the maps of the `addressesByUserAndType` map will be validated.
The following value extractors are invoked for this:

* the extractor for `Map` values will be invoked to obtain all map values (maps of addresses by address type)
* for each extracted map, the extractor for `Map` keys will be invoked, providing the `AddressType` objects from each of the nested maps
* for each extracted map, the extractor for `Map` values will be invoked, providing the `Address` objects from each of the nested maps

[[constraintdeclarationvalidationprocess-constraintdeclaration]]

=== Constraint declaration

Constraint declarations are placed on classes or interfaces primarily through annotations. A constraint annotation (see <<constraintsdefinitionimplementation-constraintdefinition>>), can be applied to a type, on any of the type's fields or on any of the JavaBeans-compliant properties.

[tck-testable]#When a constraint is defined on a class, the class instance being validated is passed to the [classname]`ConstraintValidator`. When a constraint is defined on a field, the value of the field is passed to the [classname]`ConstraintValidator`. When a constraint is defined on a getter, the result of the getter invocation is passed to the [classname]`ConstraintValidator`.#

<<constraintdeclarationvalidationprocess-methodlevelconstraints>> discusses in detail constraints on methods and constructors.

Constraints can also be applied to the elements of container types, e.g. to the elements of a `List`-typed property or to the value wrapped by an `Optional` object returned by a method.
Container element constraints are discussed in <<constraintdeclarationvalidationprocess-containerelementconstraints>>.

[[constraintdeclarationvalidationprocess-inheritance]]

=== Inheritance (interface and superclass)

[tck-testable]#A constraint declaration can be placed on an interface.# [tck-testable]#For a given class, constraint declarations held on superclasses as well as interfaces are evaluated by the {spec-name-bv} provider.# Rules are formally described in <<constraintdeclarationvalidationprocess-groupsequence-formaldefinition>>.

[tck-testable]#The effect of constraint declarations is cumulative. Constraints declared on a superclass getter will be validated along with any constraints defined on an overridden version of the getter according to the Java Language Specification visibility rules.#

[[constraintdeclarationvalidationprocess-groupsequence]]

=== Group and group sequence

A group defines a subset of constraints. Instead of validating all constraints for a given object graph, only a subset is validated. This subset is defined by the group or groups targeted. Each constraint declaration defines the list of groups it belongs to. [tck-testable]#If no group is explicitly declared, a constraint belongs to the [classname]`Default` group.#

[tck-testable]#Groups are represented by interfaces.#

.Definition of groups
====

[source, JAVA]
----
/**
 * Validation group verifing that a user is billable
 */
public interface Billable {}

/**
 * Customer can buy without any harrassing checking process
 */
public interface BuyInOneClick {
}
----

====

[tck-testable]#A constraint can belong to one or more groups.#

[[example-assigngrouptoconstraints]]

.Assign groups to constraints
====

[source, JAVA]
----
/**
 * User representation
 */
public class User {
    @NotNull
    private String firstname;

    @NotNull(groups = Default.class)
    private String lastname;

    @NotNull(groups = {Billable.class, BuyInOneClick.class})
    private CreditCard defaultCreditCard;
}
----

====

[tck-testable]#During the validation call, one or more groups are validated. All the constraints belonging to this set of groups is evaluated on the object graph.# In <<example-assigngrouptoconstraints>>, [classname]`@NotNull` is checked on `defaultCreditCard` when either the [classname]`Billable` or [classname]`BuyInOneClick` group is validated. [classname]`@NotNull` on `firstname` and `lastname` are validated when the [classname]`Default` group is validated. Reminder: constraints held on superclasses and interfaces are considered.

[classname]`Default` is a group predefined by the specification.

[role="api"]
.`Default` group
====
[source, JAVA, indent=0]
----
include::{validation-api-source-dir}jakarta/validation/groups/Default.java[lines=7..-1]
----
====

[[constraintdeclarationvalidationprocess-groupsequence-groupinheritance]]
==== Group inheritance

In some situations, a group is a superset of one or more groups. This can be described by {spec-name-bv}. [tck-testable]#A group may inherit one or more groups by using interface inheritance.#

.Groups can inherit other groups
====

[source, JAVA]
----
/**
 * Customer can buy without harrassing checking process
 */
public interface BuyInOneClick extends Default, Billable {}
----

====

[tck-testable]#For a given interface [classname]`Z`, constraints marked as belonging to the group [classname]`Z` (i.e. where the annotation element [methodname]`groups` contains the interface [classname]`Z`) or any of the super interfaces of [classname]`Z` (inherited groups) are considered part of the group [classname]`Z`.#

In the following example:

.Use of a inherited group
====

[source, JAVA]
----
/**
 * User representation
 */
public class User {
    @NotNull
    private String firstname;

    @NotNull(groups = Default.class)
    private String lastname;

    @NotNull(groups = Billable.class)
    private CreditCard defaultCreditCard;
}
----

====

validating the group [classname]`BuyInOneClick` will lead to the following constraints checking:

* [classname]`@NotNull` on `firstname` and `lastname`
* [classname]`@NotNull` on `defaultCreditCard`


because [classname]`Default` and [classname]`Billable` are superinterfaces of [classname]`BuyInOneClick`.

[[constraintdeclarationvalidationprocess-groupsequence-groupsequence]]
==== Group sequence

[tck-not-testable]#By default, constraints are evaluated in no particular order regardless of which groups they belong to.# It is however useful in some situations to control the order of constraints evaluation. There are often scenarios where a preliminary set of constraints should be evaluated prior to other constraints. Here are two examples:

* The second group depends on a stable state to run properly. This stable state is verified by the first group.
* The second group is a heavy consumer of time, CPU or memory and its evaluation should be avoided if possible.


To implement such ordering, a group can be defined as a sequence of other groups. [tck-testable]#Each group in a group sequence must be processed sequentially in the order defined by [methodname]`@GroupSequence.value` when the group defined as a sequence is requested.# [tck-testable]#Note that a group member of a sequence can itself be composed of several groups via inheritance or sequence definition. In this case, each composed group must respect the sequence order as well.#

Processing a group is defined in <<constraintdeclarationvalidationprocess-validationroutine>> ; [tck-testable]#if one of the groups processed in the sequence generates one or more constraint violations, the groups following in the sequence must not be processed.# This ensures that a set of constraints is evaluated only if another set of constraints is valid.

[tck-testable]
--
Groups defining a sequence and groups composing a sequence must not be involved in a cyclic dependency:

* either directly or indirectly
* either through cascaded sequence definitions or group inheritance
--

[tck-testable]#If a group containing such a circularity is evaluated, a [classname]`GroupDefinitionException` is raised.#

[tck-not-testable]#Groups defining a sequence should not directly inherit other groups. In other words, the interface hosting the group sequence should not have any super interface.#

[tck-not-testable]#Groups defining a sequence should not be used directly in constraint declarations.# In other words, the interface hosting the group sequence should not be used in a constraint declaration.

[tck-testable]#To define a group as a sequence, the interface must be annotated with the [classname]`@GroupSequence` annotation.#

[role="api"]
.`@GroupSequence` annotation
====
[source, JAVA]
----
include::{validation-api-source-dir}jakarta/validation/GroupSequence.java[lines=18..-1]
----
====

Here is a usage example:

[[example-groupsequence]]

.Make use of group sequence
====

[source, JAVA]
----
@ZipCodeCoherenceChecker(groups = Address.HighLevelCoherence.class)
public class Address {
    @NotNull @Size(max = 50)
    private String street1;

    @NotNull @ZipCode
    private String zipCode;

    @NotNull @Size(max = 30)
    private String city;

    /**
     * check coherence on the overall object
     * Needs basic checking to be green first
     */
    public interface HighLevelCoherence {}

    /**
     * check both basic constraints and high level ones.
     * high level constraints are not checked if basic constraints fail
     */
    @GroupSequence({Default.class, HighLevelCoherence.class})
    public interface Complete {}
}
----

====

In <<example-groupsequence>>, when the [classname]`Address.Complete` group is validated, all constraints belonging to the [classname]`Default` group are validated. If any of them fail, the validation skips the [classname]`HighLevelCoherence` group. If all [classname]`Default` constraints pass, [classname]`HighLevelCoherence` constraints are evaluated.

[NOTE]
====
[tck-testable]#A given constraint can belong to two or more groups ordered by a sequence. In this case, the constraint is evaluated as part of the first group and ignored in the subsequent group(s).# See <<constraintdeclarationvalidationprocess-validationroutine>> for more information.
====

[[constraintdeclarationvalidationprocess-groupsequence-redefiningdefaultgroup]]
==== Redefining the Default group for a class

In <<example-groupsequence>>, validating the [classname]`Default` group does not validate [classname]`HighLevelCoherence` constraints. To ensure a complete validation, a user must use the [classname]`Complete` group. This breaks some of the encapsulation you could expect. You can work around this by redefining what the [classname]`Default` group means for a given class. [tck-testable]#To redefine [classname]`Default` for a class, place a [classname]`@GroupSequence` annotation on the class; this sequence expresses the sequence of groups that does substitute [classname]`Default` for this class.#

[[example-overridedefaultgroup]]

.Redefining Default group for Address
====

[source, JAVA]
----
@GroupSequence({Address.class, HighLevelCoherence.class})
@ZipCodeCoherenceChecker(groups = Address.HighLevelCoherence.class)
public class Address {
    @NotNull @Size(max = 50)
    private String street1;

    @NotNull @ZipCode
    private String zipCode;

    @NotNull @Size(max = 30)
    private String city;

    /**
     * check coherence on the overall object
     * Needs basic checking to be green first
     */
    public interface HighLevelCoherence {}
}
----

====

In <<example-overridedefaultgroup>>, when an address object is validated for the group [classname]`Default`, all constraints belonging to the group [classname]`Default` and hosted on [classname]`Address` are evaluated. If none fails, all [classname]`HighLevelCoherence` constraints present on [classname]`Address` are evaluated. In other words, when validating the [classname]`Default` group for [classname]`Address`, the group sequence defined on the [classname]`Address` class is used.

Since sequences cannot have circular dependencies, using [classname]`Default` in the declaration of a sequence is not an option. [tck-not-testable]#Constraints hosted on a class [classname]`A` and belonging to the [classname]`Default` group (by default or explicitly) implicitly belong to the group [classname]`A`.#

[tck-testable]#A sequence defined on a class [classname]`A` (i.e. redefining the [classname]`Default` groups for the class) must contain the group [classname]`A`.# In other words, the default constraints hosted on a class must be part of the sequence definition. [tck-testable]#If a [classname]`@GroupSequence` redefining the [classname]`Default` group for a class [classname]`A` does not contain the group [classname]`A`, a [classname]`GroupDefinitionException` is raised when the class is validated or when its metadata is requested.#

[[constraintdeclarationvalidationprocess-groupsequence-implicitgrouping]]
==== Implicit grouping

It is possible to implicitly group several constraints in the same group without explicitly listing such a group in the constraint declaration. [tck-testable]#Every constraint hosted on an interface [classname]`Z` and part of the [classname]`Default` group (implicitly or explicitly) belongs to the group [classname]`Z`.# This is useful to validate the partial state of an object based on a role represented by an interface.

.Example of interface / group hosting constraints
====

[source, JAVA]
----
/**
 * Auditable object contract
 */
public interface Auditable {
    @NotNull String getCreationDate();
    @NotNull String getLastUpdate();
    @NotNull String getLastModifier();
    @NotNull String getLastReader();
}

/**
 * Represents an order in the system
 */
public class Order implements Auditable {
    private String creationDate;
    private String lastUpdate;
    private String lastModifier;
    private String lastReader;

    private String orderNumber;

    public String getCreationDate() {
        return this.creationDate;
    }

    public String getLastUpdate() {
        return this.lastUpdate;
    }

    public String getLastModifier() {
        return this.lastModifier;
    }

    public String getLastReader() {
        return this.lastReader;
    }

    @NotNull @Size(min=10, max=10)
    public String getOrderNumber() {
        return this.orderNumber;
    }
}
----

====

When an [classname]`Order` object is validated on the [classname]`Default` group, the following constraints are validated: [classname]`@NotNull` on [methodname]`getCreationDate`, [methodname]`getLastUpdate`, [methodname]`getLastModifier`, [methodname]`getLastReader`, [methodname]`getOrderNumber` and [classname]`@Size` on [methodname]`getOrderNumber` as all belong to the [classname]`Default` group.

When an [classname]`Order` object is validated on the [classname]`Auditable` group, the following constraints are validated: [classname]`@NotNull` on [methodname]`getCreationDate`, [methodname]`getLastUpdate`, [methodname]`getLastModifier`, [methodname]`getLastReader`. Only the constraints present on [classname]`Auditable` (and any of its super interfaces) and belonging to the [classname]`Default` group are validated when the group [classname]`Auditable` is requested. It allows the caller to validate that a given object can be safely audited even if the object state itself is not valid.

[[constraintdeclarationvalidationprocess-groupsequence-groupconversion]]

==== Group conversion

When performing cascading validation, it is possible to use a different group than the one originally requested using the group conversion feature. Group conversions are declared by using the [classname]`@ConvertGroup` annotation.

[role="api"]
.@ConvertGroup annotation
====
[source, JAVA, indent=0]
----
include::{validation-api-source-dir}jakarta/validation/groups/ConvertGroup.java[lines=7..8;24..-1]
----
====

[tck-testable]#[classname]`@ConvertGroup` and [classname]`@ConvertGroup.List` can be used everywhere [classname]`@Valid` can be used (associations, method/constructor parameters and return value). If these annotations are used without [classname]`@Valid`, a [classname]`ConstraintDeclarationException` is raised.#

When an element is annotated with [classname]`@Valid`, validation is propagated. [tck-testable]#Groups are passed as is to the nested elements unless the [classname]`@ConvertGroup` annotation is used.#

[tck-testable]#If the group expected to be passed to the nested element validation is defined as the `from` attribute of a [classname]`@ConvertGroup` annotation, the group used to effectively validate the nested element is the corresponding group defined in the `to` attribute.#

[tck-testable]#If no value for the `from` attribute is specified, `Default.class` will be used as the source group of the conversion.#

[tck-testable]#Rules are not executed recursively.# If a rule is found matching, subsequent rules are no longer evaluated. In particular, if a set of [classname]`@ConvertGroup` declaration chains group `A` to `B` and `B` to `C`, the group `A` will be converted to `B` and not to `C`. This both makes rules clearer and lets you switch two groups.

[tck-testable]#It is not legal to have more than one conversion rule containing the same `from` value. In this case, a [classname]`ConstraintDeclarationException` is raised.#

[tck-testable]#Like regular constraint declarations, the `from` attribute cannot refer to a group sequence. A [classname]`ConstraintDeclarationException` is raised in this situation.# [tck-testable]#The `to` attribute can. The group sequence will then be expanded before validating the associated object.#

[NOTE]
====
When validation is done, group sequences are expanded before validating the object and its cascaded objects with the expected groups. Group conversion on an associated object happens on the already expanded groups.

The group referred to in [methodname]`@ConvertGroup.from` works on expanded groups (i.e., after the group sequence has been expanded), not necessarily groups passed to the various [methodname]`validate` methods.

The group referred to in [methodname]`@ConvertGroup.to` will be expanded before validating the cascaded object just like a call to the various [methodname]`validate` method would have done.
====

[NOTE]
====
Like most {spec-name-bv} error cases, an illegal set of rules can be discovered statically (at compile time). For example, an annotation processor could detect such errors.
====

[NOTE]
====
Group circularity in a group conversion are not problematic because:

* only one rule is applied for a given cascade (rules are not applied recursively)
* validation cascading is stopped when the same instance / property is validated with the same group in a given path (existing rule)
====

[tck-testable]#[classname]`@ConvertGroup` and [classname]`@ConvertGroup.List` can only be placed where [classname]`@Valid` is present to ensure proper respect of the Liskov substitution principle:# if rules were to be defined on an overriding method of a method marked as cascading validation, the rules could end up altering the list of constraints validated by the super type and thus violating the Liskov substitution principle.

[tck-testable]#Likewise, if a sub type overrides/implements a method originally defined in several parallel types of the hierarchy (e.g. two interfaces not extending each other, or a class and an interface not implemented by said class) and if that method's return value has been marked for cascading validation in one of the parallel types, no group conversion rule may be declared for that method's return value in the parallel types of the hierarchy.# This again is to avoid an unexpected altering of the post conditions to be guaranteed to the caller.

[tck-testable]#If any of these rules is violated, a [classname]`ConstraintDeclarationException` is raised by default as defined in <<constraintdeclarationvalidationprocess-methodlevelconstraints-inheritance>>.#

Group conversion is quite useful to facilitate object graph reuse without spreading the validation group definitions across several layers. Let's look at an example.

[[constraintdeclarationvalidationprocess-groupsequence-groupconversion-examples]]
===== Group conversion examples

In this example we will reuse the [classname]`Address` group split and match it to the [classname]`User` group split.

.Example of group conversion
====
[source, JAVA]
----
public interface Complete extends Default {}
public interface BasicPostal {}
public interface FullPostal extends BasicPostal {}

public class Address {
    @NotNull(groups=BasicPostal.class)
    String street1;

    String street2;

    @ZipCode(groups=BasicPostal.class)
    String zipCode;

    @CodeChecker(groups=FullPostal.class)
    String doorCode;
}

public class User {
    @Valid
    @ConvertGroup(from=Default.class, to=BasicPostal.class)
    @ConvertGroup(from=Complete.class, to=FullPostal.class)
    Set<Address> getAddresses() { [...] }
}
----
====

When validating an instance of [classname]`User` with the [classname]`Default` group, the associated addresses are validated with the [classname]`BasicPostal` group. When validating an instance of [classname]`User` with the [classname]`Complete` group, the associated addresses are validated with the [classname]`FullPostal` group.

[tck-testable]#Group conversions can also be applied during container element validation#:

.Example of container element validation with group conversion
====
[source, JAVA]
----
public class User {
    Set<
        @Valid
        @ConvertGroup(from=Default.class, to=BasicPostal.class)
        @ConvertGroup(from=Complete.class, to=FullPostal.class)
        Address
    > getAddresses() { [...] }
}
----
====

The following example shows an illegal declaration of a group conversion rule on a method's return value:

.Example of an illegal group conversion
====


[source, JAVA]
----
public interface BasicPostal {}

public class Order { [...] }

public interface RetailOrderService {

    @Valid
    Order placeOrder(String itemNo, int quantity);
}

public interface B2BOrderService {

    @Valid
    @ConvertGroup(from=Default.class, to=BasicPostal.class)
    Order placeOrder(String itemNo, int quantity);
}

public class OrderService implements RetailOrderService, B2BOrderService {

    @Override
    public Order placeOrder(String itemNo, int quantity) {
        [...]
    }
}
----

====

Here the class [classname]`OrderService` implements the two unrelated interfaces [classname]`RetailOrderService` and [classname]`B2BOrderService`, which both define a method [methodname]`placeOrder()`, marking the return value as cascaded.

The group conversion declared in [classname]`B2BOrderService` is illegal as per the rules defined in the previous section, since the set of applied validation groups might be altered unexpectedly for a client of the [classname]`RetailOrderService` interface.

[[constraintdeclarationvalidationprocess-groupsequence-formaldefinition]]

==== Formal group definitions

The formal rules defining groups are as followed. _Text in italic are comments about the rules._

For every class [classname]`X`:

[start=1]
. For each superclass [classname]`Y` of [classname]`X`, the group [classname]`Y` contains all constraints of the group [classname]`Y` of [classname]`Y`
_this rule prepares formal concepts for recursive discovery_

[tck-testable]
--
[start=2]
. The group [classname]`X` contains the following constraints:
[tck-ignore]#group [classname]`X` is a group used on sequences redefining the default group on a class (see <<constraintdeclarationvalidationprocess-groupsequence-redefiningdefaultgroup>>)#
.. every constraint declared by the class [classname]`X` which does not declare a group or does declare the group [classname]`Default` explicitly.
[tck-ignore]#_all Default constraints hosted on X_#


.. every constraint declared by any interface implemented by [classname]`X` and not annotated [classname]`@GroupSequence` which does not explicitly declare a group or does declare the group [classname]`Default` explicitly.
[tck-ignore]#_all Default constraints hosted on interfaces of X: constraints are inherited by the class hierarchy. Interfaces marked as @GroupSequence are ignored._#


.. if [classname]`X` has a direct superclass [classname]`Y`, every constraint in the group [classname]`Y`
[tck-ignore]#_all Default constraints hosted on the superclasses of X: constraints are inherited by the class hierarchy_#
--

[tck-testable]
--
[start=3]
. If [classname]`X` has no [classname]`@GroupSequence` annotation, the group [classname]`Default` contains the following constraints:
[tck-ignore]#_this rule defines which constraints are evaluated when validating Default on X._#
.. every constraint in the group [classname]`X`

.. if [classname]`X` has a direct superclass [classname]`Y`, every constraint in the group [classname]`Default` of [classname]`Y`
[tck-ignore]#_this rule is necessary in case Y redefines the group Default_#
--

[start=4]
. [tck-testable]#If [classname]`X` does have a [classname]`@GroupSequence` annotation, the group [classname]`Default` contains every constraint belonging to every group declared by the [classname]`@GroupSequence` annotation.#
_this rule describes how a class can redefine the group Default for itself (see <<constraintdeclarationvalidationprocess-groupsequence-redefiningdefaultgroup>>)_
** [tck-testable]#the [classname]`@GroupSequence` annotation must declare the group [classname]`X`#

[tck-testable]
--
[start=5]
. For every interface [classname]`Z`, the group [classname]`Z` contains the following constraints:
[tck-ignore]#_this rule defines how non Default groups are defined_#
.. every constraint declared by the interface [classname]`Z` which does not explicitly declare a group or does declare the group [classname]`Default` explicitly.
[tck-ignore]#_all Default constraints hosted on Z: this rule formally defines implicit grouping per interface (see <<constraintdeclarationvalidationprocess-groupsequence-implicitgrouping>>)_#


.. every constraint (which does not explicitly declare a group) declared by any superinterface not annotated [classname]`@GroupSequence` of the interface [classname]`Z`
[tck-ignore]#_all Default constraints hosted on interfaces of Z: groups can be inherited (see <<constraintdeclarationvalidationprocess-groupsequence-groupinheritance>>)_#


.. every constraint declared by the class [classname]`X` which explicitly declares the group [classname]`Z`
[tck-ignore]#_every constraint hosted by X and marked as belonging to the group Z_#


.. every constraint declared by any interface implemented by [classname]`X` and not annotated [classname]`@GroupSequence` which explicitly declares the group [classname]`Z`
[tck-ignore]#_every constraint hosted by any interface of X and marked as belonging to the group Z_#


.. if [classname]`X` has a direct superclass [classname]`Y`, every constraint in the group [classname]`Z` of [classname]`Y`
[tck-ignore]#_every constraint hosted by any superclass of X and marked as belonging to the group Z_#
--

[start=6]
. [tck-testable]#For every interface [classname]`Z` annotated [classname]`@GroupSequence`, the group [classname]`Z` contains every constraint belonging to every group declared by the [classname]`@GroupSequence` annotation.#
_defines the composition side of group sequence but does not define the ordering behavior of sequence (see <<constraintdeclarationvalidationprocess-groupsequence-groupsequence>>)_


[tck-testable]
--
When a given group [classname]`G` (represented by an interface [classname]`G`) is requested for the validation of a class [classname]`X`:

* constraints belonging to the group [classname]`G` are evaluated
* if the interface [classname]`G` is not annotated [classname]`@GroupSequence`, every group represented by the super interface of [classname]`G` are requested for validation
* if the interface [classname]`G` is annotated with [classname]`@GroupSequence`, every group represented by the interfaces declared by the [classname]`@GroupSequence` annotation are requested for validation
** the validation of groups declared to the [classname]`@GroupSequence` must happen in the sequencing order declared by [classname]`@GroupSequence`: the sequencing order is propagated to the groups composing the sequenced group (via inheritance or group sequence)
** if a group validation triggers the failure of one or more constraints, groups following in the sequence must not be evaluated.

* if the group [classname]`G` represents the [classname]`Default` group of [classname]`X` overridden by [classname]`@GroupSequence`, operations are equivalent
--

[tck-testable]
--
When the [classname]`Default` group of a given class [classname]`X` is overridden via [classname]`@GroupSequence`, its validation is as followed:

* every group represented by the interfaces declared by the [classname]`@GroupSequence` annotation are requested for validation
** the validation of groups declared to the [classname]`@GroupSequence` must happen in the sequencing order declared by [classname]`@GroupSequence`: the sequencing order is propagated to the groups composing the sequenced group (via inheritance or group sequence)
** if a group validation triggers the failure of one or more constraints, groups following in the sequence must not be evaluated.
--

[tck-not-testable]#Unless defined by a [classname]`@GroupSequence`, evaluation ordering is not constrained. In particular, several groups can be validated in the same pass.# [tck-testable]#If a group definition leads to a circular sequencing order between groups, a [classname]`GroupDefinitionException` is raised.#

[NOTE]
====
A group [classname]`G` sequenced (directly or indirectly) to be executed before itself is not considered a circular reference.
====

[[constraintdeclarationvalidationprocess-containerelementconstraints]]
=== Container element constraints
[tck-testable]#Constraints can be applied to the elements of generic containers, e.g. `List`, `Map` or `Optional`.
This is done by putting constraint annotations to the type arguments of such containers.#
[tck-testable]
--
Container element constraints can be used within the following declarations:

* fields,
* properties,
* method or constructor parameters or
* method return values.
--

.Container element constraints
====
[source, JAVA]
----
private List<@Email String> emails;

public Optional<@Email String> getEmail() {
    [...]
}

public Map<@NotNull String, @ValidAddress Address> getAddressesByType() {
    [...]
}

public List<@NotBlank String> getMatchingRecords(List<@NotNull @Size(max=20) String> searchTerms) {
    [...]
}
----
====

[tck-testable]#When a field, property, executable parameter or method return value which is of a container type gets validated, then all values contained in the container will be validated provided that their container element type is constrained.#
[tck-testable]#Any container element constraints of that element will be validated alongside any other constraints hosted by that element.#
[tck-testable]#For container element constraints, the same rules for validation groups and group sequences apply as for any other constraint on the same element.#

When a container element is constrained, the validation engine invokes a value extractor (see <<valueextractordefinition>>)
which retrieves the value(s) from the container so they can be validated.
This may be a single value - e.g. in the case of `Optional` which wraps exactly one value if the `Optional` is not empty -
or multiple values in the case of collection types.

[tck-testable]#Container element constraints can be applied to nested container types#:

.Container element constraints on nested containers
====
[source, JAVA]
----
private Map<String, @NotEmpty List<@ValidAddress Address>> addressesByType;
----
====

In such case multiple value extractors will be invoked.

In the example above,

* the extractor for `Map` values will be invoked to obtain all map values (lists of `Address`)
* for each extracted list of addresses, the `@NotEmpty` constraint will be validated and the extractor for `List` elements will be invoked, providing the `Address` objects from each list in the map
* the `@ValidAddress` constraint will be applied to all elements of all lists stored in the map

[tck-not-testable]#It is not supported to declare container element constraints on the type parameters of generic types or methods.#
[tck-not-testable]#It is also not supported to declare container element constraints on type arguments within the `extends` or `implements` clauses of type definitions.#
I.e. the following usages are unsupported:

.Unsupported usage of container element constraints on generic types and methods
====
[source, JAVA]
----
public class NonNullList<@NotNull T> {
    [...]
}

public class ContainerFactory {
    <@NotNull T> Container<T> instantiateContainer(T wrapped) { [...] }
}

public class NonNullSet<T> extends Set<@NotNull T> {
    [...]
}
----
====

A future revision of this specification might define support for such usages of container element constraints.

[[constraintdeclarationvalidationprocess-containerelementconstraints-implicitunwrapping]]
==== Implicit unwrapping of containers

Besides specifying container element constraints on type arguments, it is also possible to declare container element constraints on non-generic container types.
This is done by means of _implicit unwrapping_, i.e. a constraint doesn't apply to the annotated container itself but to its element(s).
Examples for types being subject to implicit unwrapping are `java.util.OptionalInt`, `OptionalLong` and `OptionalDouble` as well as JavaFX's non-generic property types such as `StringProperty` or `IntegerProperty`:

.Implicit unwrapping of container elements
====
[source, JAVA]
----
@Min(1)
private OptionalInt optionalNumber;

@Negative
private LongProperty negativeLong;

@Positive
private IntegerProperty positiveInt;

private final ListProperty<@NotBlank StringProperty> notBlankStrings;
----
====

Here the `@Min`, `@Negative`, `@Positive` and `@NotBlank` constraints don't apply to the annotated `OptionalInt`, `LongProperty`, `IntegerProperty` and `StringProperty` objects themselves, but rather to the wrapped numeric and string values, respectively.

For this to work, an unambiguously resolvable value extractor (see <<constraintdeclarationvalidationprocess-validationroutine-valueextractorresolution-implicitunwrapping>>) must be defined which carries the `@UnwrapByDefault` annotation (see <<valueextractordefinition-unwrapbydefault>>).

If needed, the target (container or container element) of a constraint declared on a container can be explicitly specified via the `Unwrap` and `Skip` payload definitions:

[role="api"]
.`Payload` types for unwrapping control
====
[source, JAVA, indent=0]
----
include::{validation-api-source-dir}jakarta/validation/valueextraction/Unwrapping.java[lines=7..8;11..-1]
----
====

[tck-testable]
--
This is useful for applying a constraint given on a non-generic container to

* the container element(s) if there is no value extractor marked with `@UnwrapByDefault` (by using `Unwrap`)
* the container itself in case there is a value extractor marked with `@UnwrapByDefault` (by using `Skip`)
--

For instance the `@NotNull` constraint is applied to the `StringProperty` container:

[source,java]
----
@NotNull(payload = Unwrapping.Skip.class)
private StringProperty name;
----

[tck-testable]#If both `Unwrap` and `Skip` are present in the definition of a payload, a `ConstraintDeclarationException` is raised.#

[NOTE]
====
For the sake of readability, when applying constraints to the elements of a generic container,
it is strongly recommended to put the constraints to the type argument instead of the container itself in conjunction with `Unwrapping.Unwrap`.
I.e. you should prefer

[source,java]
----
List<@Email String> emails;
----

over

[source,java]
----
@Email(payload = Unwrapping.Unwrap.class)
List<String> emails;
----
====

[[constraintdeclarationvalidationprocess-methodlevelconstraints]]
=== Method and constructor constraints

[NOTE]
====
In the following, the term "method constraint" refers to constraints declared on methods as well as constructors.
====

Method constraints are declared by adding constraint annotations directly to methods or constructors and/or their parameters. In the former case, all the parameters of an executable (cross-parameter constraint) or the return value is constrained, in the latter individual parameters are constrained. As with bean constraints, this can be done using either actual Java annotations or using an XML constraint mapping file (see <<xml-mapping-constraintdeclarationinxml-methodleveloverriding>>). {spec-name-bv} providers are free to provide additional means of defining method constraints such as an API-based approach.

Getters are not considered constrained methods by default (see <<integration-general-executable>>).

[[constraintdeclarationvalidationprocess-methodlevelconstraints-requirements]]
==== Requirements on methods to be validated

[tck-not-testable]#Static methods are ignored by validation. Putting constraints on a static method is not portable.# No other restrictions exist from the perspective of this specification, however it is possible that technologies integrating with method validation impose further restrictions to methods for which a validation shall be applied. For instance certain integration technologies might require that methods to be validated must have [methodname]`public` visibility and/or must not be [methodname]`final`.

[[constraintdeclarationvalidationprocess-methodlevelconstraints-parameterconstraints]]
==== Declaring parameter constraints

[tck-testable]#Parameter constraints are declared by putting constraint annotations on method or constructor parameters.#

.Declaring parameter constraints
====

[source, JAVA]
----
public class OrderService {

    public OrderService(@NotNull CreditCardProcessor creditCardProcessor) {
        [...]
    }

    public void placeOrder(
        @NotNull @Size(min=3, max=20) String customerCode,
        @NotNull Item item,
        @Min(1) int quantity) {
        [...]
    }
}
----

====

Using constraint annotations, several preconditions are defined here. These preconditions which must be satisfied in order to legally invoke the methods of [classname]`OrderService` are:

* The [classname]`CreditCardProcessor` passed to the constructor must not be null.
* The customer code passed to the [methodname]`placeOrder()` method must not be null and must be between 3 and 20 characters long.
* The [classname]`Item` passed to the [methodname]`placeOrder()` method must not be null.
* The quantity value passed to the [methodname]`placeOrder()` method must be 1 at least.


Note that declaring these constraints does not automatically cause their validation when the concerned methods are invoked. It's the responsibility of an integration layer to trigger the validation of the constraints using a method interceptor, dynamic proxy or similar. See section <<validationapi-triggeringmethodvalidation>> for more details.

[TIP]
====
In order to use constraint annotations for method or constructor parameters, their element type must be [varname]`ElementType.PARAMETER`. In order to use constraint annotations for cross-parameter validation or on the return values of methods or constructors (see the following sections), their element type must be [varname]`ElementType.METHOD` respectively [varname]`ElementType.CONSTRUCTOR`. All built-in constraints support these element types, and it is considered a best practice to do the same for custom constraints.
====

[[constraintdeclarationvalidationprocess-methodlevelconstraints-parameterconstraints-crossparameterconstraints]]

===== Cross-parameter constraints

Cross-parameter constraints allow to express constraints based on the value of several method parameters, similar to class-level constraints which are based on several properties of a given class. [tck-testable]#Cross-parameter constraints are declared by putting cross-parameter constraint annotations on methods or constructors# as shown in the following example.

.Declaring cross-parameter constraints
====


[source, JAVA]
----
public class CalendarService {

    @ConsistentDateParameters
    public void createEvent(
        String title,
        @NotNull Date startDate,
        @NotNull Date endDate) {
        [...]
    }
}
----

====

The cross-parameter constraint annotation expresses here that the given start date must be before the passed end date in order to legally invoke the [methodname]`createEvent()` method. The example also shows that it is often useful to combine constraints directly placed on individual parameters ([classname]`e.g. @NotNull`) and cross-parameter constraints.

[TIP]
====
Cross-parameter constraints as well as return value constraints are declared directly on a method or a constructor. To make it obvious for a reader that an annotation refers to the parameters of a method or constructor and not its return value, it is recommended to choose a name which clearly expresses this intention.
====



[tck-testable]#It is not legal to declare a cross-parameter constraint on a method or constructor which has no parameters. A [classname]`ConstraintDeclarationException` is raised in this case.#

Some constraints can target an executable's return value as well as its array of parameters. [tck-testable]#They are known to be both generic and cross-parameter constraints. When using such a constraint on an executable to target the parameters, one must set [methodname]`validationAppliesTo` if there is an ambiguity.# The set of ambiguities is described in <<constraintsdefinitionimplementation-constraintdefinition-properties-validationappliesto>>. Even without ambiguity, it is recommended to explicitly set [methodname]`validationAppliesTo` to `ConstraintTarget.PARAMETERS` as it improves readability.

[[constraintdeclarationvalidationprocess-methodlevelconstraints-parameterconstraints-namingparameters]]
===== Naming parameters

In case the validation of a parameter constraint fails, the concerned parameter needs to be identified in the resulting [classname]`ConstraintViolation` (see section <<validationapi-constraintviolation>>). {spec-name-bv} defines the [classname]`jakarta.validation.ParameterNameProvider` API to which the retrieval of parameter names is delegated:

[role="api"]
.`ParameterNameProvider` interface
====
[source, JAVA, indent=0]
----
include::{validation-api-source-dir}jakarta/validation/ParameterNameProvider.java[lines=13..-1]
----
====

[tck-testable]
--
A conforming {spec-name-bv} implementation provides a default [classname]`ParameterNameProvider` implementation which returns parameter names as stored in the class file containing the validated executable, if present. A conforming implementation must either use the Java reflection API or ensure behavioral compatibility to using the reflection API in the following way:

 * Obtain the method's or constructor's parameters via [methodname]`java.lang.reflect.Executable.getParameters()`
 * Obtain each parameter's name via [methodname]`java.lang.reflect.Parameter.getName()`
--

Depending on whether the class file of the validated executable contains parameter name information or not, the actual parameter names as provided in the executable's definition will be returned or synthetic names in the form arg``PARAMETER_INDEX``, where `PARAMETER_INDEX` starts at 0 for the first parameter, e.g. [varname]`arg0`, [varname]`arg1` etc.

{spec-name-bv} providers and integrators are free to provide additional implementations (e.g. based on annotations specifying parameter names, debug symbols etc.). If a user wishes to use another parameter name provider than the default implementation, they may specify the provider to use with help of the bootstrap API (see <<validationapi-bootstrapping>>) or the XML configuration (see <<validationapi-bootstrapping-xmlconfiguration>>).

[tck-testable]#If an exception occurs during invocation of the [methodname]`getParameterNames()` methods, this exception is wrapped into a [classname]`ValidationException` by the {spec-name-bv} engine.#

[[constraintdeclarationvalidationprocess-methodlevelconstraints-returnvalueconstraints]]
==== Declaring return value constraints

[tck-testable]#Return value constraints are declared by putting constraint annotations directly on a method or constructor.#

Some constraints can target both the return value and the array of parameters of an executable. [tck-testable]#They are known to be both generic and cross-parameter constraints. When using such constraint on an executable to target the return value, one must set [methodname]`validationAppliesTo` in case there is an ambiguity.# The set of ambiguities is described in <<constraintsdefinitionimplementation-constraintdefinition-properties-validationappliesto>>. Even without ambiguity, it is recommended to explicitly set [methodname]`validationAppliesTo` to `ConstraintTarget.RETURN_VALUE` as it improves readability.

.Declaring return value constraints
====


[source, JAVA]
----
public class OrderService {

    private CreditCardProcessor creditCardProcessor;

    @ValidOnlineOrderService
    public OrderService(OnlineCreditCardProcessor creditCardProcessor) {
        this.creditCardProcessor = creditCardProcessor;
    }

    @ValidBatchOrderService
    public OrderService(BatchCreditCardProcessor creditCardProcessor) {
        this.creditCardProcessor = creditCardProcessor;
    }

    @NotNull
    @Size(min=1)
    public Set<CreditCardProcessor> getCreditCardProcessors() { [...] }

    @NotNull
    @Future
    public Date getNextAvailableDeliveryDate() { [...] }
}
----

====

Here the following postconditions are defined which are guaranteed to the caller of the methods and constructors of the [classname]`OrderService` class:

* The newly created [classname]`OrderService` object returned by the first constructor satisfies the conditions of the custom [classname]`@ValidOnlineOrderService` constraint.
* The newly created [classname]`OrderService` object returned by the second constructor satisfies the conditions of the custom [classname]`@ValidBatchOrderService` constraint.
* The set of [classname]`CreditCardProcessor` objects returned by [methodname]`getCreditCardProcessors()` will neither be null nor be empty.
* The [classname]`Date` object returned by [methodname]`getNextAvailableDeliveryDate()` will not be null and will be in the future.


Like parameter constraints, these return value constraints are not per-se validated upon method invocation, but instead an integration layer invoking the validation is required.

[[constraintdeclarationvalidationprocess-methodlevelconstraints-cascadedvalidation]]
==== Marking parameters and return values for cascaded validation

[tck-testable]#The [classname]`@Valid` annotation is used to declare that a cascaded validation of the given method/constructor parameters or return values is performed by the {spec-name-bv} provider. When marked, the parameter or return value is considered a bean object to validate.# The same rules as for standard object graph validation (see <<constraintdeclarationvalidationprocess-validationroutine-graphvalidation>>) apply, in particular

* [tck-testable]#null arguments and null return values are ignored#
* [tck-testable]#The validation is recursive; that is, if validated parameter or return value objects have references marked with [classname]`@Valid` themselves, these references will also be validated#
* [tck-not-testable]#{spec-name-bv} providers must guarantee the prevention of infinite loops during cascaded validation#


.Marking parameters and return values for cascaded validation
====


[source, JAVA]
----
public class OrderService {

    @NotNull @Valid
    private CreditCardProcessor creditCardProcessor;

    @Valid
    public OrderService(@NotNull @Valid CreditCardProcessor creditCardProcessor) {
        this.creditCardProcessor = creditCardProcessor;
    }

    @NotNull @Valid
    public Order getOrderByPk(@NotNull @Valid OrderPK orderPk) { [...] }

    @NotNull
    public Set<@Valid Order> getOrdersByCustomer(@NotNull @Valid CustomerPK customerPk) { [...] }
}
----

====

Here the following recursive validations will happen when validating the methods of the [classname]`OrderService` class:

* Validation of the constraints on the object passed for the [varname]`creditCardProcessor` parameter of the constructor
* Validation of the constraints on the newly created [classname]`OrderService` instance returned by the constructor, i.e. the [classname]`@NotNull` constraint on the field [varname]`creditCardProcessor` and the constraints on the referenced [classname]`CreditCardProcessor` instance (as the field is annotated with [classname]`@Valid`).
* Validation of the constraints on the object passed for the [varname]`orderPk` parameter and the returned [classname]`Order` object of the [methodname]`getOrderByPk()` method
* Validation of the constraints on the object passed for the [varname]`customerPk` parameter and the constraints on each object contained within the returned [varname]`Set<Order>` of the [methodname]`getOrdersByCustomer()` method

Again, solely marking parameters and return values for cascaded validation does not trigger the actual validation.

[[constraintdeclarationvalidationprocess-methodlevelconstraints-inheritance]]
==== Method constraints in inheritance hierarchies

When defining method constraints within inheritance hierarchies (that is, class inheritance by extending base classes and interface inheritance by implementing or extending interfaces) one has to obey the link:$$http://en.wikipedia.org/wiki/Liskov_substitution_principle$$[Liskov substitution] principle which mandates that:

* a method's preconditions (as represented by parameter constraints) must not be strengthened in sub types
* a method's postconditions (as represented by return value constraints) must not be weakened in sub types


[TIP]
====
Very informally speaking, the Liskov substitution principle says that where a given type T is used, it should be possible to replace T with a sub-type S of T ("Behavioral subtyping"). If S overrides/implements a method from T and S would strengthen the method's preconditions (e.g. by adding parameter constraints) this principle would be violated as client code working correctly against T might fail when working against S. Also if S overrides/implements a method from T and S weakens the method's postconditions this principle would be violated. However S may strengthen the method's postconditions (by adding return value constraints), as client code working against T still will work against S.
====

Therefore the following rules with respect to the definition of method level constraints in inheritance hierarchies apply:

* [tck-testable]#In sub types (be it sub classes/interfaces or interface implementations), no parameter constraints may be declared on overridden or implemented methods, nor may parameters be marked for cascaded validation. This would pose a strengthening of preconditions to be fulfilled by the caller.#
* [tck-testable]#If a sub type overrides/implements a method originally defined in several parallel types of the hierarchy (e.g. two interfaces not extending each other, or a class and an interface not implemented by said class), no parameter constraints may be declared for that method at all nor parameters be marked for cascaded validation. This again is to avoid an unexpected strengthening of preconditions to be fulfilled by the caller.#
* [tck-testable]#In sub types (be it sub classes/interfaces or interface implementations), return value constraints may be declared on overridden or implemented methods and the return value may be marked for cascaded validation. Upon validation, all return value constraints of the method in question are validated, wherever they are declared in the hierarchy. This only poses possibly a strengthening but no weakening of the method's postconditions guaranteed to the caller.#
* [tck-testable]#One must not mark a method return value for cascaded validation more than once in a line of a class hierarchy. In other words, overriding methods on sub types (be it sub classes/interfaces or interface implementations) cannot mark the return value for cascaded validation if the return value has already been marked on the overridden method of the super type or interface.#


[tck-testable]#Out of the box, a conforming {spec-name-bv} provider must throw a [classname]`ConstraintDeclarationException` when discovering that any of these rules are violated.# In addition providers may implement alternative, potentially more liberal, approaches for handling constrained methods in inheritance hierarchies. Possible means for activating such alternative behavior include provider-specific configuration properties or annotations. Note that client code relying on such alternative behavior is not portable between {spec-name-bv} providers.

[tck-testable]#The above rules do not apply when validating constructor constraints as constructors do not override one another. Parameter and return value constraints can be applied to any constructor in the type hierarchy, but only the constraints defined directly on the validated constructor are evaluated.#

[[constraintdeclarationvalidationprocess-methodlevelconstraints-inheritance-examples]]
===== Examples

This sections provides some examples of illegal constraint definitions which violate the rules stated above in one way or another.

.Illegally declared parameter constraints on interface implementation
====


[source, JAVA]
----
public interface OrderService {

    void placeOrder(String customerCode, Item item, int quantity);
}

public class SimpleOrderService implements OrderService {

    @Override
    public void placeOrder(
        @NotNull @Size(min=3, max=20) String customerCode,
        @NotNull Item item,
        @Min(1) int quantity) {
        [...]
    }
}
----

====

The constraints in [classname]`SimpleOrderService` are illegal, as they strengthen the preconditions of the [methodname]`placeOrder()` method as constituted by the interface [classname]`OrderService`.

.Illegally declared parameter constraints on sub class
====


[source, JAVA]
----
public class OrderService {

    void placeOrder(String customerCode, Item item, int quantity) { [...] }
}

public class SimpleOrderService extends OrderService {

    @Override
    public void placeOrder(
        @NotNull @Size(min=3, max=20) String customerCode,
        @NotNull Item item,
        @Min(1) int quantity) {
        [...]
    }
}
----

====



The constraints in [classname]`SimpleOrderService` are illegal, as they strengthen the preconditions of the [methodname]`placeOrder()` method as constituted by the super class [classname]`OrderService`.

[[illegal_constraints_in_parallel_types]]

.Illegally declared parameter constraints on parallel types
====


[source, JAVA]
----
public interface OrderService {

    void placeOrder(String customerCode, Item item, int quantity);
}

public interface OrderPlacementService {

    public void placeOrder(
        @NotNull @Size(min=3, max=20) String customerCode,
        @NotNull Item item,
        @Min(1) int quantity);
}

public class SimpleOrderService implements OrderService, OrderPlacementService {

    @Override
    public void placeOrder(String customerCode, Item item, int quantity) {
        [...]
    }
}
----

====

Here the class [classname]`SimpleOrderService` implements the interfaces [classname]`OrderService` and [classname]`OrderPlacementService`, which themselves are unrelated to each other but both define a method [methodname]`placeOrder()` with an identical signature. This hierarchy is illegal with respect to the parameter constraints as a client of [classname]`SimpleOrderService` would have to fulfill the constraints defined on the interface [classname]`OrderPlacementService` even if the client only expects [classname]`OrderService`.

.Correctly declared return value constraints on sub class
====


[source, JAVA]
----
public class OrderService {

    Order placeOrder(String customerCode, Item item, int quantity) {
        [...]
    }
}

public class SimpleOrderService extends OrderService {

    @Override
    @NotNull
    @Valid
    public Order placeOrder(String customerCode, Item item, int quantity) {
        [...]
    }
}
----

====

The return value constraints in [classname]`DefaultOrderService` are legal, as they strengthen the postconditions of the [methodname]`placeOrder()` method as constituted by the super class [classname]`OrderService` but don't weaken them.

[[constraintdeclarationvalidationprocess-validationroutine]]
=== Validation routine

[tck-testable]
--
For a given group, the validation routine applied on a given bean instance is expected to execute the following constraint validations in no particular order:

* for all _reachable_ fields, execute all field level validations (including the ones expressed on superclasses) matching the targeted group unless the given validation constraint has already been processed during this validation routine for a given navigation path (see <<constraintdeclarationvalidationprocess-validationroutine-graphvalidation>>) as part of a previous group match.
* for all _reachable_ getters, execute all getter level validations (including the ones expressed on interfaces and superclasses) matching the targeted group unless the given validation constraint has already been processed during this validation routine for a given navigation path (see <<constraintdeclarationvalidationprocess-validationroutine-graphvalidation>>) as part of a previous group match.
* execute all class level validations (including the ones expressed on interfaces and superclasses) matching the targeted group unless the given validation constraint has already been processed during this validation routine for a given navigation path (see <<constraintdeclarationvalidationprocess-validationroutine-graphvalidation>>) as part of a previous group match.
* for all _reachable_ and _cascadable_ associations, execute all cascading validations (see <<constraintdeclarationvalidationprocess-validationroutine-graphvalidation>>) including the ones expressed on interfaces and superclasses (see <<constraintdeclarationvalidationprocess-groupsequence-formaldefinition>>). Note that group conversion can apply (see <<constraintdeclarationvalidationprocess-groupsequence-groupconversion>>).

--

Reachable fields, getters and associations as well as cascadable associations are defined in <<constraintdeclarationvalidationprocess-validationroutine-traversable>>.

Note that this implies that a given validation constraint will not be processed more than once per validation per path. Some implementations might even process a single constraint only once across paths provided that they return the expected set of [classname]`ConstraintViolation`.

[tck-not-testable]#Unless ordered by group sequences, groups can be validated in no particular order.# This implies that the validation routine can be run for several groups in the same pass.

[tck-testable]
--
The object validation routine is described as such. For each constraint declaration:

* determine for the constraint declaration, the appropriate [classname]`ConstraintValidator` to use (see <<constraintdeclarationvalidationprocess-validationroutine-typevalidatorresolution>>).
* execute the [methodname]`isValid` operation (from the constraint validation implementation) on the appropriate data (see <<constraintsdefinitionimplementation-validationimplementation>>)
* if [methodname]`isValid()` returns `true`, continue to the next constraint,
* if [methodname]`isValid()` returns `false`, the {spec-name-bv} provider populates [classname]`ConstraintViolation` object(s) according to the rules defined in <<constraintsdefinitionimplementation-validationimplementation>> and appends these objects to the list of constraint violations.
--

[[constraintdeclarationvalidationprocess-validationroutine-graphvalidation]]

==== Object graph validation

[tck-testable]#The [classname]`@Valid` annotation on a given association (i.e. object reference or collection, array, [classname]`Iterable` of objects), dictates the {spec-name-bv} implementation to apply recursively the {spec-name-bv} routine on (each of) the associated object(s).# [tck-testable]#This mechanism is recursive: an associated object can itself contain cascaded references.#

[tck-testable]#Null references are ignored.#

[tck-testable]#To prevent infinite loops, the {spec-name-bv} implementation must ignore the cascading operation if the associated object instance has already been validated in the current navigation path (starting from the root object).# See <<example-oglimit>> for an example. A navigation path is defined as a set of [classname]`@Valid` associations starting from the root object instance and reaching the associated instance. A given navigation path cannot contain the same instance multiple times (the complete validated object graph can though). See <<example-oglimit>> for an example.

[NOTE]
====
This object graph navigation can lead to multiple validations of the same constraint and the same object instance but the set of constraint validation is deterministic and the algorithm prevents infinite loops.
====

[[example-oglimit]]

.Object graph limits
====

[source,subs="verbatim,specialchars,specialcharacters,normal"]
----
#assuming the following object graph

Order -(lines)-> Orderline1
Order -(lines)-> Orderline2
Orderline1 -(order)-> Order
Orderline2 -(order)-> Order
Order -(customer)-> User
Order -(shippingAddress)-> Address1
Order -(billingAddress)-> Address2
Address1 -(inhabitant)-> User
Address2 -(inhabitant)-> User
User -(addresses)-> Address1
User -(addresses)-> Address2

#validation branches are as followed
Order -(lines)-> Orderline1
  - order is ignored: Order is already present in the branch

Order -(lines)-> Orderline2
  - order is ignored: Order is already present in the branch

Order -(customer)-> User -(addresses)-> Address1
  - inhabitant is ignored: User is already present in the branch

Order -(customer)-> User -(addresses)-> Address2
  - inhabitant is ignored: User is already present in the branch

Order -(shippingAddress)-> Address1 -(inhabitant)-> User
  - addresses to Address1 is ignored: Address1 is already present in the branch

Order -(shippingAddress)-> Address1 -(inhabitant)-> User -(addresses)-> Address2
  - inhabitant is ignored: User is already present in the branch

Order -(billingAddress)-> Address2 -(inhabitant)-> User
  - addresses to Address2 is ignored: Address2 is already present in the branch

Order -(billingAddress)-> Address2 -(inhabitant)-> User -(addresses)-> Address1
  - inhabitant is ignored: User is already present in the branch
----

====

The [classname]`ConstraintViolation` objects are built when a failing constraint on an associated object is found. They reflect the path to reach the object from the root validated object (See <<validationapi-constraintviolation>>).

[tck-testable]#[classname]`@Valid` is an orthogonal concept to the notion of group. If two groups are in sequence, the first group must pass for all associated objects before the second group is evaluated.# Note however that the [classname]`Default` group sequence overriding is local to the class it is defined on and is not propagated to the associated objects. The following example illustrates this:

.Class Driver with redefined default group
====

[source, JAVA]
----
@GroupSequence({ Minimal.class, Driver.class })
public class Driver {
  @Min(value = 18, groups = Minimal.class)
  int age;

  @AssertTrue
  Boolean passedDrivingTest;

  @Valid
  Car car;

  // setter/getters
}
----

====

.Class Car with redefined default group
====

[source, JAVA]
----
@GroupSequence({ Car.class, Later.class })
public class Car {
  @NotNull
  String type;

  @AssertTrue(groups = Later.class)
  Boolean roadWorthy;

  // setter/getters
}
----

====

.Defining a group sequence
====

[source, JAVA]
----
@GroupSequence({ Minimal.class, Later.class })
public interface SequencedGroups {
}
----

====

.Group sequence overriding is not propagated to associated objects
====

[source, JAVA]
----
Validator validator = Validation.buildDefaultValidatorFactory().getValidator();

Driver driver = new Driver();
driver.setAge(16);
Car porsche = new Car();
driver.setCar(porsche);


Set<ConstraintViolation<Driver>> violations = validator.validate( driver );

assert violations.size() == 2;

violations = validator.validate( driver, SequencedGroups.class );

assert violations.size() == 1;
----

====

The default group sequence is redefined for the [classname]`Driver` as well as [classname]`Car`. When the default group is requested via [methodname]`validator.validate( driver )` the group [classname]`Minimal` gets validated in class [classname]`Driver`. The constraint will fail since the driver's age in the example is only 16. The constraint on [property]`passedDrivingTest` will not be evaluated due to the redefined default sequence of [classname]`Driver`. However, there is one more constraint violation, namely the [classname]`@NotNull` on [property]`Car.type`. The reason for this is that the group [classname]`Default` gets propagated to [classname]`Car` (not [classname]`Minimal`). Class [classname]`Driver` defines its own group sequence which means that [classname]`only @NotNull` on [property]`type` gets evaluated.

In the second call to [methodname]`validate` the group [classname]`SequencedGroups` is requested which defines a sequence of [classname]`Minimal` followed by [classname]`Later`. In this case there is only one constraint violation. Again [classname]`@Min` on [property]`age` fails, but in this case the group [classname]`Minimal` gets propagated to [classname]`Car` which does not have any constraints defined against this group. Constraints belonging to the group [classname]`Later` won't get validated until all constraints belonging to [classname]`Minimal` pass.

[[constraintdeclarationvalidationprocess-validationroutine-methodconstructorvalidation]]
==== Method and constructor validation

[tck-testable]
--
For a given group, the validation routine applied to validate parameters of a method or constructor is expected to execute the following constraint validations in no particular order:

* execute all parameter validations (in case of overriding method validation, including the ones expressed on overridden methods of the interfaces and superclasses) matching the targeted group unless the given validation constraint has already been processed during this validation routine for a given navigation path (see <<constraintdeclarationvalidationprocess-validationroutine-graphvalidation>>) as part of a previous group match.
* execute all cross parameter validations (in case of overriding method validation, including the ones expressed on overridden methods of the interfaces and superclasses) matching the targeted group unless the given validation constraint has already been processed during this validation routine for a given navigation path (see <<constraintdeclarationvalidationprocess-validationroutine-graphvalidation>>) as part of a previous group match.
* for all parameters marked for cascaded validation, execute all cascading validations (see <<constraintdeclarationvalidationprocess-validationroutine-graphvalidation>>), in case of overriding method validation including the ones expressed on overridden methods of the interfaces and superclasses (see <<constraintdeclarationvalidationprocess-groupsequence-formaldefinition>>). Note that group conversion can apply (see <<constraintdeclarationvalidationprocess-groupsequence-groupconversion>>).
--

[tck-testable]
--
For a given group, the validation routine applied to validate the return value of a method or constructor is expected to execute the following constraint validations in no particular order:

* execute all return value validations (including the ones expressed on interfaces and superclasses) matching the targeted group unless the given validation constraint has already been processed during this validation routine for a given navigation path (see <<constraintdeclarationvalidationprocess-validationroutine-graphvalidation>>) as part of a previous group match.
* if the return value is marked for cascaded validation, execute all cascading validations (see <<constraintdeclarationvalidationprocess-validationroutine-graphvalidation>>) including the ones expressed on interfaces and superclasses (see <<constraintdeclarationvalidationprocess-groupsequence-formaldefinition>>). Note that group conversion can apply (see <<constraintdeclarationvalidationprocess-groupsequence-groupconversion>>).
--

Note that this implies that a given validation constraint will not be processed more than once per validation per path. Some implementations might even process a single constraint only once across paths provided that they return the expected set of [classname]`ConstraintViolation`.

[tck-not-testable]#Unless ordered by group sequences, groups can be validated in no particular order.# This implies that the validation routine can be run for several groups in the same pass.

The object validation routine is as defined in described in <<constraintdeclarationvalidationprocess-validationroutine>>.

[[constraintdeclarationvalidationprocess-validationroutine-traversable]]

==== Traversable property

In some cases, the state of some properties should not be accessed. For example, if a property loaded by a {spec-name-persistence} provider is a lazy property or a lazy association, accessing its state would trigger a load from the database. An undesired behavior.

{spec-name-bv} offers a way to control which property can and cannot be accessed via the [classname]`TraversableResolver.isReachable`() contract.

Likewise, it is sometimes undesirable to cascade validation despite the use of [classname]`@Valid`. {spec-name-persistence} 2 for example does not cascade to associated entities during flush. You can control this behavior by implementing [methodname]`TraversableResolver.isCascadable()`.

[role="api"]
.`TraversableResolver` interface
====
[source, JAVA]
----
include::{validation-api-source-dir}jakarta/validation/TraversableResolver.java[lines=13..-1]
----
====

[tck-testable]#[methodname]`isReachable()` is called for every property about to be accessed either for validation or for cascading.# A property is _reachable_ if this method returns `true`.

[tck-testable]#[methodname]`isCascadable()` is called for every property about to be cascaded (i.e. marked as [classname]`@Valid`).# A property is _cascadable_ if it is reachable and if the [methodname]`isCascadable` method returns `true`.

[NOTE]
====
[tck-testable]#[methodname]`isCascadable()` for a given property is only called if [methodname]`isReachable()` returns `true`. In other words, [methodname]`isReachable()` is always called before [methodname]`isCascadable()` for a given property.#
====

[tck-testable]#`traversableObject` is the object instance being evaluated. `null` if the check is triggered as part of a [methodname]`validateValue()` call.#

[tck-testable]#`traversableProperty` is the [classname]`Node` representing the property hosted by the [methodname]`traversableObject` being considered for traversal. The name of a property is defined in <<constraintdeclarationvalidationprocess-requirements-propertyvalidation>>.#

[tck-testable]#`rootBeanType` is the class of the root being validated, i.e. either the type of the object passed to the [methodname]`validate` method or the type declaring the validated method/constructor in case of method validation.#

[tck-testable]#`pathToTraversableObject` is the [classname]`Path` from the [methodname]`rootBeanType` down to the [methodname]`traversableObject`. If the root object is [classname]`traversableObject`, [classname]`pathToTraversableObject` is composed of a single Node whose name is `null`. The path is described following the conventions described in <<validationapi-constraintviolation>> ([methodname]`getPropertyPath`).#

[tck-testable]#`elementType` is the [classname]`java.lang.annotation.ElementType` the annotation is placed on. It can be either `FIELD` or `METHOD`. Any other value is not expected.#

[tck-testable]#The {spec-name-bv} provider must not access the state of a property, nor validate its constraints if the property is not traversable. A property is traversable if [classname]`TraversableResolver` returns `true` for this property.#

[tck-testable]#If an exception occurs when the [classname]`TraversableResolver` is called, the exception is wrapped into a [classname]`ValidationException`.#

[tck-testable]
--
The following elements are not passed through the traversable resolver filter:

* the bean instance validated
* the method and constructor parameter values being validated
* the method and constructor return value being validated
--

[tck-testable]#But the properties of these elements (if validated) are. In this case the complete path is provided via `pathToTraversableObject`.#

The traversable resolver used by default by a {spec-name-bv} provider behaves as followed:

* [tck-not-testable]#if {spec-name-persistence} is available in the runtime environment, a property is considered reachable if {spec-name-persistence} considers the property as loaded.# A typical implementation will use [code]`Persistence.getPersistenceUtil().isLoaded(Object, String)` to implement such contract.
* [tck-not-testable]#if {spec-name-persistence} is not available in the runtime environment, all properties are considered reachable.#
* [tck-not-testable]#all properties are considered cascadable.#


An example implementation of such a resolver is shown in <<constraintdeclarationvalidationprocess-validationroutine-traversable-jparesolver>>.

[[constraintdeclarationvalidationprocess-validationroutine-traversable-jparesolver]]

.{spec-name-persistence} aware TraversableResolver
====

[source, JAVA]
----
public class JPATraversableResolver implements TraversableResolver {

    public boolean isReachable(Object traversableObject,
                               Path.Node traversableProperty,
                               Class<?> rootBeanType,
                               Path pathToTraversableObject,
                               ElementType elementType) {
        return traversableObject == null ||
                Persistence.getPersistenceUtil().isLoaded(
                        traversableObject,
                        traversableProperty.getName() );
    }

    public boolean isCascadable(Object traversableObject,
                               Path.Node traversableProperty,
                               Class<?> rootBeanType,
                               Path pathToTraversableObject,
                               ElementType elementType) {
        return true;
    }
}
----

====

See <<validationapi-bootstrapping>> to learn how to pass a custom [classname]`TraversableResolver`.

[[constraintdeclarationvalidationprocess-validationroutine-traversable-examples]]

===== Examples

The following example assumes the object graph defined in <<example-ognav-definitions>> and assumes the validation operation is applied on an address object.

[[example-ognav-definitions]]

.Definitions used in the example
====

[source, JAVA]
----
public class Country {
    @NotNull
    private String name;
    @Size(max=2)
    private String ISO2Code;
    @Size(max=3)
    private String ISO3Code;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getISO2Code() {
        return ISO2Code;
    }

    public void setISO2Code(String ISO2Code) {
        this.ISO2Code = ISO2Code;
    }

    public String getISO3Code() {
        return ISO3Code;
    }

    public void setISO3Code(String ISO3Code) {
        this.ISO3Code = ISO3Code;
    }
}

public class Address {
    @NotNull @Size(max=30)
    private String addressline1;
    @Size(max=30)
    private String addressline2;
    @Size(max=11)
    private String zipCode;
    @Valid
    private Country country;

    private String city;

    public String getAddressline1() {
        return addressline1;
    }

    public void setAddressline1(String addressline1) {
        this.addressline1 = addressline1;
    }

    public String getAddressline2() {
        return addressline2;
    }

    public void setAddressline2(String addressline2) {
        this.addressline2 = addressline2;
    }

    public String getZipCode() {
        return zipCode;
    }

    public void setZipCode(String zipCode) {
        this.zipCode = zipCode;
    }

    @Size(max=30) @NotNull
    public String getCity() {
        return city;
    }

    public void setCity(String city) {
        this.city = city;
    }

    public Country getCountry() {
        return country;
    }

    public void setCountry(Country country) {
        this.country = country;
    }
}
----

====

When the {spec-name-bv} provider is about to check constraints of `ISO3Code`, it calls the [classname]`TraversableResolver.isReachable()` method to ensure that the `ISO3Code` property is reachable with the following parameter values:

* `traversableObject`: country. The instance returned by [code]`address.getCountry()`.
* `traversableProperty`: a [classname]`PropertyNode` whose name is "ISO3Code". Represents the property of `traversableObject` being verified.
* [methodname]`rootBeanType`: [classname]`Address.class`. The type of the root object being validated.
* `pathtoTraversableObject`: a [classname]`Path` containing a single [classname]`PropertyNode` whose name is "country". The path from address to the country instance.
* `elementType`: [classname]`ElementType.FIELD`. The ISO3Code property is annotated on its field.


When the {spec-name-bv} provider is about to cascade validation on `country` ([classname]`Address` object), it calls the [classname]`TraversableResolver.isReachable()` method to ensure that the `country` property is reachable and if this method returns `true`, it calls [classname]`TraversableResolver.isCascadable()` with the following parameter values:

* `traversableObject`: address. The address instance.
* `traversableProperty`: a [classname]`PropertyNode` whose name is "country". Represents the property of `traversableObject` being verified.
* [methodname]`rootBeanType`: [classname]`Address.class`. The type of the root object being validated.
* `pathtoTraversableObject`: a [classname]`Path` containing a single [classname]`BeanNode` whose name is `null`.
* `elementType`: [classname]`ElementType.FIELD`. The country property is annotated on its field.


The following example shows invocations of the [classname]`TraversableResolver` as to be performed by the {spec-name-bv} provider during method validation. The example is based on the object graph defined in <<example-ognav-definitions>> and the [classname]`AddressService` class shown in <<example-ognav-definitions-methodvalidation>>. It assumes that a call of [methodname]`persistAddress()` is subject to method parameter validation.

[[example-ognav-definitions-methodvalidation]]

.Examplary class [classname]`AddressService`
====

[source, JAVA]
----
public class AddressService {
    public void persistAddress(@NotNull @Valid Address address) {
        [...]
    }
}
----

====

When the {spec-name-bv} provider is about to validate the [classname]`@NotNull` constraint on the [varname]`address` parameter, no call to [methodname]`isReachable()` is expected, since parameters are assumed to always be reachable. Similarly, no call to [methodname]`isCascadable()` is expected when performing cascaded validation of the [varname]`address` parameter, since parameters are assumed to always be cascadable.

When the {spec-name-bv} provider is about to validate constraints on the field [varname]`addressline1` of the passed [classname]`Address` object, it calls the [methodname]`isReachable()` method to ensure that the property is reachable with the following parameter values:

* `traversableObject`: address. The instance passed to [methodname]`persistAddress()`.
* `traversableProperty`: a [classname]`PropertyNode` whose name is "addressline1". Represents the property of `traversableObject` being verified.
* [methodname]`rootBeanType`: [classname]`AddressService.class`. The type of the root object being validated.
* `pathtoTraversableObject`: a [classname]`Path` comprising a [classname]`MethodNode` (named "persistService") and a [classname]`ParameterNode` (with parameter index 0). The path from [classname]`AddressService` to the [classname]`Address` instance.
* `elementType`: [classname]`ElementType.FIELD`. The [varname]`addressline1` property is annotated on its field.


When the {spec-name-bv} provider is about to perform a cascaded validation of the [varname]`country` property of the passed [classname]`Address` object, it calls the [methodname]`isReachable()` method to ensure that the property is reachable. If this method returns `true`, it calls [classname]`TraversableResolver.isCascadable()` with the following parameter values:

* `traversableObject`: address. The instance passed to [methodname]`persistAddress()`.
* `traversableProperty`: a [classname]`PropertyNode` whose name is "country". Represents the property of `traversableObject` being verified.
* [methodname]`rootBeanType`: [classname]`AddressService.class`. The type of the root object being validated.
* `pathtoTraversableObject`: a [classname]`Path` comprising a [classname]`MethodNode` (named "persistService") and a [classname]`ParameterNode` (with parameter index 0). The path from [classname]`AddressService` to the [classname]`Address` instance.
* `elementType`: [classname]`ElementType.FIELD`. The [varname]`country` property is annotated on its field.


[[constraintdeclarationvalidationprocess-validationroutine-typevalidatorresolution]]

==== ConstraintValidator resolution algorithm

A constraint is associated to one or more [classname]`ConstraintValidator` implementations. Each [classname]`ConstraintValidator<A, T>` accepts the type [classname]`T`. The [classname]`ConstraintValidator` executed depends on the type hosting the constraint. For a given constraint evaluation, a single [classname]`ConstraintValidator` is considered.

[tck-testable]#The list of [classname]``ConstraintValidator``s can contain at most one which targets cross-parameter. If the constraint targets the parameters of an executable either implicitly or by the use of [methodname]`validationAppliesTo` in the constraint - see <<constraintsdefinitionimplementation-constraintdefinition-properties-validationappliesto>>, then the cross-parameter [classname]`ConstraintValidator` is used. If none is present, a [classname]`ConstraintDefinitionException` is raised. If more than one cross-parameter [classname]`ConstraintValidator` is present, a [classname]`ConstraintDefinitionException` is raised.#

If the constraint is a generic constraint, the following rules apply:

* [tck-testable]#If the constraint declaration is hosted on a class or an interface, the targeted type is the class or the interface.#
* [tck-testable]#If the constraint is hosted on a class attribute, the type of the attribute is the targeted type.#
* [tck-testable]#If the constraint is hosted on a method (getter or non-getter) or constructor, the return type is the targeted type.#
* [tck-testable]#If the constraint is hosted on a method or constructor parameter, the parameter type is the targeted type.#
* [tck-testable]#If the constraint is hosted on a type argument of a parameterized type (i.e. a container element constraint, see <<constraintdeclarationvalidationprocess-containerelementconstraints>>), the type argument's type is the targeted type.#
* [tck-testable]#If the constraint is subject to implicit unwrapping (see <<constraintdeclarationvalidationprocess-containerelementconstraints-implicitunwrapping>>) and the applicable value extractor is defined for a generic type (e.g. `javafx.beans.value.ObservableValue`), the targeted type is the type captured for the type parameter handled by the value extractor (e.g. `String` if the constraint is placed on a `StringProperty`).#
* [tck-testable]#If the constraint is subject to implicit unwrapping and the applicable value extractor is defined for a non-generic type, the targeted type is the type defined by the extractor via `@ExtractedValue#type()` (e.g. `Integer` if the constraint is placed on a `java.util.OptionalInt`).#

In other words, the resolution algorithm considers the type as defined in the source code and not the runtime type of the value.

The rules written below describe formally the following statement: [tck-testable]#the [classname]`ConstraintValidator` chosen to validate the generic constraint on a declared type [classname]`T` is the one where the [classname]`ConstraintValidator` targets the annotated element, where the type supported by the [classname]`ConstraintValidator` is a supertype of [classname]`T` and where there is no other [classname]`ConstraintValidator` whose supported type is a supertype of [classname]`T` and not a supertype of the chosen [classname]`ConstraintValidator` supported type.#

When validating a generic constraint [classname]`A` placed on a target declaring the type [classname]`T`, the following resolution rules apply:

* [tck-testable]#Only [classname]`ConstraintValidator` implementations targeting annotated elements are considered.#
* [tck-testable]#Primitive types are considered equivalent to their respective primitive wrapper class.#
* A [classname]`ConstraintValidator<A, U>` is said to be _compliant_ with [classname]`T` if [classname]`T` is a subtype of [classname]`U` (according to the http://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.10[Java Language Specification, Java SE 8 Edition, chapter 4.10, "Subtyping"]). Note that [classname]`T` is a subtype of [classname]`U` if [classname]`T` = [classname]`U`.
* [tck-testable]#If no [classname]`ConstraintValidator` compliant with [classname]`T` is found among the [classname]``ConstraintValidator``s listed by the constraint [classname]`A`, an [classname]`UnexpectedTypeException` is raised.#
* [tck-testable]#A [classname]`ConstraintValidator<A, U>` compliant with [classname]`T` is considered _strictly more specific_ than a [classname]`ConstraintValidator<A, V>` compliant with [classname]`T` if [classname]`U` is a strict subtype of [classname]`V`. [classname]`U` is a strict subtype of [classname]`V` if [classname]`U` is a subtype of [classname]`V` and [classname]`U` != [classname]`V` (according to the http://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.10[Java Language Specification]).#
* A [classname]`ConstraintValidator<A, U>` compliant with [classname]`T` is considered maximally specific if no other [classname]`ConstraintValidator<A, V>` compliant with [classname]`T` is strictly more specific than [classname]`ConstraintValidator<A, U>`.
* [tck-testable]#If more than one maximally specific [classname]`ConstraintValidator` is found, an [classname]`UnexpectedTypeException` is raised.#


[NOTE]
====
While the Java compiler itself cannot determine if a constraint declaration will lead to a [classname]`UnexpectedTypeException`, rules can be statically checked. A tool such as an IDE or an annotation processor can apply these rules and prevent compilation in case of ambiguity. The specification encourages {spec-name-bv} providers to provide such a tool to their users.
====

Let's see a couple of declarations and their respective [classname]`ConstraintValidator` resolution. Assuming the definitions shown in <<example-constraintvalidator-resolution>>:

[[example-constraintvalidator-resolution]]

.ConstraintValidator and type resolution
====

[source, JAVA]
----
[...]
@Constraint(validatedBy={
    SizeValidatorForCollection.class,
    SizeValidatorForSet.class,
    SizeValidatorForSerializable.class })
public @interface Size { [...] }

public class SizeValidatorForCollection implements ConstraintValidator<Size, Collection> {
    [...]
}
public class SizeValidatorForSet implements ConstraintValidator<Size, Set> {
    [...]
}
public class SizeValidatorForSerializable implements ConstraintValidator<Size, Serializable> {
    [...]
}

public interface SerializableCollection extends Serializable, Collection {
}
----

====

The resolutions shown in <<table-constraintvalidator-resolution>> occur.

[[table-constraintvalidator-resolution]]

.Resolution of ConstraintValidator for various constraints declarations
[options="header"]
|===============
|Declaration|Resolution
|[code]`@Size Collection getAddresses() { [...] }`|[classname]`SizeValidatorForCollection`: direct
              match
|[code]`@Size Collection<?> getAddresses() { [...] }`|[classname]`SizeValidatorForCollection`:
              [classname]`Collection`  is a direct supertype of
              [classname]`Collection<?>`
|[code]`@Size Collection<Address> getAddresses() { [...] }`|[classname]`SizeValidatorForCollection`:
              [classname]`Collection`  is a direct supertype of
              [classname]`Collection<Address>`
|[code]`@Size Set<Address> getAddresses() { [...] }`|[classname]`SizeValidatorForSet`: direct
              supertype of [classname]`Set<Address>`
|[code]`@Size SortedSet<Address> getAddresses() { [...] }`|[classname]`SizeValidatorForSet`:
              [classname]`Set`  is the closest supertype of
              [classname]`SortedSet<Address>`
|[code]`@Size SerializableCollection getAddresses() { [...] }`|[classname]`UnexpectedTypeException`:
              [classname]`SerializableCollection`  is a subtype of
              both [classname]`Collection`  and
              [classname]`Serializable`  and neither
              [classname]`Collection`  nor
              [classname]`Serializable`  are subtypes of each
              other.
|[code]`@Size String getName() { [...] }`|[classname]`UnexpectedTypeException`: none of
              the [classname]`ConstraintValidator`  types are
              supertypes of [classname]`String`.
|===============

[[constraintdeclarationvalidationprocess-validationroutine-valueextractorresolution]]
==== ValueExtractor resolution

When detecting a container element constraint or a container element marked with `@Valid`, a value extractor must be determined so that the elements can be obtained from that container.

A value extractor handles one container type and - in the case of a generic container type - one type parameter of that container type.
The applicable extractor is identified based on the container type and - in the case of a generic container type - the type argument hosting the container element constraint or `@Valid`.

Exactly one value extractor must be identified when processing a container element constraint or container element marked with `@Valid`.

[[constraintdeclarationvalidationprocess-validationroutine-valueextractorresolution-registering]]
===== Registering ValueExtractor implementations

Value extractors can be registered with the validation engine in the following ways (in increasing order of priority):

* Provided by the validation engine itself (see <<valueextractordefinition-builtinvalueextractors>>)
* [tck-testable]#Via the Java https://docs.oracle.com/javase/8/docs/api/java/util/ServiceLoader.html[service loader] mechanism; for this the file _META-INF/services/jakarta.validation.valueextraction.ValueExtractor_ must be provided#,
with the fully-qualified name(s) of one or more extractor implementations as its contents.
It is undefined which value extractor will be selected if multiple extractors for the same type and type parameter are registered via the service loader mechanism.
* [tck-testable]#By specifying the fully-qualified class name of one or several extractors in `META-INF/validation.xml`# (see <<validationapi-bootstrapping-xmlconfiguration>>). Not more than one extractor for the same type and type parameter may be given.
* [tck-testable]#By invoking the method `Configuration#addValueExtractor(ValueExtractor<?>)` (to apply it at the validator factory level).#  Not more than one extractor for the same type and type parameter may be passed.
* [tck-testable]#By invoking the method `ValidatorContext#addValueExtractor(ValueExtractor<?>)` (to apply it for a single `Validator` instance).# Not more than one extractor for the same type and type parameter may be passed.

[tck-testable]#A value extractor for a given type and type parameter specified at a higher priority overrides any other extractors for the same type and type parameter given at lower priorities.#
If e.g. a value extractor defined as `class MyListValueExtractor implements ValueExtractor<List<@ExtractedValue ?>> { ... }` is given via `ValidatorContext#addValueExtractor(ValueExtractor<?>)`,
it will take precedence over any other value extractor implementing `List<@ExtractedValue ?>` given via `Configuration#addValueExtractor(ValueExtractor<?>)`,
_META-INF/validation.xml_ or the service loader mechanism as well as the built-in extractor for `List` values.

[[constraintdeclarationvalidationprocess-validationroutine-valueextractorresolution-algorithm-constraints]]
===== ValueExtractor resolution algorithm for container element constraints

For a container with the declared type `C` whose element type is hosting a constraint, the following resolution rules apply for identifying the value extractor:

* [tck-testable]#A `ValueExtractor<T>` is said to be _type-compliant_ with `C`, if `C` is a subtype of `T`
(according to the http://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.10[Java Language Specification, Java SE 8 Edition, chapter 4.10, "Subtyping"]).
Note that `C` is a subtype of `T` if `C` = `T`.#
* [tck-testable]#A `ValueExtractor` implementation is said to be _container-element-compliant_ with `C`, if `C` is a generic container type and the value extractor implementation handles a type parameter that maps to the constrained type argument.#
* [tck-testable]#If no `ValueExtractor` type-compliant and container-element-compliant with `C` is found among the available value extractors, a `ConstraintDeclarationException` is raised.#
* [tck-testable]#A `ValueExtractor<U>` type-compliant with `C` is considered _strictly more specific_ than a `ValueExtractor<V>` compliant with `C` if `U` is a strict subtype of `V`.#
`U` is a strict subtype of `V` if `U` is a subtype of `V` and `U` != `V`.
* A `ValueExtractor<U>` type-compliant with `C` is considered maximally specific if no other `ValueExtractor<V>` type-compliant with `C` is strictly more specific than `ValueExtractor<U>`.
* [tck-testable]#If more than one maximally specific and container-element-compliant `ValueExtractor` is found, a `ConstraintDeclarationException` is raised.#

[NOTE]
.Implementation note
====
Extractor retrieval for container element constraints is based on the declared type of constrained elements,
hence it is recommended that implementations perform the resolution once and then cache the value extractor for a given constraint.
====

[[constraintdeclarationvalidationprocess-validationroutine-valueextractorresolution-algorithm-cascaded]]
===== ValueExtractor resolution algorithm for cascaded validation

For a container with the declared type `C` and the runtime type `C'` whose element type is marked for cascaded validation, the following resolution rules apply for identifying the value extractor:

* [tck-testable]#A `ValueExtractor<T>` is said to be _type-compliant_ with `C'`, if `C'` is a subtype of `T`.#
Note that `C'` is a subtype of `T` if `C'` = `T`.
* [tck-testable]#A `ValueExtractor` implementation is said to be _container-element-compliant_ with `C`, if it handles a type parameter that maps to the type argument marked with `@Valid`.#
* [tck-testable]#If no `ValueExtractor` type-compliant with `C'` and container-element-compliant with `C` is found among the available value extractors, a `ConstraintDeclarationException` is raised.#
* [tck-testable]#A `ValueExtractor<U>` type-compliant with `C'` is considered _strictly more specific_ than a `ValueExtractor<V>` compliant with `C'` if `U` is a strict subtype of `V`.#
`U` is a strict subtype of `V` if `U` is a subtype of `V` and `U` != `V`.
* [tck-testable]#A `ValueExtractor<U>` type-compliant with `C'` is considered maximally specific if no other `ValueExtractor<V>` type-compliant with `C'` is strictly more specific than `ValueExtractor<U>`.#
* [tck-testable]#If more than one maximally specific and container-element-compliant `ValueExtractor` is found, a `ConstraintDeclarationException` is raised.#

[NOTE]
.Implementation note
====
Extractor retrieval for cascaded validation is based on the runtime type of the container hosting `@Valid`
(this is to be consistent with the semantics of property paths for cascaded validation),
hence it is not possible to perform the extractor resolution only once per usage of `@Valid` and cache the result.
====

[[constraintdeclarationvalidationprocess-validationroutine-valueextractorresolution-implicitunwrapping]]
===== ValueExtractor resolution algorithm for applying container-level constraints to container elements

When detecting a constraint given as a _declaration annotation_ and not as a _type annotation_ (i.e. it is given on field, parameter etc. and not given on a type argument of a parameterized type), the applicable value extractor, if any, is determined as follows:

* [tck-testable]#If the constraint carries the `Unwrapping.Skip` payload, no value extractor is applied.#
* [tck-testable]#If the constraint carries the `Unwrapping.Unwrap` payload and there is exactly one maximally-specific type-compliant value extractor, this extractor is applied;#
[tck-testable]#if no type-compliant extractor or multiple maximally-specific type-compliant extractors exist, a `ConstraintDeclarationException` is raised.#
* If the constraint carries neither the `Unwrapping.Unwrap` nor the `Unwrapping.Skip` payload:
** [tck-testable]#If there is exactly one maximally-specific type-compliant value extractor and this extractor is marked with `@UnwrapByDefault`, this extractor is applied;#
** [tck-testable]#Otherwise, no value extractor is applied.#

[[constraintdeclarationvalidationprocess-validationroutine-algorithm-examples]]
===== Examples

Let's consider a couple of value extractor definitions and their respective `ValueExtractor` resolution against container element constraint declarations:

.`ValueExtractor` resolution
====
[source, JAVA]
----
public interface ConcurrentList<T> {
    [...]
}

public class MyList<T> implements List<T>, ConcurrentList<T> {
    [...]
}

public interface Table<R, C, V> {
    [...]
}

interface ConfusingMap<K, V> extends Map<V, K> {
    [...]
}

interface SingleTypeMap<T> extends Map<T, T> {
    [...]
}

interface StringMap extends Map<String, String> {
    [...]
}

interface Property<T> {
    [...]
}

class StringProperty implements Property<String> {
    [...]
}

public class IterableValueExtractor implements ValueExtractor<Iterable<@ExtractedValue ?>> {
    [...]
}

public class ListValueExtractor implements ValueExtractor<List<@ExtractedValue ?>> {
    [...]
}

public class ConcurrentListValueExtractor implements ValueExtractor<
        ConcurrentList<@ExtractedValue ?>> {

    [...]
}

public class MapKeyExtractor implements ValueExtractor<Map<@ExtractedValue ?, ?>> {
    [...]
}

public class MapValueExtractor implements ValueExtractor<Map<?, @ExtractedValue ?>> {
    [...]
}

public class TableValueExtractor implements ValueExtractor<Table<?, ?, @ExtractedValue ?>> {
    [...]
}

@UnwrapByDefault
public class PropertyValueExtractor implements ValueExtractor<Property<@ExtractedValue ?>> {
    [...]
}

@UnwrapByDefault
public class OptionalIntValueExtractor implements ValueExtractor<
        @ExtractedValue(type = Integer.class) OptionalInt> {

    [...]
}
----
====

The following value extractor resolutions occur:

[[table-valueextractor-resolution]]

.Resolution of `ValueExtractor` for various container element constraints
[options="header"]
|===============
|Declaration|Resolution
|`List<@Email String> emails`|`ListValueExtractor`; strictly more specific than `IterableValueExtractor`
|`Iterable<@Valid Address> addresses = new ArrayList<>()`|`ListValueExtractor` (the runtime type `ArrayList` is used for resolving value extractors for cascaded validation)
|`Map<@Email String, String> emails`|`MapKeyExtractor`; equally specific as `MapValueExtractor`, but the latter isn't container-element-compliant
|`ConfusingMap<@Email String, String> map`|`MapValueExtractor`; the constrained type argument maps to the type parameter `V` of `Map`
|`@Email StringProperty`|`PropertyValueExtractor`; the extractor is marked with `@UnwrapByDefault`, i.e. implicit unwrapping is performed; `String` will be used for validator resolution as that's the type captured for the type parameter handled by the applied value extractor
|`@Min(1) OptionalInt`|`OptionalIntValueExtractor`; the extractor is marked with `@UnwrapByDefault`, i.e. implicit unwrapping is performed; `Integer` as given via `@ExtractedValue#type()` will be used for validator resolution
|`Optional<@Email String> getEmail() {...}`|`ConstraintDeclarationException`; no compliant extractor exists
|`Table<@Min(1) String, String, String> table`|`ConstraintDeclarationException`; `TableValueExtractor` is type-compliant but not container-element-compliant
|`MyList<@Email String> emails`|`ConstraintDeclarationException`; `ListValueExtractor` and `ConcurrentListValueExtractor` are equally specific
|`SingleTypeMap<@NotEmpty String> map`|`ConstraintDeclarationException`; `MapKeyExtractor` and `MapValueExtractor` are equally specific and both container-element-compliant
|`@NotEmpty(payload=Unwrapping.Unwrap.class) StringMap`|`ConstraintDeclarationException`; more than one maximally-specific extractor is found (`MapKeyExtractor` and `MapValueExtractor`)
|===============

[[constraintdeclarationvalidationprocess-examples]]
=== Examples

The first example demonstrates how beans, fields and getters are annotated to express some constraints.

.Place constraint declarations on the element to validate
====

[source, JAVA]
----
@ZipCodeCityCoherenceChecker
public class Address {
    @NotNull @Size(max=30)
    private String addressline1;

    @Size(max=30)
    private String addressline2;

    private String zipCode;

    private String city;

    public String getAddressline1() {
        return addressline1;
    }

    public void setAddressline1(String addressline1) {
        this.addressline1 = addressline1;
    }

    public String getAddressline2() {
        return addressline2;
    }

    public void setAddressline2(String addressline2) {
        this.addressline2 = addressline2;
    }

    public String getZipCode() {
        return zipCode;
    }

    public void setZipCode(String zipCode) {
        this.zipCode = zipCode;
    }

    @Size(max=30) @NotNull
    public String getCity() {
        return city;
    }

    public void setCity(String city) {
        this.city = city;
    }
}
----

====

During the validation routine execution on an [classname]`Address` object,

* [methodname]`addressline1` field value is passed to the [classname]`@NotNull` as well as [classname]`@Size` constraint validation implementations.
* [methodname]`addressline2` field value is passed to the [classname]`@Size` constraint validation implementation.
* [methodname]`getCity` value is passed to the [classname]`@Size` and [classname]`@NotNull` constraint validation implementations.
* [classname]`@ZipCodeCoherenceChecker` is a constraint whose validation implementation's [methodname]`isValid` method receives the [classname]`Address` object.

The second example demonstrates object graph validation.

.Define object graph validation
====

[source, JAVA]
----
public class Country {
    @NotNull
    private String name;
    @Size(max=2)
    private String ISO2Code;
    @Size(max=3)
    private String ISO3Code;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getISO2Code() {
        return ISO2Code;
    }

    public void setISO2Code(String ISO2Code) {
        this.ISO2Code = ISO2Code;
    }

    public String getISO3Code() {
        return ISO3Code;
    }

    public void setISO3Code(String ISO3Code) {
        this.ISO3Code = ISO3Code;
    }
}

public class Address {
    @NotNull @Size(max=30)
    private String addressline1;
    @Size(max=30)
    private String addressline2;
    @Size(max=11)
    private String zipCode;
    @NotNull @Valid
    private Country country;

    private String city;

    public String getAddressline1() {
        return addressline1;
    }

    public void setAddressline1(String addressline1) {
        this.addressline1 = addressline1;
    }

    public String getAddressline2() {
        return addressline2;
    }

    public void setAddressline2(String addressline2) {
        this.addressline2 = addressline2;
    }

    public String getZipCode() {
        return zipCode;
    }

    public void setZipCode(String zipCode) {
        this.zipCode = zipCode;
    }

    @Size(max=30) @NotNull
    public String getCity() {
        return city;
    }

    public void setCity(String city) {
        this.city = city;
    }

    public Country getCountry() {
        return country;
    }

    public void setCountry(Country country) {
        this.country = country;
    }
}
----

====

During the validation routine execution on an [classname]`Address` object, constraints on [methodname]`addressLine1`, [methodname]`addressLine2`, [methodname]`zipCode`, [classname]`getCity` and [methodname]`country` are processed as well as the validation of the [classname]`Country` object itself, more specifically [methodname]`country.name` is checked for [classname]`@NotNull`, [methodname]`ISO2Code` and [methodname]`ISO3Code` are checked for [classname]`@Size`.

Assuming that [classname]`@NonEmpty` is defined as such:

[source, JAVA, indent=0]
----
include::{spec-examples-source-dir}org/beanvalidation/specexamples/constraintdeclarationvalidation/resolution/NonEmpty.java[tags=include]
----

The third example demonstrates superclass, inheritance and composite constraints.

.Use inheritance, constraints on superclasses and composite constraints
====

[source, JAVA]
----
public interface Person {
    @NonEmpty
    String getFirstName();

    String getMiddleName();

    @NonEmpty
    String getLastName();
}

public class Customer implements Person {
    private String firstName;
    private String middleName;
    private String lastName;
    @NotNull
    private String customerId;
    @Password(robustness=5)
    private String password;

    public String getFirstName() {
        return firstName;
    }

    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }

    public String getMiddleName() {
        return middleName;
    }

    public void setMiddleName(String middleName) {
        this.middleName = middleName;
    }

    public String getLastName() {
        return lastName;
    }

    public void setLastName(String lastName) {
        this.lastName = lastName;
    }

    public String getCustomerId() {
        return customerId;
    }

    public void setCustomerId(String customerId) {
        this.customerId = customerId;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }
}

public class PreferredGuest extends Customer {
    @CreditCard
    private String guestCreditCardNumber;

    public String getGuestCreditCardNumber() {
        return guestCreditCardNumber;
    }

    public void setGuestCreditCardNumber(String guestCreditCardNumber) {
        this.guestCreditCardNumber = guestCreditCardNumber;
    }
}

public class CommonGuest extends customer {}
----

====

When validating a [classname]`PreferredGuest` the following constraints are processed:

* [classname]`@NonEmpty`, [classname]`@NotNull` and [classname]`@Size(min=1)` on [methodname]`firstName`
* [classname]`@NonEmpty`, [classname]`@NotNull` and [classname]`@Size(min=1)` on [methodname]`lastName`
* [classname]`@NotNull` on [methodname]`customerId`, [classname]`@Password` on [methodname]`password`
* [classname]`@CreditCard` on [methodname]`guestCreditCardNumber`


When validating [classname]`CommonGuest`, the following constraints are processed:

* [classname]`@NonEmpty`, [classname]`@NotNull` and [classname]`@Size(min=1)` on [methodname]`firstName`
* [classname]`@NonEmpty`, [classname]`@NotNull` and [classname]`@Size(min=1)` on [methodname]`lastName`
* [classname]`@NotNull` on [methodname]`customerId`, [classname]`@Password` on [methodname]`password`

The fourth example demonstrates the influence of group sequence.

.Use groups and group sequence to define constraint ordering
====

[source, JAVA]
----
@GroupSequence({First.class, Second.class, Last.class})
public interface Complete {}

public class Book {
    @NonEmpty(groups=First.class)
    private String title;

    @Size(max=30, groups=Second.class)
    private String subtitle;

    @Valid
    @NotNull(groups=First.class)
    private Author author;

    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public String getSubtitle() {
        return subtitle;
    }

    public void setSubtitle(String subtitle) {
        this.subtitle = subtitle;
    }

    public Author getAuthor() {
        return author;
    }

    public void setAuthor(Author author) {
        this.author = author;
    }
}

public class Author {
    @NonEmpty(groups=Last.class)
    private String firstName;

    @NonEmpty(groups=First.class)
    private String lastName;

    @Size(max=30, groups=Last.class)
    private String company;

    public String getFirstName() {
        return firstName;
    }

    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }

    public String getLastName() {
        return lastName;
    }

    public void setLastName(String lastName) {
        this.lastName = lastName;
    }

    public String getCompany() {
        return company;
    }

    public void setCompany(String company) {
        this.company = company;
    }
}
----

====

Assuming the validation of the [classname]`Complete` group on the following book instance:

[source, JAVA]
----
Author author = new Author();
author.setLastName( "Baudelaire" );
author.setFirstName( "" );
Book book = new Book();
book.setAuthor( author );
----

the validation routine will return the following failure:

* [classname]`@NotNull` failure (from [classname]`@NonEmpty`) on the `title` field


As both [methodname]`title` and [methodname]`author.lastname` are checked as part of the `First` group. If the instance is updated:

[source, JAVA]
----
book.setTitle( "Les fleurs du mal" );
author.setCompany( "Some random publisher with a very very very long name" );
----

the validation routine will return the following failures:

* [methodname]`author.firstName` fails to pass the [classname]`@Size(min=1)` (from [classname]`@NonEmpty`) constraint
* [methodname]`author.company` fails to pass the [classname]`@Size` constraint


As the [classname]`First` and [classname]`Second` groups pass without failure, the [classname]`Last` group is going through validation.

Java records are supported by {spec-name-bv}. The following examples demonstrate how to use records with {spec-name-bv} constraints.

.Example record constuctor parameter constraint and constructor return value constraint
====

[source, JAVA]
----
@Target({ METHOD, CONSTRUCTOR, ANNOTATION_TYPE })
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = ValidStockItemRecord.Validator.class)
@Documented
public @interface ValidStockItemRecord {
	String message() default "{ValidStockItem.message}";

	Class<?>[] groups() default { };

	Class<? extends Payload>[] payload() default { };

	public class Validator implements ConstraintValidator<ValidStockItemRecord, StockItemRecord> {

		@Override
		public boolean isValid(StockItemRecord object, ConstraintValidatorContext context) {
			return false;
		}
	}
}

public record StockItemRecord(@NotNull String name) {
    @ValidStockItemRecord
    public StockItemRecord {
    }
}
----
Here the constructor parameter constraint is declared on the record components list and the return value constraint is declared on the compact constructor.

====

.Example record cross-parameter constraint with parameter constraints
====

[source, JAVA]
----

@Target({ METHOD, CONSTRUCTOR, ANNOTATION_TYPE })
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = MyCrossParameterConstraintValidator.class)
@Documented
public @interface MyCrossParameterConstraint {
	String message() default "{MyCrossParameterConstraint.message}";

	Class<?>[] groups() default { };

	Class<? extends Payload>[] payload() default { };

	@Target({ METHOD, CONSTRUCTOR, ANNOTATION_TYPE })
	@Retention(RUNTIME)
	@Documented
	@interface List {
		MyCrossParameterConstraint[] value();
	}
}

public record ComplexStockItemRecord(@NotNull String name, @NotNull String description) {
    @MyCrossParameterConstraint
    public ComplexStockItemRecord {
    }
}
----
Here the constructor parameter constraints are declared on the record components list and the cross-parameter constraint is declared on the compact constructor.
====