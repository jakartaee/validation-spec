// Bean Validation
//
// License: Apache License, Version 2.0
// See the license.txt file in the root directory or <http://www.apache.org/licenses/LICENSE-2.0>.

[[constraintmetadata]]

== Constraint metadata request APIs

The Bean Validation specification provides a way to query the constraint repository. This API is expected to be used for tooling support as well as integration with other frameworks, libraries and JSRs. The Bean Validation specification aims to provide both a validation engine and a metadata repository for object constraints. Frameworks (EE or SE) in need for constraint definition, validation and metadata will be able to rely on the Bean Validation specification for these services avoiding any unnecessary duplication work from an application and infrastructure point of view.

[[constraintmetadata-validator]]
=== Validator

The main API to access all metadata related to a given object is [classname]`Validator` (see <<validationapi-bootstrapping>> for more information on how to retrieve a [classname]`Validator` instance).

A [classname]`Validator` instance hosts the method to access to the metadata repository for a given class. It is recommended to leave the caching of [classname]`Validator` instances to the [classname]`ValidatorFactory`. [classname]`Validator` implementations are thread-safe.

.Validator interface (metadata request API)
====

[source, JAVA]
----
/**
 * Validates bean instances. Implementations of this interface must be thread-safe.
 *
 * @author Emmanuel Bernard
 * @author Hardy Ferentschik
 * @author Gunnar Morling
 */
public interface Validator {

    [...] //See 5.1

    /**
     * Returns the descriptor object describing bean constraints.
     * <p/>
     * The returned object (and associated objects including
     * {@link ConstraintDescriptor}s) are immutable.
     *
     * @param clazz class or interface type evaluated
     * @return the bean descriptor for the specified class
     * @throws IllegalArgumentException if clazz is {@code null}
     * @throws ValidationException if a non recoverable error happens
     *         during the metadata discovery or if some
     *         constraints are invalid.
     */
    BeanDescriptor getConstraintsForClass(Class<?> clazz);
}
----

====

[tck-testable]#[methodname]`getConstraintsForClass()` returns a [classname]`BeanDescriptor` object describing the bean level constraints (see <<constraintdeclarationvalidationprocess-requirements-objectvalidation>>) and providing access to the property level constraints metadata.# [tck-testable]#An [classname]`IllegalArgumentException` is raised if the [varname]`clazz` parameter is null.#

[tck-testable]#If a constraint definition or declaration hosted by the requested class (or any of its superclasses and interfaces according to the constraint propagation rules) is invalid, a [classname]`ValidationException` is raised.# This can be a subclass of [classname]`ValidationException` like [classname]`ConstraintDefinitionException`, [classname]`ConstraintDeclarationException` or [classname]`UnexpectedTypeException`.

All descriptor types accessible via [methodname]`getConstraintsForClass()` and introduced in the following sections are located in the package [classname]`javax.validation.metadata`.

[[constraintmetadata-elementdescriptor]]

=== ElementDescriptor

[classname]`ElementDescriptor` is the root interface describing elements hosting constraints. It is used to describe the list of constraints for a given element (whether it be a class, property, method etc.).

.ElementDescriptor interface
====

[source, JAVA, indent=0]
----
include::{validation-api-source-dir}javax/validation/metadata/ElementDescriptor.java[lines=7..8;13..-1]
----

====

[source, JAVA, indent=0]
----
include::{validation-api-source-dir}javax/validation/metadata/Scope.java[lines=7..-1]
----

[tck-testable]
--
[methodname]`getElementClass()` returns

* the object type when invoked on [classname]`BeanDescriptor`,
* the type of a property or parameter when invoked on [classname]`PropertyDescriptor` or [classname]`ParameterDescriptor` respectively,
* `Object[].class` when invoked on [classname]`CrossParameterDescriptor`,
* the return type when invoked on [classname]`ConstructorDescriptor`, [classname]`MethodDescriptor` or [classname]`ReturnValueDescriptor`,
* the container element type when invoked on `ContainerElementTypeDescriptor` (e.g. when invoked on a descriptor representing the container element type of `List<String>`, `String.class` will be returned).
--

[tck-testable]#[classname]`getConstraintDescriptors()` returns all the [classname]``ConstraintDescriptor``s (see <<constraintmetadata-constraintdescriptor>>) hosted on the given element in the class hierarchy, each [classname]`ConstraintDescriptor` describing one of the constraints declared on the given element.#

[tck-testable]#[methodname]`hasConstraints()` returns `true` if the given element in the class hierarchy holds at least one constraint declaration.#

[tck-testable]#If you need to query the metadata API in a more fine grained way for example by restricting the constraints to the ones described on fields or on getters or by restricting to a given set of groups, you can use the [classname]`ConstraintFinder` fluent API by calling [methodname]`findConstraints()`.#

[tck-testable]#[classname]`unorderedAndMatchingGroups()` restricts the results to the [classname]``ConstraintDescriptor``s (see <<constraintmetadata-constraintdescriptor>>) matching the given groups. Order is not respected but group inheritance and inheritance via sequence (including the [classname]`Default` group overriding at the class level) are honored.#

[tck-testable]#[methodname]`declaredOn()` lets you restrict the list of element types constraints are hosted on.# This is particularly useful to retrieve property constraints only hosted on fields ([classname]`ElementType.FIELD`) or only hosted on getters ([classname]`ElementType.METHOD`).

[tck-testable]#[methodname]`lookingAt()` lets you restrict which constraints are considered. Either constraints belonging to the element but hosted on the class represented by the given descriptor ([classname]`Scope.LOCAL_ELEMENT`), or constraints belonging to the element but hosted anywhere in the class hierarchy ([classname]`Scope.HIERARCHY`).#

Here is an example restricting the list of constraints on getters, matching the default group and declared physically on the `name` getter of [classname]`Customer` (and not any of the getters on the super classes).

.Using the fluent API to restrict matching constraints
====

[source, JAVA]
----
public class User {

    @Size(max=50)
    String getName() {
        [...]
    }

    [...]
}

public class Customer extends User {

    @NotNull
    String getName() {
        [...]
    }
}

PropertyDescriptor pd =
    validator.getConstraintsForClass(Customer.class).getConstraintsForProperty("name");
Set<ConstraintDescriptor<?>> constraints =
    pd.findConstraints()
        .declaredOn(ElementType.METHOD)
        .unorderedAndMatchingGroups(Default.class)
        .lookingAt(Scope.LOCAL_ELEMENT)
        .getConstraintDescriptors();

assert 1 == constraints.size();

constraints = pd.getConstraintDescriptors();
//equivalent to pd.findConstraints().getConstraintDescriptors();
assert 2 == constraints.size();
----

====

The following example shows how the fluent API is used to retrieve parameter, cross-parameter and return value constraints, taking into account locally declared constraints as well as constraints declared in the inheritance hierarchy.

.Using the fluent API to select method and constructor constraints
====

[source, JAVA]
----
public class User {

    public User(@Size(max=50) String name) {
        [...]
    }

    @PasswordParametersMatch
    @NotNull
    public String resetPassword(
        @NotNull @Size(min=8) String password,
        @NotNull @Size(min=8) String confirmation) {
        [...]
    }
}

public class Customer extends User {

    public Customer(@NotNull String name) {
        [...]
    }

    @Size(min=8)
    public String resetPassword(String password, String confirmation) {
        [...]
    }
}

MethodDescriptor methodDescriptor = validator
    .getConstraintsForClass( Customer.class )
    .getConstraintsForMethod( "resetPassword", String.class, String.class );

//one cross-parameter constraint
assert 1 == methodDescriptor.getCrossParameterDescriptor().getConstraintDescriptors().size();

//one local return value constraint
assert 1 == methodDescriptor.getReturnValueDescriptor()
    .findConstraints()
    .lookingAt( Scope.LOCAL_ELEMENT )
    .getConstraintDescriptors()
    .size();

//two return value constraints in the complete hierarchy
assert 2 == methodDescriptor.getReturnValueDescriptor()
    .findConstraints()
    .lookingAt( Scope.HIERARCHY )
    .getConstraintDescriptors()
    .size();

//two parameter constraints, defined on overridden method
assert 2 == methodDescriptor.getParameterDescriptors()
    .get( 0 )
    .getConstraintDescriptors()
    .size();

ConstructorDescriptor constructorDescriptor = validator
    .getConstraintsForClass( Customer.class )
    .getConstraintsForConstructor( String.class );

//one parameter constraint; constraints from super constructor don't apply
assert 1 == constructorDescriptor.getParameterDescriptors()
    .get( 0 )
    .findConstraints()
    .lookingAt( Scope.HIERARCHY )
    .getConstraintDescriptors()
    .size();
----

====

[[constraintmetadata-beandescriptor]]
=== BeanDescriptor

The [classname]`BeanDescriptor` interface describes a constrained Java Bean. This interface is returned by [methodname]`Validator.getConstraintsForClass(Class<?>)`.

.BeanDescriptor interface
====

[source, JAVA, indent=0]
----
include::{validation-api-source-dir}javax/validation/metadata/BeanDescriptor.java[lines=7..8;12..-1]
----

====

.MethodType
====

[source, JAVA, indent=0]
----
include::{validation-api-source-dir}javax/validation/metadata/MethodType.java[lines=7..-1]
----

====

[tck-testable]#[methodname]`isBeanConstrained()` returns `true` if the given class (and superclasses and interfaces) has at least one class-level or property-level constraint or validation cascade.# If the method returns false, the Bean Validation engine can safely ignore the bean as it will not be impacted by validation.

[tck-testable]#[methodname]`getConstraintsForProperty()` returns a [classname]`PropertyDescriptor` object describing the property level constraints (See <<constraintdeclarationvalidationprocess-requirements-propertyvalidation>>). The property is uniquely identified by its name as per the JavaBeans convention: field level and getter level constraints of the given name are all returned.# [tck-testable]#An [classname]`IllegalArgumentException` is raised if the [varname]`propertyName` parameter is null.#

[tck-testable]#[methodname]`getConstrainedProperties()` returns the [classname]``PropertyDescriptor``s of the bean properties having at least one constraint or being cascaded ([classname]`@Valid` annotation).#

[tck-testable]#[methodname]`getConstraintsForMethod()` returns a [classname]`MethodDescriptor` object describing the method constraints of the given method. The method is uniquely identified by its name and the types of its parameters.#

[tck-testable]#[methodname]`getConstrainedMethods()` returns the [classname]``MethodDescriptor``s of the methods matching the [classname]``MethodType``s provided as parameter and having at least one constraint or cascaded parameter or return value.#

[tck-testable]#[methodname]`getConstraintsForConstructor()` returns a [classname]`ConstructorDescriptor` object describing the method constraints of the given constructor. The constructor is uniquely identified by its name and the types of its parameters.#

[tck-testable]#[methodname]`getConstrainedConstructors()` returns the [classname]``ConstructorDescriptor``s of the constructors having at least one constraint or cascaded parameter or return value.#

[[constraintmetadata-cascadabledescriptor]]
=== CascadableDescriptor

The [classname]`CascadableDescriptor` interface describes a cascadable element, i.e. an element which can be marked with [classname]`@Valid` in order to perform a cascaded validation of the element as described in <<constraintdeclarationvalidationprocess-requirements-graphvalidation>>.

[source, JAVA, indent=0]
----
include::{validation-api-source-dir}javax/validation/metadata/CascadableDescriptor.java[lines=7..8;11..-1]
----

[tck-testable]#The [methodname]`isCascaded()` method returns `true` if the element is marked for cascaded validation.#

[tck-testable]#The method [methodname]`getGroupConversions()` returns a set with the group conversions declared for the cascadable element. An empty set will be returned if no group conversions are configured.#

[[constraintmetadata-groupconversiondescriptor]]
=== GroupConversionDescriptor

The [classname]`GroupConversionDescriptor` interface describes a group conversion rule configured for a cascadable element as described in <<constraintdeclarationvalidationprocess-groupsequence-groupconversion>>. It is returned by [methodname]`CascadableDescriptor.getGroupConversions()`.

[source, JAVA, indent=0]
----
include::{validation-api-source-dir}javax/validation/metadata/GroupConversionDescriptor.java[lines=7..8;11..-1]
----

[tck-testable]#The [methodname]`getFrom()` method returns the source of a group conversion rule.#

[tck-testable]#The [methodname]`getTo()` method returns the target of a group conversion rule.#

[[constraintmetadata-propertydescriptor]]
=== PropertyDescriptor

The [classname]`PropertyDescriptor` interface describes a constrained property of a Java Bean.

This interface is returned by [methodname]`BeanDescriptor.getConstraintsForProperty(String)` or [methodname]`BeanDescriptor.getConstrainedProperties()`. Constraints declared on the attribute and the getter of the same name according to the JavaBeans rules are returned by this descriptor.

[source, JAVA, indent=0]
----
include::{validation-api-source-dir}javax/validation/metadata/PropertyDescriptor.java[lines=7..-1]
----

[tck-testable]#[methodname]`getPropertyName()` returns the property name as described in <<validationapi-constraintviolation>>.#

[[constraintmetadata-executabledescriptor]]
=== ExecutableDescriptor, MethodDescriptor and ConstructorDescriptor

The [classname]`ExecutableDescriptor` interface describes a constrained method or constructor of a Java type.

[source, JAVA, indent=0]
----
include::{validation-api-source-dir}javax/validation/metadata/ExecutableDescriptor.java[lines=7..8;13..-1]
----

[tck-testable]#[methodname]`getName()` returns the name of the represented method (e.g. "placeOrder") respectively the non-qualified name of the declaring class of the represented constructor (e.g. "OrderService").#

[tck-testable]#[methodname]`getParameterDescriptors()` returns a list of [classname]``ParameterDescriptor``s representing the method's or constructor's parameters in order of their declaration, including synthetic parameters. An empty list will be returned in case the method or constructor has no parameters.#

[tck-testable]#[methodname]`getCrossParameterDescriptor()` returns a descriptor containing cross-parameter constraints of the method or constructor. If no cross-parameter constraint is present, the descriptor will return an empty set of constraint descriptors.#

[tck-testable]#[methodname]`getReturnValueDescriptor()` returns a descriptor for the method's or constructor's return value. A descriptor representing the special class [classname]`void`, without any constraint descriptors, will be returned for executables which have no return value.#

[tck-testable]#[classname]`hasConstrainedParameters()` returns `true` if any of the parameters is constrained or cascaded or if the represented executable has at least one cross-parameter constraint. Returns `false` if there is no parameter.#

[tck-testable]#[classname]`hasConstrainedReturnValue()` returns `true` if the return value is constrained or cascaded. Returns `false` if there is no return value.#

[tck-testable]#The methods [methodname]`hasConstraints()`, [methodname]`getConstraintDescriptors()` and [methodname]`findConstraints()` defined on [classname]`ElementDescriptor` are redefined to clarify that executables do not host constraints directly and thus will always return `false` or an empty set of constraints, respectively. Constraint descriptors for individual parameters can be obtained from the corresponding [classname]`ParameterDescriptor` object, constraint descriptors for cross-parameter constraints can be obtained from the corresponding [classname]`CrossParameterDescriptor` object and constraint descriptors for the return value can be obtained from [classname]`ReturnValueDescriptor`.#

The interfaces [classname]`MethodDescriptor` and [classname]`ConstructorDescriptor` are derived from [classname]`ExecutableDescriptor` and allow to distinguish between descriptors representing methods and descriptors representing constructors.

[source, JAVA, indent=0]
----
include::{validation-api-source-dir}javax/validation/metadata/MethodDescriptor.java[lines=7..-1]
----

[source, JAVA, indent=0]
----
include::{validation-api-source-dir}javax/validation/metadata/ConstructorDescriptor.java[lines=7..-1]
----

[classname]`MethodDescriptor` objects are returned by [methodname]`BeanDescriptor.getConstraintsForMethod(String, Class<?>...)` and [methodname]`BeanDescriptor.getConstrainedMethods(MethodType, MethodType...)`, while [classname]`ConstructorDescriptor` objects are returned by [methodname]`BeanDescriptor.getConstraintsForConstructor(Class<?>...)` and [methodname]`BeanDescriptor.getConstrainedConstructors()`.

[tck-testable]#None of the metadata API methods honor the XML configuration around executable validation nor the presence of [classname]`@ValidateOnExecution`. In other words, all constrained methods and constructors will be returned by the metadata API regardless of these settings.#

[[constraintmetadata-parameterdescriptor]]
=== ParameterDescriptor

The [classname]`ParameterDescriptor` interface describes a constrained parameter of a method or constructor.

This interface is returned by [methodname]`MethodDescriptor.getParameterDescriptors()` and [methodname]`ConstructorDescriptor.getParameterDescriptors()`.

[source, JAVA, indent=0]
----
include::{validation-api-source-dir}javax/validation/metadata/ParameterDescriptor.java[lines=7..-1]
----

[tck-testable]#[methodname]`getIndex()` returns the index of the represented parameter within the parameter array of the method or constructor holding it.#

[tck-testable]#[methodname]`getName()` returns the name of the represented parameter.#

[[constraintmetadata-crossparameterdescriptor]]
=== CrossParameterDescriptor

The [classname]`CrossParameterDescriptor` interface describes an element containing all cross-parameter constraints of a method or constructor.

This interface is returned by [methodname]`MethodDescriptor.getCrossParameterDescriptor()` and [methodname]`ConstructorDescriptor.getCrossParameterDescriptor()`.

[source, JAVA, indent=0]
----
include::{validation-api-source-dir}javax/validation/metadata/CrossParameterDescriptor.java[lines=7..-1]
----

[tck-testable]#[methodname]`getElementClass()` returns [classname]`Object[]`.#

[[constraintmetadata-returnvaluedescriptor]]
=== ReturnValueDescriptor

The [classname]`ReturnValueDescriptor` interface describes the return value of a method or constructor.

This interface is returned by [methodname]`MethodDescriptor.getReturnValueDescriptor()` and [methodname]`ConstructorDescriptor.getReturnValueDescriptor()`.

[source, JAVA, indent=0]
----
include::{validation-api-source-dir}javax/validation/metadata/ReturnValueDescriptor.java[lines=7..-1]
----

[[constraintmetadata-containerdescriptor]]
=== ContainerDescriptor and ContainerElementTypeDescriptor

The `ContainerDescriptor` interface describes those elements that can be of a container type, e.g. `List` or `Map`, and as such may host container element constraints (see <<constraintdeclarationvalidationprocess-containerelementconstraints>>) or have container element types that are marked with `@Valid`.

`ContainerDescriptor` is extended by `PropertyDescriptor`, `ParameterDescriptor`, `ReturnValueDescriptor` and `ContainerElementTypeDescriptor`.

[source, JAVA, indent=0]
----
include::{validation-api-source-dir}javax/validation/metadata/ContainerDescriptor.java[lines=7..8;11..-1]
----

[tck-testable]#If a given element is of a container type, `getConstrainedContainerElementTypes()` returns a set with descriptors representing those container element types that either host at least one constraint or are marked with `@Valid`.#
[tck-testable]#The returned set will be empty if the given element is not of a container type or is of a container type but has no element types that are constrained or marked with `@Valid`.#
In the context of properties and method return values, container element types of super-types are considered.

[tck-testable]#The `ContainerElementTypeDescriptor` interface describes the potential container element constraints applied to one element type of a container.#

This interface is returned by `ContainerDescriptor.getConstrainedContainerElementTypes()`.

[source, JAVA, indent=0]
----
include::{validation-api-source-dir}javax/validation/metadata/ContainerElementTypeDescriptor.java[lines=7..-1]
----

[tck-testable]#`getTypeArgumentIndex()` returns the index of the type argument corresponding to this descriptor instance.#
[tck-testable]#`getContainerClass()` returns the type of the container declaring the container element type represented by this descriptor instance.#

As an example, consider the following type hierarchy:

.Type hierarchy with container element constraints
====
[source, JAVA]
----
public interface LegalEntity {

    Iterable<@NotNull String> getRoles();
}

public interface Person extends LegalEntity {

    @Override
    Set<@NotEmpty String> getRoles();

    Map<@NotNull String, @Valid Account> getAccounts();
}

public interface Employee extends Person {

    @Override
    Set<@NotBlank String> getRoles();

    Map<String, List<@NotNull @Valid Address>> getAddresses();
}

public abstract class Roles implements Set<String> {
    [...]
}

public class EmployeeImpl implements Employee {

    @Override
    public Roles getRoles() {
        [...]
    }

    public Map<String, List<@ValidAddress Address>> getAddresses() {
        [...]
    }

    [...]
}
----
====

Then the assertions in the following example are true:

.Retrieving metadata on container element constraints
====
[source, JAVA]
----
Validator validator = ...;

BeanDescriptor employeeImplDescriptor = validator.getConstraintsForClass( Employee.class );

// container element constraints for property "roles"
PropertyDescriptor rolesDescriptor = employeeImplDescriptor.getConstraintsForProperty( "roles" );
assert rolesDescriptor != null;

Set<ContainerElementTypeDescriptor> constrainedContainerElementTypes = rolesDescriptor.getConstrainedContainerElementTypes();
// the container element types of Set and Iterable; Roles does not declare any container element types itself
assert constrainedContainerElementTypes.size() == 2;

Iterator<ContainerElementTypeDescriptor> it = constrainedContainerElementTypes.iterator();

// assuming that the descriptor for Set is returned first
ContainerElementTypeDescriptor containerElementTypeDescriptor = it.next();
assert containerElementTypeDescriptor.getContainerClass() == Set.class;
assert containerElementTypeDescriptor.getTypeArgumentIndex() == 0;
assert containerElementTypeDescriptor.getElementClass() == String.class;
// @NotEmpty and @NotBlank
assert containerElementTypeDescriptor.getConstraintDescriptors().size() == 2;

// assuming that the descriptor for Iterable is returned next
containerElementTypeDescriptor = it.next();
assert containerElementTypeDescriptor.getContainerClass() == Iterable.class;
assert containerElementTypeDescriptor.getTypeArgumentIndex() == 0;
assert containerElementTypeDescriptor.getElementClass() == String.class;
// @NotNull
assert containerElementTypeDescriptor.getConstraintDescriptors().size() == 1;

// container element constraints for property "accounts"
PropertyDescriptor accountsDescriptor = employeeImplDescriptor.getConstraintsForProperty( "accounts" );
constrainedContainerElementTypes = accountsDescriptor.getConstrainedContainerElementTypes();
// the map key type and the map value type
assert constrainedContainerElementTypes.size() == 2;

it = constrainedContainerElementTypes.iterator();

// assuming that the descriptor for the map key is returned first
containerElementTypeDescriptor = it.next();
assert containerElementTypeDescriptor.getContainerClass() == Map.class;
assert containerElementTypeDescriptor.getTypeArgumentIndex() == 0;
assert containerElementTypeDescriptor.getElementClass() == String.class;
// @NotNull
assert containerElementTypeDescriptor.getConstraintDescriptors().size() == 1;
assert containerElementTypeDescriptor.isCascaded() == false;

// assuming that the descriptor for the map value is returned next
containerElementTypeDescriptor = it.next();
assert containerElementTypeDescriptor.getContainerClass() == Map.class;
assert containerElementTypeDescriptor.getTypeArgumentIndex() == 1;
assert containerElementTypeDescriptor.getElementClass() == Account.class;
assert containerElementTypeDescriptor.getConstraintDescriptors().size() == 0;
assert containerElementTypeDescriptor.isCascaded() == true;

// container element constraints for property "addresses"
PropertyDescriptor addressesDescriptor = employeeImplDescriptor.getConstraintsForProperty( "addresses" );
constrainedContainerElementTypes = accountsDescriptor.getConstrainedContainerElementTypes();
// the map value type
assert constrainedContainerElementTypes.size() == 1;

it = constrainedContainerElementTypes.iterator();

containerElementTypeDescriptor = it.next();
assert containerElementTypeDescriptor.getContainerClass() == Map.class;
assert containerElementTypeDescriptor.getTypeArgumentIndex() == 1;
assert containerElementTypeDescriptor.getElementClass() == List.class;
// No constraints nor @Valid on List itself
assert containerElementTypeDescriptor.getConstraintDescriptors().size() == 0;
assert containerElementTypeDescriptor.isCascaded() == false;

// container element type of the nested List container
constrainedContainerElementTypes = containerElementTypeDescriptor.getConstrainedContainerElementTypes();
assert constrainedContainerElementTypes.size() == 1;
it = constrainedContainerElementTypes.iterator();

containerElementTypeDescriptor = it.next();
assert containerElementTypeDescriptor.getContainerClass() == List.class;
assert containerElementTypeDescriptor.getTypeArgumentIndex() == 0;
assert containerElementTypeDescriptor.getElementClass() == Address.class;
// @NotNull and @ValidAddress
assert containerElementTypeDescriptor.getConstraintDescriptors().size() == 2;
assert containerElementTypeDescriptor.isCascaded() == true;
----
====

[[constraintmetadata-constraintdescriptor]]
=== ConstraintDescriptor

A [classname]`ConstraintDescriptor` object describes a given constraint declaration (i.e. a constraint annotation).

[source, JAVA, indent=0]
----
include::{validation-api-source-dir}javax/validation/metadata/ConstraintDescriptor.java[lines=7..8;20..-1]
----

[tck-testable]#[methodname]`getAnnotation()` returns the annotation instance (or an annotation instance representing the given constraint declaration).# [tck-testable]#If [classname]`ConstraintDescriptor` represents a composing annotation (see <<constraintsdefinitionimplementation-constraintcomposition>>), the returned annotation must reflect parameter overriding.# In other words, the annotation parameter values are the overridden values.

[tck-testable]#[methodname]`getAttributes()` returns a map containing the annotation attribute names as a key, and the annotation attribute values as a value# (this API is anticipated to be simpler to use by tools than reflection over the annotation instance). [tck-testable]#If [classname]`ConstraintDescriptor()` represents a composing annotation (see <<constraintsdefinitionimplementation-constraintcomposition>>), the returned [classname]`Map` must reflect attribute overriding.#

[tck-testable]#[methodname]`getMessageTemplate()` returns the non-interpolated error message.#

[tck-testable]#[methodname]`getGroups()` returns the groups the constraint is supposed to be applied upon.# [tck-testable]#If no group is set on the constraint declaration, the [classname]`Default` group is returned.# [tck-testable]#The groups of a composing constraint are the groups of the composed constraint.#

[tck-testable]#`getPayload()` returns the payloads associated to the constraint or an empty set if none.# [tck-testable]#The payload from the main constraint annotation is inherited by the composing annotations.# [tck-testable]#Any payload definition on a composing annotation is ignored.#

[tck-testable]#[methodname]`getValidationAppliesTo()` returns the [classname]`ConstraintTarget` returned by [methodname]`validationAppliesTo` if the constraint hosts the attribute or `null` otherwise. The constraint target from the main constraint annotation is inherited by the composing annotation. Any constraint target definition on a composing annotation is ignored.#

[tck-testable]#[methodname]`isReportAsSingleViolation()` returns `true` if the constraint is annotated with [classname]`@ReportAsSingleViolation`.#

[tck-testable]#[methodname]`getComposingConstraints()` return a set of composing [classname]``ConstraintDescriptor``s where each descriptor describes a composing constraint.#

[tck-testable]#[methodname]`getConstraintValidatorClasses()` returns the [classname]`ConstraintValidator` classes associated with the constraint.#

[tck-testable]#[methodname]`validateUnwrappedValue()` returns a [classname]`ValidateUnwrappedValue` instance describing the unwrapping behavior.#

[source, JAVA, indent=0]
----
include::{validation-api-source-dir}javax/validation/metadata/ValidateUnwrappedValue.java[lines=7..8;11..-1]
----

[[constraintmetadata-example]]
=== Example

Assuming the following constraint definitions

[source, JAVA, indent=0]
----
package com.acme.constraint;

include::{spec-examples-source-dir}org/beanvalidation/specexamples/constraintmetadata/NotEmpty.java[tags=include]

include::{spec-examples-source-dir}org/beanvalidation/specexamples/constraintmetadata/ValidInterval.java[tags=include]
----

and the following class definitions

[source, JAVA, indent=0]
----
include::{spec-examples-source-dir}org/beanvalidation/specexamples/constraintmetadata/Author.java[tags=include]

include::{spec-examples-source-dir}org/beanvalidation/specexamples/constraintmetadata/Book.java[tags=include]
----

The following assertions are true.

[source, JAVA, indent=0]
----
include::{spec-examples-source-dir}org/beanvalidation/specexamples/constraintmetadata/MetaDataApiTest.java[tags=include]
----
