// Jakarta Bean Validation
//
// License: Apache License, Version 2.0
// See the license.txt file in the root directory or <http://www.apache.org/licenses/LICENSE-2.0>.

[[appendix-persistence]]


[appendix]
== {spec-name-persistence} 2.0 and schema generation

While not specified by this specification or the {spec-name-persistence} 2.0 specification, Persistence Providers are encouraged to make use of {spec-name-bv} constraint metadata when generating DDL schemas. The proposal is as followed.

[source,subs="verbatim,specialchars,specialcharacters,normal"]
----
Ideas explored and not standardized

{spec-name-persistence} consumes {spec-name-bv} metadata to enhance persistence property 
metadata.

A Persistence provider must use the {spec-name-bv} metadata of a given list of groups. 
The default group evaluated is Default (default {spec-name-bv} group). Groups evaluated 
can be overridden by a property. 
This property contains the comma separated groups (fully qualified class name).

For each entity, apply the following algorithm. 
For each persistent property in a given entity: 
 - extract the list of {spec-name-bv} constraints (including the composing constraints) 
 - determine the subset of applicable constraints 
    (i.e. constraints understood by the persistence provider)
 - apply these constraints on the persistent property metadata 
 - if the property type is an embeddable object or a collection 
of embeddable objects, apply the algorithm on the embeddable object properties.

The list of constraints that must be understood by persistence providers are
as followed:
 - @NotNull should be considered equivalent to @Column(nullable=false) / 
     @JoinColumn(nullable=false)
 - @Size.max should be considered equivalent to @Column.length 
     for String properties 
 - @Digits (which contains integer and fraction) should be considered 
     equivalent to @Column.precision = integer+fraction, 
     @Column.scale = fraction for decimal columns

The {spec-name-bv} annotation metadata should have priority over {spec-name-persistence} metadata 
({spec-name-persistence} has no sensible "unset" values on their annotations).

Question: should we add @Unique that would map to @Column(unique=true)? 
@Unique cannot be tested at the Java level reliably but could generate
a database unique constraint generation. @Unique is not part 
of the {spec-name-bv} spec today.

Persistence Provider should optionally recognize and try to apply the 
following constraints as well:
 - @Min / @Max on numeric columns (TODO String too?)
 - @Future / @Past on temporal columns
 - @Size for collections and array (not sure it is feasible).

Persistence Providers can also apply non standard constraints to their metadata model. 
For example, provider ACME might recognize and understand @com.acme.validation.Email 
and apply it to the database model.

While most high level constraints will not be recognized, the {spec-name-bv} built-in constraints 
will be the common language spoken by Persistence Providers. Any high level constraint 
can be composed of more modular constraints (constraint composition).

* additional proposal
In case of a constraint violation report detected and generated by the database 
(not null, etc), the Java persistence provider catches this report and translates 
it into a {spec-name-bv} error report. From the perspective of the application, constraint 
errors are viewed through a unified layer. {spec-name-bv} must provide some API to create a 
constraint violation error (constraintDescriptor.createConstraintViolation(...)).

While this proposal has a lot of value-add, I wonder how difficult it can be to 
implement this in persistence providers.

Provide a way to disable {spec-name-bv} metadata use by a persistence provider (property based).
----

This is not an endorsement of the {spec-name-persistence} expert group or the {spec-name-bv} expert group. Such approach may or may not be standardized in the future. Such integration should not be considered portable.

