// Bean Validation
//
// License: Apache License, Version 2.0
// See the license.txt file in the root directory or <http://www.apache.org/licenses/LICENSE-2.0>.

[[constraintsdefinitionimplementation]]

== Constraint Definition

Constraints are defined by the combination of a constraint annotation and a list of constraint validation implementations. The constraint annotation is applied on types, fields, methods, constructors, parameters or other constraint annotations in case of composition.

Unless stated otherwise the default package name for the Bean Validation APIs is [classname]`javax.validation`.

[[constraintsdefinitionimplementation-constraintdefinition]]

=== Constraint annotation

A constraint on a JavaBean is expressed through one or more annotations. [tck-not-testable]#An annotation is considered a constraint definition if its retention policy contains `RUNTIME` and if the annotation itself is annotated with `javax.validation.Constraint`# .

[source, JAVA]
----
/**
 * Marks an annotation as being a Bean Validation constraint.
 * <p/>
 * A given constraint annotation must be annotated by a {@code @Constraint}
 * annotation which refers to its list of constraint validation implementations.
 * <p/>
 * Each constraint annotation must host the following attributes:
 * <ul>
 *     <li>{@code String message() default [...];} which should default to an error
 *     message key made of the fully-qualified class name of the constraint followed by
 *     {@code .message}. For example {@code "{com.acme.constraints.NotSafe.message}"}</li>
 *     <li>{@code Class<?>[] groups() default {};} for user to customize the targeted
 *     groups</li>
 *     <li>{@code Class<? extends Payload>[] payload() default {};} for
 *     extensibility purposes</li>
 * </ul>
 * <p/>
 * When building a constraint that is both generic and cross-parameter, the constraint
 * annotation must host the {@code validationAppliesTo()} property.
 * A constraint is generic if it targets the annotated element and is cross-parameter if
 * it targets the array of parameters of a method or constructor.
 * <pre>
 *     ConstraintTarget validationAppliesTo() default ConstraintTarget.IMPLICIT;
 * </pre>
 * This property allows the constraint user to choose whether the constraint
 * targets the return type of the executable or its array of parameters.
 *
 * A constraint is both generic and cross-parameter if
 * <ul>
 *     <li>two kinds of {@code ConstraintValidator}s are attached to the
 *     constraint, one targeting {@link ValidationTarget#ANNOTATED_ELEMENT}
 *     and one targeting {@link ValidationTarget#PARAMETERS},</li>
 *     <li>or if a {@code ConstraintValidator} targets both
 *     {@code ANNOTATED_ELEMENT} and {@code PARAMETERS}.</li>
 * </ul>
 *
 * Such dual constraints are rare. See {@link SupportedValidationTarget} for more info.
 * <p/>
 * Here is an example of constraint definition:
 * <pre>
 * &#64;Documented
 * &#64;Constraint(validatedBy = OrderNumberValidator.class)
 * &#64;Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
 * &#64;Retention(RUNTIME)
 * public &#64;interface OrderNumber {
 *     String message() default "{com.acme.constraint.OrderNumber.message}";
 *     Class<?>[] groups() default {};
 *     Class<? extends Payload>[] payload() default {};
 * }
 * </pre>
 *
 * @author Emmanuel Bernard
 * @author Gavin King
 * @author Hardy Ferentschik
 */
@Documented
@Target({ ANNOTATION_TYPE })
@Retention(RUNTIME)
public @interface Constraint {

    /**
     * {@link ConstraintValidator} classes must reference distinct target types
     * for a given {@link ValidationTarget}
     * If two {@code ConstraintValidator}s refer to the same type,
     * an exception will occur.
     * <p/>
     * At most one {@code ConstraintValidator} targeting the array of parameters of
     * methods or constructors (aka cross-parameter) is accepted. If two or more
     * are present, an exception will occur.
     *
     * @return array of (@code ConstraintValidator} classes implementing the constraint
     */
    Class<? extends ConstraintValidator<?, ?>>[] validatedBy();
}
----

A constraint is said to be generic if it has at least one constraint validator targeting the element annotated i.e. targeting the (returned) element annotated by the constraint (a bean, a field, a getter, a method/constructor return value or a method/constructor parameter). A constraint is said to be cross-parameter if it has one constraint validator targeting the array of parameters of a method or constructor (to validate the consistency of several method/constructor parameters). A Bean Validation constraint is most of the time either a generic constraint or a cross-parameter constraint. In rare situations, a constraint can be both.

[tck-not-testable]
--
Generic constraint annotations can target any of the following [classname]``ElementType``s:

* `FIELD` for constrained attributes
* `METHOD` for constrained getters and constrained method return values
* [classname]`CONSTRUCTOR` for constrained constructor return values
* [classname]`PARAMETER` for constrained method and constructor parameters
* `TYPE` for constrained beans
* `ANNOTATION_TYPE` for constraints composing other constraints
--

[tck-not-testable]
--
Cross-parameter constraint annotations can target any of the following [classname]``ElementType``s:

* `METHOD`
* `CONSTRUCTOR`
* `ANNOTATION_TYPE` for cross-parameter constraints composing other cross-parameter constraints
--

[tck-not-testable]#A constraint annotation that is both can target the union of the generic and cross-parameter constraint annotations targets.#

While other [classname]``ElementType``s are not forbidden, the provider does not have to recognize and process constraints placed on such types.

Since a given constraint definition applies to one or more specific Java types, the JavaDoc for the constraint annotation should clearly state which types are supported. [tck-testable]#Applying a constraint annotation to an incompatible type will raise an [classname]`UnexpectedTypeException`.# Care should be taken on defining the list of [classname]``ConstraintValidator``s. The type resolution algorithm (see <<typevalidatorresolution>>) could lead to exceptions if the [classname]`ConstraintValidator` list leads to ambiguities.

[tck-testable]#At most one [classname]`ConstraintValidator` supporting cross-parameter validation must be present for a given constraint. A [classname]`ConstraintDefinitionException` is raised otherwise.# The JavaDoc should clearly state if the constraint is a generic and / or a cross-parameter constraint.

[tck-testable]#If a constraint definition is not valid, a [classname]`ConstraintDefinitionException` is raised either at validation time or when the metadata is requested.# Invalid constraint definitions causes are multiple but include missing or illegal [methodname]`message` or [methodname]`groups` elements (see <<constraintsdefinitionimplementation-constraintdefinition-properties>>).

[NOTE]
====
Bean Validation defines rules for applying constraint annotations in inheritance hierarchies, described in <<constraintdeclarationvalidationprocess-inheritance>> and <<constraintdeclarationvalidationprocess-methodlevelconstraints-inheritance>>. It is therefore not recommended to specify the meta annotation [classname]`java.lang.annotation.Inherited` at constraint annotation types, as it is not relevant in the context of Bean Validation and would conflict with the proposed rules.
====

[[constraintsdefinitionimplementation-constraintdefinition-properties]]

==== Constraint definition properties

[tck-testable]#A constraint definition may have attributes that are specified at the time the constraint is applied to a JavaBean.# The properties are mapped as annotation elements. The annotation element names `message`, `groups`, `validationAppliesTo` and `payload` are considered reserved names; [tck-testable]#annotation elements starting with `valid` are not allowed# ; a constraint may use any other element name for its attributes.

[[constraintsdefinitionimplementation-constraintdefinition-parameters-message]]

===== message

[tck-testable]#Every constraint annotation must define a `message` element of type `String`.#

[source, JAVA]
----
String message() default "{com.acme.constraint.MyConstraint.message}";
----

The [methodname]`message` element value is used to create the error message. See <<validationapi-message>> for a detailed explanation. It is recommended to default `message` values to resource bundle keys to enable internationalization. It is also recommended to use the following convention: the resource bundle key should be the fully qualified class name of the constraint annotation concatenated to `.message` as shown in the previous program listing.

Built-in Bean Validation constraints follow this convention.

[[constraintsdefinitionimplementation-constraintdefinition-groups]]

===== groups

[tck-testable]#Every constraint annotation must define a `groups` element that specifies the processing groups with which the constraint declaration is associated.# [tck-testable]#The type of the `groups` parameter is [classname]`Class<?>[]`.#

[source, JAVA]
----
Class<?>[] groups() default {};
----

[tck-testable]#The default value must be an empty array.#

[tck-testable]#If no group is specified when declaring the constraint on an element, the `Default` group is considered declared.#

See <<validationapi-validatorapi-groups>> for more information.

Groups are typically used to control the order in which constraints are evaluated, or to perform validation of the partial state of a JavaBean.

[[constraintsdefinitionimplementation-constraintdefinition-payload]]

===== payload

[tck-testable]#Constraint annotations must define a `payload` element that specifies the payload with which the constraint declaration is associated. The type of the `payload` parameter is [classname]`Payload[]`.#

[source, JAVA]
----
Class<? extends Payload>[] payload() default {};
----

[tck-testable]#The default value must be an empty array.#

[tck-testable]#Each attachable payload extends [classname]`Payload`.#

[source, JAVA]
----
/**
 * Payload type that can be attached to a given
 * constraint declaration.
 * <p/>
 * Payloads are typically used to carry on metadata information
 * consumed by a validation client.
 * </p>
 * Use of payloads is not considered portable.
 *
 * @author Emmanuel Bernard
 * @author Gerhard Petracek
 */
public interface Payload {
}
----

Payloads are typically used by validation clients to associate some metadata information with a given constraint declaration. Payloads are typically non-portable. Describing payloads as interface extensions as opposed to a string-based approach allows an easier and more type-safe approach.

One use case for payload shown in <<example-payload>> is to associate a severity to a constraint. This severity can be exploited by a presentation framework to adjust how a constraint failure is displayed.

[[example-payload]]

.Use of payload to associate severity to a constraint
====

[source, JAVA]
----
package com.acme.severity;

public class Severity {
    public static class Info implements Payload {};
    public static class Error implements Payload {};
}

public class Address {
    @NotNull(message="would be nice if we had one", payload=Severity.Info.class)
    public String getZipCode() { [...] }

    @NotNull(message="the city is mandatory", payload=Severity.Error.class)
    String getCity() { [...] }
}
----

====

The `payload` information can be retrieved from error reports via the [classname]`ConstraintDescriptor` either accessed through the [classname]`ConstraintViolation` objects (see <<validationapi-constraintviolation>>) or through the metadata API (see <<constraintmetadata-constraintdescriptor>>).

[[constraintsdefinitionimplementation-constraintdefinition-validationappliesto]]

===== validationAppliesTo

`validationAppliesTo` is used at constraint declaration time to clarify what the constraint targets (i.e. the annotated element, the method return value or the method parameters).

[tck-testable]#The element `validationAppliesTo` must only be present for constraints that are both generic and cross-parameter, it is mandatory in this situation. A [classname]`ConstraintDefinitionException` is raised if these rules are violated.#

[tck-testable]#The type of the `validationAppliesTo` parameter is [classname]`ConstraintTarget`. The default value must be [classname]`ConstraintTarget.IMPLICIT`.#

.validationAppliesTo and ConstraintTarget
====

[source, JAVA]
----
ConstraintTarget validationAppliesTo() default ConstraintTarget.IMPLICIT;
----

[source, JAVA]
----
/**
 * Defines the constraint target.
 *
 * @author Emmanuel Bernard
 * @since 1.1
 */
public enum ConstraintTarget {

    /**
     * Discover the type when no ambiguity is present
     * <ul>
     *     <li>if neither on a method nor a constructor, it implies the annotated element
     *     (type, field etc),</li>
     *     <li>if on a method or constructor with no parameter, it implies
     *     {@code RETURN_VALUE},</li>
     *     <li>if on a method with no return value ({@code void}), it implies
     *     {@code PARAMETERS}.</li>
     * </ul>
     * Otherwise, {@code IMPLICIT} is not accepted and either {@code RETURN_VALUE} or
     * {@code PARAMETERS} is required. This is the case for constructors with parameters
     * and methods with parameters and return value.
     */
    IMPLICIT,

    /**
     * Constraint applies to the return value of a method or a constructor.
     */
    RETURN_VALUE,

    /**
     * Constraint applies to the parameters of a method or a constructor
     */
    PARAMETERS
}
----

====

[tck-testable]#If a [classname]`ConstraintTarget` is used in an illegal situation, a [classname]`ConstraintDeclarationException` is raised either at validation time or when the metadata is requested.# Examples of illegal situations are:

* [tck-testable]#using `IMPLICIT` in a situation that cannot be inferred (see the JavaDoc for the detailed rules),#
* [tck-testable]#using `PARAMETERS` on a constructor or method that has no parameter,#
* [tck-testable]#using `RETURN_VALUE` on a method with no return value,#
* [tck-testable]#using `PARAMETERS` or `RETURN_VALUE` on a type - class or interface - or on a field.#


Constraint users are encouraged to explicitly set the [classname]`ConstraintTarget` target when using a constraint supporting both on a method or constructor as it improves readability.

===== Constraint specific parameter

The constraint annotation definitions may define additional elements to parameterize the constraint. For example, a constraint that validates the length of a string can use an annotation element named `length` to specify the maximum length at the time the constraint is declared.

==== Examples

[[example-definition-notnull]]

.Simple constraint definition
====

[source, JAVA]
----
//assuming OrderNumberValidator is a generic constraint validator

package com.acme.constraint;

/**
 * Mark a String as representing a well formed order number
 */
@Documented
@Constraint(validatedBy = OrderNumberValidator.class)
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
public @interface OrderNumber {
    String message() default "{com.acme.constraint.OrderNumber.message}";
    Class<?>[] groups() default {};
    Class<? extends Payload>[] payload() default {};
}
----

====

<<example-definition-notnull>> marks a [classname]`String` as a well-formed order number. The constraint validator is implemented by [classname]`OrderNumberValidator`.

[[example-definition-crossparameter]]

.Simple cross-parameter constraint definition
====

[source, JAVA]
----
//assuming DateParametersConsistentValidator is a cross-parameter
//constraint validator

package com.acme.constraint;

/**
 * Cross-parameter constraint ensuring that two date parameters
 * of a method are in the correct order.
 */
@Documented
@Constraint(validatedBy = DateParametersConsistentValidator.class)
@Target({ METHOD, CONSTRUCTOR, ANNOTATION_TYPE })
@Retention(RUNTIME)
public @interface DateParametersConsistent {
    String message() default "{com.acme.constraint.DateParametersConsistent.message}";
    Class<?>[] groups() default {};
    Class<? extends Payload>[] payload() default {};
}
----

====

<<example-definition-crossparameter>> shows a cross-parameter constraint which ensures that two date parameters of a method are in the correct order. The constraint validator is implemented by [classname]`DateParametersConsistentValidator`.

[[example-definition-genericandcrossparameter]]

.Constraint that is both generic and cross parameter
====

[source, JAVA]
----
//assuming ELAssertValidator is both a generic and cross-parameter
//constraint validator

package com.acme.constraint;

/**
 * EL expression to be validated.
 * This constraint accepts any type and can validate both the
 * annotated type or apply restrictions across parameters.
 */
@Documented
@Constraint(validatedBy=ELAssertValidator.class)
@Target({ METHOD, FIELD, TYPE, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
public @interface ELAssert {
    String message() default "{com.acme.constraint.DateParametersConsistent.message}";
    Class<?>[] groups() default {};
    Class<? extends Payload>[] payload() default {};
    ConstraintTarget validationAppliesTo() default ConstraintTarget.IMPLICIT;

    String expression();
}
----

[source, JAVA]
----
@ELAssert(
    message="Please check that your passwords match and try again.",
    expression="param[1]==param[2]",
    validationAppliesTo=ConstraintType.PARAMETERS
)
public User createUser(String email, String password, String repeatPassword) { [...] }
----

====

<<example-definition-genericandcrossparameter>> shows a constraint that can be applied both on the annotated element and across parameters of a method or a constructor. Note in this case the presence of [methodname]`validationAppliesTo`.

[[example-definition-length]]

.Constraint definition with default parameter
====

[source, JAVA]
----
package com.acme.constraint;

/**
 * A frequency in Hz as audible to human ear.
 * Adjustable to the age of the person.
 * Accept Numbers.
 */
@Documented
@Constraint(validatedBy = AudibleValidator.class)
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
public @interface Audible {
    Age age() default Age.YOUNG;
    String message() default "{com.acme.constraint.Audible.message}";
    Class<?>[] groups() default {};
    Class<? extends Payload>[] payload() default {};

    public enum Age {
        YOUNG,
        WONDERING
        OLD
    }
}
----

====

<<example-definition-length>> ensures that a given frequency is within the scope of human ears. The constraint definition includes an optional parameter that may be specified when the constraint is applied.

[[example-definition-mandatory]]

.Constraint definition with mandatory parameter
====

[source, JAVA]
----
package com.acme.constraint;

/**
 * Defines the list of values accepted
 * Accepts int or Integer objects
 */
@Documented
@Constraint(validatedBy = DiscreteListOfIntegerValidator.class)
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
public @interface Acceptable {
    int[] value();
    String message() default "{com.acme.constraint.Acceptable.message}";
    Class<?>[] groups() default {};
    Class<? extends Payload>[] payload() default {};
}
----

====

<<example-definition-mandatory>> defines a list of acceptable values expressed as an array: the [methodname]`value` property must be specified when the constraint is applied.

[[constraintsdefinitionimplementation-multipleconstraints]]

=== Applying multiple constraints of the same type

It is often useful to declare the same constraint more than once to the same target, with different properties. A common example is the `@Pattern` constraint, which validates that its target matches a specified regular expression. Other constraints have this requirement as well. The same constraint type can belong to different groups and have specific error messages depending on the targeted group.

To support this requirement, [tck-testable]#the Bean Validation provider treats regular annotations (annotations not annotated by [classname]`@Constraint`) whose `value` element has a return type of an array of constraint annotations in a special way. Each element in the `value` array are processed by the Bean Validation implementation as regular constraint annotations.# This means that each constraint specified in the `value` element is applied to the target. The annotation must have retention `RUNTIME` and can be applied on a type, field, property, executable parameter, executable return value, executable cross-parameter or another annotation. It is recommended to use the same set of targets as the initial constraint.

Note to constraint designers: each constraint annotation should be coupled with its corresponding multi-valued annotation. The specification recommends, though does not mandate, the definition of an inner annotation named [classname]`List`.

.Multi-valued constraint definition
====

[source, JAVA]
----
/**
 * Validate a zipcode for a given country
 * The only supported type is String
 */
@Documented
@Constraint(validatedBy = ZipCodeValidator.class)
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
public @interface ZipCode {

    String countryCode();

    String message() default "{com.acme.constraint.ZipCode.message}";

    Class<?>[] groups() default {};

    Class<? extends Payload>[] payload() default {};

    /**
     * Defines several @ZipCode annotations on the same element
     * @see (@link ZipCode}
     */
    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
    @Retention(RUNTIME)
    @Documented
    @interface List {
        ZipCode[] value();
    }
}
----

====

.Multi-valued constraint declaration
====

[source, JAVA]
----
public class Address {
    @ZipCode.List( {
            @ZipCode(countryCode="fr", groups=Default.class
                     message = "zip code is not valid"),
            @ZipCode(countryCode="fr", groups=SuperUser.class
                     message = "zip code invalid. Requires overriding before saving.")
            } )
    private String zipcode;
}
----

====

In this example, both constraints apply to the [methodname]`zipcode` field but with different groups and with different error messages.

Using two different multi-constraint annotations for the same underlying constraint type on the same target (i.e. class or property) is not considered portable and is discouraged.

[[constraintsdefinitionimplementation-constraintcomposition]]

=== Constraint composition

This specification allows you to compose constraints to create higher level constraints.

Constraint composition is useful in several ways:

* Avoid duplication and facilitate reuse of more primitive constraints.
* Expose primitive constraints as part of a composed constraint in the metadata API and enhance tool awareness.


Composition is done by annotating a constraint annotation with the composing constraint annotations.

.Composition is done by annotating the composed constraint
====

[source, JAVA]
----
@Pattern(regexp="[0-9]*")
@Size(min=5, max=5)
@Constraint(validatedBy = FrenchZipcodeValidator.class)
@Documented
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
public @interface FrenchZipcode {
    String message() default "Wrong zipcode";
    Class<?>[] groups() default {};
    Class<? extends Payload>[] payload() default {};

    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
    @Retention(RUNTIME)
    @Documented
    @interface List {
        FrenchZipcode[] value();
    }
}
----

====

Annotating an element with [classname]`@FrenchZipcode` (the composed annotation) is equivalent to annotating it with [classname]`@Pattern(regexp="[0-9]*")`, [classname]`@Size(min=5, max=5)` (the composing annotations) and [classname]`@FrenchZipcode`. [tck-testable]#More formally, each constraint annotation hosted on a constraint annotation is applied to the target element and this is done recursively.# [tck-testable]#Note that the main annotation and its constraint validation implementation is also applied.# [tck-testable]#By default, each failing constraint generates an error report.# [tck-testable]#Groups from the main constraint annotation are inherited by the composing annotations.# [tck-testable]#Any [methodname]`groups` definition on a composing annotation is ignored.# [tck-testable]#Payload from the main constraint annotation is inherited by the composing annotations.# [tck-testable]#Any [methodname]`payload` definition on a composing annotation is ignored.# [tck-testable]#The constraint target from the main constraint annotation is inherited by the composing annotations.# [tck-testable]#Any [methodname]`validationAppliesTo` definition on a composing annotation is ignored.#

[tck-testable]#The type upon which composed constraint is placed must be compatible with all constraints (composing and composed).# A constraint designer should ensure that such a type exists and lists in the JavaDoc all the compatible types.

[tck-testable]#All composed and composing constraints must have a constraint type in common.# In particular, it is not legal to mix a pure generic constraint and a pure cross-parameter constraint.

It is possible to ensure that composing annotations do not raise individual error reports. In this scenario, if one or more composing annotations are invalid, the main constraint is automatically considered invalid and the corresponding error report is generated. To mark a constraint as raising a single constraint error report if either the composed or one of the composing constraints fail, use the [classname]`@ReportAsSingleViolation` annotation.

.If any of the composing constraints fail, the error report corresponding to @FrenchZipcode is raised and none other.
====

[source, JAVA]
----
@Pattern(regexp="[0-9]*")
@Size(min=5, max=5)
@ReportAsSingleViolation
@Constraint(validatedBy = FrenchZipcodeValidator.class)
@Documented
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
public @interface FrenchZipcode {
    String message() default "Wrong zipcode";
    Class<?>[] groups() default {};
    Class<? extends Payload>[] payload() default {};

    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
    @Retention(RUNTIME)
    @Documented
    @interface List {
        FrenchZipcode[] value();
    }
}
----

====

The definition of [classname]`@ReportAsSingleViolation` is as follows.

[source, JAVA]
----
/**
 * A constraint annotation hosting this annotation will return the
 * composed annotation error report if any of the composing annotations fail.
 * The error reports of each individual composing constraint are ignored.
 * <p/>
 * Note: Evaluation of composed constraints stops on the first validation
 * error in case the composing constraint is annotated with
 * {@code @ReportAsSingleViolation}.
 *
 * @author Emmanuel Bernard
 */
@Target({ ANNOTATION_TYPE })
@Retention(RUNTIME)
public @interface ReportAsSingleViolation {
}
----

[tck-testable]#More specifically, if a composed constraint is marked as [classname]`@ReportAsSingleViolation`, the evaluation of the composing constraints stops at the first failing constraint and the error report corresponding to the composed constraint is generated and returned.#

[tck-testable]#Composing annotations can define the value of `message` and custom attributes (excluding [methodname]`groups`, [methodname]`payload` and [methodname]`validationAppliesTo`) but these are fixed in the composed constraint definition.#

.Composing annotations can use attributes. They are fixed for a given main annotation. All @FrenchZipcode constraints have a @Size restricted to 5.
====

[source, JAVA]
----
@Pattern(regexp="[0-9]*")
@Size(min=5, max=5)
@Constraint(validatedBy = FrenchZipcodeValidator.class)
@Documented
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
public @interface FrenchZipcode {
    String message() default "Wrong zipcode";
    Class<?>[] groups() default {};
    Class<? extends Payload>[] payload() default {};

    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
    @Retention(RUNTIME)
    @Documented
    @interface List {
        FrenchZipcode[] value();
    }
}
----

====

[tck-testable]#It is possible to override attributes and messages defined on a composing annotation. An attribute from the main annotation is used to override one or more attributes of the composing annotations. Such an attribute is annotated with the [classname]`@OverridesAttribute` annotation or its multivalued equivalent [classname]`@OverridesAttribute.List`.#

[[example-composing-overridden]]

.Attributes from composing annotations can be overridden by attributes from the composed annotation
====

[source, JAVA]
----
@Pattern(regexp="[0-9]*")
@Size
@Constraint(validatedBy = FrenchZipcodeValidator.class)
@Documented
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
public @interface FrenchZipcode {
    String message() default "Wrong zipcode";
    Class<?>[] groups() default {};
    Class<? extends Payload>[] payload() default {};

    @OverridesAttribute.List( {
        @OverridesAttribute(constraint=Size.class, name="min"),
        @OverridesAttribute(constraint=Size.class, name="max") } )
    int size() default 5;

    @OverridesAttribute(constraint=Size.class, name="message")
    String sizeMessage() default "{com.acme.constraint.FrenchZipcode.zipcode.size}";

    @OverridesAttribute(constraint=Pattern.class, name="message")
    String numberMessage() default "{com.acme.constraint.FrenchZipcode.number.size}";

    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
    @Retention(RUNTIME)
    @Documented
    @interface List {
        FrenchZipcode[] value();
    }
}
----

====

The value of the composed constraint attribute annotated with [classname]`@OverridesAttribute` ([methodname]`@FrenchZipcode.sizeMessage`) is applied to the composing constraint attribute named after [methodname]`@OverridesAttribute.name` and hosted on the composing constraint of type [methodname]`@OverridesAttribute.constraint` ([methodname]`@Size.message`). Similarly, [classname]`@FrenchZipcode.numberMessage` value is mapped to [classname]`@Pattern.message`.

If left undefined, the default value for [methodname]`@OverridesAttribute.name` is the name of the composed constraint attribute hosting the [classname]`@OverridesAttribute` annotation.

[tck-testable]#The types of the overridden and overriding attributes must be identical.#

[NOTE]
====
[tck-testable]#A composing constraint can itself be a composed constraint. In this case, attribute values are overridden recursively according to the described rules.# Note however, that a forwarding rule (as defined by [classname]`@OverridesAttribute`) is only applied to the direct composing constraints.
====

Using <<example-composing-overridden>>,

[source, JAVA]
----
@FrenchZipcode(size=9, sizeMessage="Zipcode should be of size {max}")
----

is equivalent to

[source, JAVA]
----
@FrenchZipcode
----

if [classname]`@FrenchZipcode` is defined as

[source, JAVA]
----
@Pattern(regexp="[0-9]*")
@Size(min=9, max=9, message="Zipcode should be of size {max}")
@Constraint(validatedBy = FrenchZipcodeValidator.class)
@Documented
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
public @interface FrenchZipcode {
    String message() default "Wrong zipcode";
    Class<?>[] groups() default {};
    Class<? extends Payload>[] payload() default {};

    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
    @Retention(RUNTIME)
    @Documented
    @interface List {
        FrenchZipcode[] value();
    }
}
----

[tck-testable]#If a constraint is used more than once as a composing constraint, the multi value constraints model as described in <<constraintsdefinitionimplementation-multipleconstraints>> is used.# [tck-testable]#To select a specific composing constraint, [methodname]`OverridesAttribute.constraintIndex` is used. It represents the constraint index in the [methodname]`value` array.# [tck-testable]#If `index` is undefined, the single constraint declaration is targeted.#

.Use of constraintIndex in @OverridesAttribute
====

[source, JAVA]
----
@Pattern.List( {
    @Pattern(regexp="[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,4}"), //email
    @Pattern(regexp=".*?emmanuel.*?") //emmanuel
} )
@Constraint(validatedBy={})
@Documented
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
public @interface EmmanuelsEmail {
    String message() default "Not emmanuel's email";

    @OverridesAttribute(constraint=Pattern.class, name="message", constraintIndex=0)
    String emailMessage() default "Not an email";

    @OverridesAttribute(constraint=Pattern.class, name="message", constraintIndex=1)
    String emmanuelMessage() default "Not Emmanuel";

    Class<?>[] groups() default {};
    Class<? extends Payload>[] payload() default {};

    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
    @Retention(RUNTIME)
    @Documented
    @interface List {
        EmmanuelsEmail[] value();
    }
}
----

====

[classname]`@OverridesAttribute` definition is as follows:

[source, JAVA]
----
/**
 * Marks an attribute as overriding the attribute of a composing constraint.
 * Both attributes must share the same type.
 *
 * @author Emmanuel Bernard
 */
@Retention(RUNTIME)
@Target({ METHOD })
public @interface OverridesAttribute {

    /**
     * @return constraint type the attribute is overriding
     */
    Class<? extends Annotation> constraint();

    /**
     * Name of the Constraint attribute overridden.
     * Defaults to the name of the attribute hosting {@code @OverridesAttribute}.
     *
     * @return name of constraint attribute overridden
     */
    String name();

    /**
     * The index of the targeted constraint declaration when using
     * multiple constraints of the same type.
     * <p/>
     * The index represents the index of the constraint in the
     * {@code value()} array.
     * <p/>
     * By default, no index is defined and the single constraint declaration
     * is targeted.
     *
     * @return constraint declaration index if multivalued annotation is used
     */
    int constraintIndex() default -1;

    /**
     * Defines several {@link OverridesAttribute} annotations on the same element
     *
     * @see javax.validation.OverridesAttribute
     */
    @Documented
    @Target({ METHOD })
    @Retention(RUNTIME)
    public @interface List {

        OverridesAttribute[] value();
    }
}
----

The following elements uniquely identify an overridden constraint attribute:

* [methodname]`@OverridesAttribute.constraint`
* [methodname]`@OverridesAttribute.name`
* [methodname]`@OverridesAttribute.constraintIndex`


[tck-testable]
--
If the composition is invalid, e.g.

* infinitely recursive composition
* wrong attribute overriding
* a single attribute mapped to more than one source attribute
* a composing and composed constraint marked as different constraint types (i.e., generic and cross-parameter)
* etc.

a [classname]`ConstraintDefinitionException` is raised either at validation time or when the metadata is requested.
--

Constraint designers are encouraged to make use of composition (recursively or not) based on the built-in constraints defined by the specification. The composing constraints are exposed through the Bean Validation metadata API (<<constraintmetadata-constraintdescriptor>>). This metadata is particularly useful for third-party metadata consumers like persistence frameworks generating database schemas (such as Java Persistence) or presentation frameworks.

[[constraintsdefinitionimplementation-validationimplementation]]

=== Constraint validation implementation

[tck-testable]#A constraint validation implementation performs the validation of a given constraint annotation for a given type.# [tck-testable]#The implementation classes are specified by the `validatedBy` element of the [classname]`@Constraint` annotation that decorates the constraint definition.# [tck-not-testable]#The constraint validation implementation implements the [classname]`ConstraintValidator` interface.#

[source, JAVA]
----
/**
 * Defines the logic to validate a given constraint {@code A}
 * for a given object type {@code T}.
 * <p/>
 * Implementations must comply to the following restriction:
 * <ul>
 *     <li>{@code T} must resolve to a non parameterized type</li>
 *     <li>or generic parameters of {@code T} must be unbounded
 *     wildcard types</li>
 * </ul>
 * <p/>
 * The annotation {@link SupportedValidationTarget} can be put on a
 * {@code ConstraintValidator} implementation to mark it as supporting
 * cross-parameter constraints. Check out {@link SupportedValidationTarget}
 * and {@link Constraint} for more information.
 *
 * @author Emmanuel Bernard
 * @author Hardy Ferentschik
 */
public interface ConstraintValidator<A extends Annotation, T> {

    /**
     * Initializes the validator in preparation for
     * {@link #isValid(Object, ConstraintValidatorContext)} calls.
     * The constraint annotation for a given constraint declaration
     * is passed.
     * <p/>
     * This method is guaranteed to be called before any use of this instance for
     * validation.
     *
     * @param constraintAnnotation annotation instance for a given constraint declaration
     */
    void initialize(A constraintAnnotation);

    /**
     * Implements the validation logic.
     * The state of {@code value} must not be altered.
     * <p/>
     * This method can be accessed concurrently, thread-safety must be ensured
     * by the implementation.
     *
     * @param value object to validate
     * @param context context in which the constraint is evaluated
     *
     * @return {@code false} if {@code value} does not pass the constraint
     */
    boolean isValid(T value, ConstraintValidatorContext context);
}
----

[tck-not-testable]
--
Some restrictions apply on the generic type [classname]`T` (used in the [methodname]`isValid()` method). [classname]`T` must

* resolve to a non parameterized type (i.e. because the type is not using generics or because the raw type is used instead of the generic version)
* or generic parameters of [classname]`T` must be unbounded wildcard types (i.e. `<?>`).

--

[NOTE]
====
This restriction is not a theoretical limitation and a future version of the specification might allow it.
====

[tck-testable]#By default, a [classname]`ConstraintValidator` targets the (returned) element annotated by the constraint. You can make a [classname]`ConstraintValidator` target the array of parameters of a method or constructor (aka cross-parameter) by annotating the validator implementation with [classname]`@SupportedValidationTarget`.#

.@SupportedValidationTarget annotation and ValidationTarget enum
====

[source, JAVA]
----
package javax.validation.constraintvalidation;

/**
 * Defines the target(s) a {@link ConstraintValidator} can validate.
 * <p/>
 * A {@code ConstraintValidator} can target the (returned) element
 * annotated by the constraint, the array of parameters of a method
 * or constructor (aka cross-parameter) or both.
 * <p/>
 * If {@code @SupportedValidationTarget} is not present, the
 * {@code ConstraintValidator} targets the (returned) element annotated
 * by the constraint.
 * <p/>
 * A {@code ConstraintValidator} targeting cross-parameter must accept
 * {@code Object[]} (or {@code Object}) as the type of object it validates.
 *
 * @author Emmanuel Bernard
 * @since 1.1
 */
@Documented
@Target({ TYPE })
@Retention(RUNTIME)
public @interface SupportedValidationTarget {

    ValidationTarget[] value();
}
----

[source, JAVA]
----
package javax.validation.constraintvalidation;

/**
 * List of possible targets for a {@link ConstraintValidator}.
 *
 * @author Emmanuel Bernard
 * @since 1.1
 */
public enum ValidationTarget {

    /**
     * (Returned) element annotated by the constraint.
     */
    ANNOTATED_ELEMENT,

    /**
     * Array of parameters of the annotated method or constructor (aka cross-parameter).
     */
    PARAMETERS
}
----

====

[tck-testable]#A [classname]`ConstraintValidator` implementation can target both annotated elements and array of parameters.#

[tck-testable]#If a [classname]`ConstraintValidator` targets array of parameters (cross-parameter), [classname]`T` must resolve to [classname]`Object[]` (or [classname]`Object`) in order to have the array of parameter values passed to the [methodname]`isValid()` method. A [classname]`ConstraintDefinitionException` is raised otherwise.#

.Example of cross parameter ConstraintValidator
====

[source, JAVA]
----
@SupportedValidationTarget(ValidationTarget.PARAMETERS)
public class ScriptAssertValidator implements ConstraintValidator<ScriptAssert,Object[]> {
    @Override
    public void initialize(ScriptAssert constraintAnnotation) {
        [...]
    }

    @Override
    public boolean isValid(Object[] value, ConstraintValidatorContext context) {
        [...]
    }
}
----

====

<<example-constraintsdefinitionimplementation-validationimplementation-validdef>> shows some examples of valid definitions.

[[example-constraintsdefinitionimplementation-validationimplementation-validdef]]

.Valid ConstraintValidator definitions
====

[source, JAVA]
----
//String is not making use of generics
public class SizeValidatorForString implements ConstraintValidator<Size, String> {
    [...]
}

//Collection uses generics but the raw type is used
public class SizeValidatorForCollection implements ConstraintValidator<Size, Collection> {
    [...]
}

//Collection uses generics and unbounded windcard type
public class SizeValidatorForCollection implements ConstraintValidator<Size, Collection<?>> {
    [...]
}

//Validator for cross-parameter constraint
@SupportedValidationTarget(ValidationTarget.PARAMETERS)
public class DateParametersConsistentValidator
    implements ConstraintValidator<DateParametersConsistent, Object[]> {
    [...]
}

//Validator for both annotated elements and executable parameters
@SupportedValidationTarget({ValidationTarget.ANNOTATED_ELEMENT, ValidationTarget.PARAMETERS})
public class ELScriptValidator implements ConstraintValidator<ELScript, Object> {
    [...]
}
----

====

And some invalid definitions in <<example-constraintsdefinitionimplementation-validationimplementation-invaliddef>>.

[[example-constraintsdefinitionimplementation-validationimplementation-invaliddef]]

.Invalid ConstraintValidator definitions
====

[source, JAVA]
----
//parameterized type
public class SizeValidatorForString implements<Size, Collection<String>> {
    [...]
}

//parameterized type using bounded wildcard
public class SizeValidatorForCollection implements<Size, Collection<? extends Address>> {
    [...]
}

//cross-parameter validator accepting the wrong type
@SupportedValidationTarget(ValidationTarget.PARAMETERS)
public class NumberPositiveValidator implements ConstraintValidator<NumberPositive, Number> {
    [...]
}
----

====

The lifecycle of a constraint validation implementation instance is undefined. Bean Validation providers are allowed to cache [classname]`ConstraintValidator` instances retrieved from the [classname]`ConstraintValidatorFactory`.

[tck-testable]#The [methodname]`initialize()` method is called by the Bean validation provider prior to any use of the constraint implementation.#

[tck-testable]#The [methodname]`isValid()` method is evaluated by the Bean Validation provider each time a given value is validated.# [tck-not-testable]#It returns `false` if the value is not valid, `true` otherwise.# [tck-not-testable]#`isValid()` implementations must be thread-safe.#

[tck-testable]#If the property is of an unanticipated type, an `UnexpectedTypeException` is raised.# [classname]`ConstraintValidator` implementations raise this exception themselves if they receive an unsupported type. However, constraint designers are encouraged to make use of specialized [classname]`ConstraintValidator` implementations and delegate the type resolution to the Bean Validation provider (see the type matching algorithm described in <<typevalidatorresolution>>).

[tck-testable]#If an exception occurs either in the [methodname]`initialize()` or [methodname]`isValid()` method, the runtime exception is wrapped into a [classname]`ValidationException` by the Bean Validation engine.#

[tck-not-testable]#The constraint validation implementation is not allowed to change the state of the value passed to [methodname]`isValid()`.#

[NOTE]
====
While not mandatory, it is considered a good practice to split the core constraint validation from the not null constraint validation (for example, an [classname]`@Email` constraint will return `true` on a null object, i.e. will not take care of the [classname]`@NotNull` validation).

[code]`null` can have multiple meanings but is commonly used to express that a value does not make sense, is not available or is simply unknown. Those constraints on the value are orthogonal in most cases to other constraints. For example a String, if present, must be an email but can be null. Separating both concerns is a good practice.
====

The [classname]`ConstraintValidatorContext` object passed to the [methodname]`isValid()` method carries information and operations available in the context the constraint is validated to.

[source, JAVA]
----
/**
 * Provides contextual data and operation when applying a given constraint validator.
 *
 * At least one {@link ConstraintViolation} must be defined (either the default one,
 * of if the default {@code ConstraintViolation} is disabled, a custom one).
 *
 * @author Emmanuel Bernard
 */
public interface ConstraintValidatorContext {

    /**
     * Disables the default {@link ConstraintViolation} object generation (which
     * is using the message template declared on the constraint).
     * <p/>
     * Useful to set a different violation message or generate a {@code ConstraintViolation}
     * based on a different property.
     */
    void disableDefaultConstraintViolation();

    /**
     * @return the current un-interpolated default message
     */
    String getDefaultConstraintMessageTemplate();

    /**
     * Returns a constraint violation builder building a violation report
     * allowing to optionally associate it to a sub path.
     * The violation message will be interpolated.
     * <p/>
     * To create the {@link ConstraintViolation}, one must call either one of
     * the {@code addConstraintViolation()} methods available in one of the
     * interfaces of the fluent API.
     * If another method is called after {@code addConstraintViolation()} on
     * {@code ConstraintViolationBuilder} or any of its associated nested interfaces
     * an {@code IllegalStateException} is raised.
     * <p/>
     * If {@link ConstraintValidator#isValid(Object, ConstraintValidatorContext)} returns
     * {@code false}, a {@code ConstraintViolation} object will be built per constraint
     * violation report including the default one (unless
     * {@link #disableDefaultConstraintViolation()} has been called).
     * <p/>
     * {@code ConstraintViolation} objects generated from such a call
     * contain the same contextual information (root bean, path and so on) unless
     * the path has been overridden.
     * <p/>
     * To create a different {@code ConstraintViolation}, a new constraint violation builder
     * has to be retrieved from {@code ConstraintValidatorContext}
     *
     * Here are a few usage examples:
     * <pre>
     * //assuming the following domain model
     * public class User {
     *     public Map<String,Address> getAddresses() { ... }
     * }
     *
     * public class Address {
     *     public String getStreet() { ... }
     *     public Country getCountry() { ... }
     * }
     *
     * public class Country {
     *     public String getName() { ... }
     * }
     *
     * //From a property-level constraint on User.addresses
     * //Build a constraint violation on the default path - i.e. the "addresses" property
     * context.buildConstraintViolationWithTemplate( "this detail is wrong" )
     *             .addConstraintViolation();
     *
     * //From a class level constraint on Address
     * //Build a constraint violation on the default path + "street"
     * //i.e. the street property of Address
     * context.buildConstraintViolationWithTemplate( "this detail is wrong" )
     *             .addPropertyNode( "street" )
     *             .addConstraintViolation();
     *
     * //From a property-level constraint on  User.addresses
     * //Build a constraint violation on the default path + the bean stored
     * //under the "home" key in the map
     * context.buildConstraintViolationWithTemplate( "Incorrect home address" )
     *             .addBeanNode()
     *                 .inIterable().atKey( "home" )
     *             .addConstraintViolation();
     *
     * //From a class level constraint on User
     * //Build a constraint violation on the default path + addresses["home"].country.name
     * //i.e. property "country.name" on the object stored under "home" in the map
     * context.buildConstraintViolationWithTemplate( "this detail is wrong" )
     *             .addPropertyNode( "addresses" )
     *             .addPropertyNode( "country" )
     *                 .inIterable().atKey( "home" )
     *             .addPropertyNode( "name" )
     *             .addConstraintViolation();
     * </pre>
     * <p/>
     * Cross-parameter constraints on a method can create a node specific
     * to a particular parameter if required. Let's explore a few examples:
     * <p/>
     * <pre>
     * //Cross-parameter constraint on method createUser(String password, String passwordRepeat)
     * //Build a constraint violation on the default path + "passwordRepeat"
     * context.buildConstraintViolationWithTemplate("Passwords do not match")
     *             .addParameterNode(1)
     *             .addConstraintViolation();
     *
     * //Cross-parameter constraint on a method
     * //mergeAddresses(Map<String,Address> addresses, Map<String,Address> otherAddresses)
     * //Build a constraint violation on the default path + "otherAddresses["home"]
     * //i.e. the Address bean hosted in the "home" key of the "otherAddresses" map parameter
     * context.buildConstraintViolationWithTemplate(
     *         "Map entry home present in both and does not match")
     *             .addParameterNode(1)
     *             .addBeanNode()
     *                 .inIterable().atKey("home")
     *             .addConstraintViolation();
     *
     * //Cross-parameter constraint on a method
     * //mergeAddresses(Map<String,Address> addresses, Map<String,Address> otherAddresses)
     * //Build a constraint violation on the default path + "otherAddresses["home"].city
     * //i.e. on the "city" property of the Address bean hosted in
     * //the "home" key of the "otherAddresses" map
     * context.buildConstraintViolationWithTemplate(
     *         "Map entry home present in both but city does not match")
     *             .addParameterNode(1)
     *             .addPropertyNode("city")
     *                 .inIterable().atKey("home")
     *             .addConstraintViolation();
     * </pre>
     *
     * @param messageTemplate new un-interpolated constraint message
     * @return returns a constraint violation builder
     */
    ConstraintViolationBuilder buildConstraintViolationWithTemplate(String messageTemplate);

    /**
     * Returns an instance of the specified type allowing access to
     * provider-specific APIs. If the Bean Validation provider
     * implementation does not support the specified class,
     * {@link ValidationException} is thrown.
     *
     * @param type the class of the object to be returned
     * @return an instance of the specified class
     * @throws ValidationException if the provider does not support the call
     *
     * @since 1.1
     */
    <T> T unwrap(Class<T> type);

    /**
     * {@link ConstraintViolation} builder allowing to optionally associate
     * the violation report to a sub path.
     * <p/>
     * To create the {@code ConstraintViolation}, one must call either one of
     * the {@code addConstraintViolation()} methods available in one of the
     * interfaces of the fluent API.
     * <p/>
     * If another method is called after {@code addConstraintViolation()} on
     * {@code ConstraintViolationBuilder} or any of its associated objects
     * an {@code IllegalStateException} is raised.
     */
    interface ConstraintViolationBuilder {

        /**
         * Adds a node to the path the {@link ConstraintViolation} will be associated to.
         * <p/>
         * {@code name} describes a single property. In particular,
         * dot (.) is not allowed.
         *
         * @param name property name
         * @return a builder representing node {@code name}
         * @deprecated since 1.1 - replaced by {@link #addPropertyNode(String)},
         *             {@link #addBeanNode()} and {@link #addParameterNode(int)}
         */
        NodeBuilderDefinedContext addNode(String name);

        /**
         * Adds a property node to the path the {@link ConstraintViolation}
         * will be associated to.
         * <p/>
         * {@code name} describes a single property. In particular,
         * dot (.) is not allowed.
         *
         * @param name property name
         * @return a builder representing node {@code name}
         * @throws IllegalArgumentException if the name is null
         *
         * @since 1.1
         */
        NodeBuilderCustomizableContext addPropertyNode(String name);

        /**
         * Adds a bean node (class-level) to the path the {@link ConstraintViolation}
         * will be associated to.
         * Note that bean nodes are always leaf nodes.
         *
         * @return a builder representing the bean node
         *
         * @since 1.1
         */
        LeafNodeBuilderCustomizableContext addBeanNode();

        /**
         * Adds a method parameter node to the path the {@link ConstraintViolation}
         * will be associated to.
         * The parameter index must be valid (i.e. within the boundaries of the method
         * parameter indexes). May only be called from within cross-parameter validators.
         *
         * @param index the parameter index
         * @return a builder representing the index-th parameter node
         * @throws IllegalArgumentException if the index is not valid
         *
         * @since 1.1
         */
        NodeBuilderDefinedContext addParameterNode(int index);

        /**
         * Adds the new {@link ConstraintViolation} to be generated if the
         * constraint validator marks the value as invalid.
         * <p/>
         * Methods of this {@code ConstraintViolationBuilder} instance and its nested
         * objects throw {@code IllegalStateException} from now on.
         *
         * @return the {@code ConstraintValidatorContext} instance the
         *         {@code ConstraintViolationBuilder} comes from
         */
        ConstraintValidatorContext addConstraintViolation();

        /**
         * Represents a node whose context is known
         * (i.e. index, key and isInIterable)
         * and that is a leaf node (i.e. no subnode can be added).
         *
         * @since 1.1
         */
        interface LeafNodeBuilderDefinedContext {

            /**
             * Adds the new {@link ConstraintViolation} to be generated if the
             * constraint validator marks the value as invalid.
             * <p/>
             * Methods of the {@code ConstraintViolationBuilder} instance this object
             * comes from and the constraint violation builder nested
             * objects throw {@code IllegalStateException} after this call.
             *
             * @return {@code ConstraintValidatorContext} instance the
             *         {@code ConstraintViolationBuilder} comes from
             */
            ConstraintValidatorContext addConstraintViolation();
        }

        /**
         * Represents a node whose context is
         * configurable (i.e. index, key and isInIterable)
         * and that is a leaf node (i.e. no subnode can be added).
         *
         * @since 1.1
         */
        interface LeafNodeBuilderCustomizableContext {

            /**
             * Marks the node as being in an {@code Iterable} or a {@code Map}.
             *
             * @return a builder representing iterable details
             */
            LeafNodeContextBuilder inIterable();

            /**
             * Adds the new {@link ConstraintViolation} to be generated if the
             * constraint validator mark the value as invalid.
             * <p/>
             * Methods of the {@code ConstraintViolationBuilder} instance this object
             * comes from and the constraint violation builder nested
             * objects throw {@code IllegalStateException} after this call.
             *
             * @return {@code ConstraintValidatorContext} instance the
             *         {@code ConstraintViolationBuilder} comes from
             */
            ConstraintValidatorContext addConstraintViolation();
        }

        /**
         * Represents refinement choices for a node which is
         * in an {@code Iterator} or {@code Map}.
         * <p/>
         * If the iterator is an indexed collection or a map,
         * the index or the key should be set.
         * <p/>
         * The node is a leaf node (i.e. no subnode can be added).
         *
         * @since 1.1
         */
        interface LeafNodeContextBuilder {

            /**
             * Defines the key the object is into the {@code Map}.
             *
             * @param key map key
             * @return a builder representing the current node
             */
            LeafNodeBuilderDefinedContext atKey(Object key);

            /**
             * Defines the index the object is into the {@code List} or array
             *
             * @param index index
             * @return a builder representing the current node
             */
            LeafNodeBuilderDefinedContext atIndex(Integer index);

            /**
             * Adds the new {@link ConstraintViolation} to be generated if the
             * constraint validator mark the value as invalid.
             * <p/>
             * Methods of the {@code ConstraintViolationBuilder} instance this object
             * comes from and the constraint violation builder nested
             * objects throw {@code IllegalStateException} after this call.
             *
             * @return {@code ConstraintValidatorContext} instance the
             *           {@code ConstraintViolationBuilder} comes from
             */
            ConstraintValidatorContext addConstraintViolation();
        }

        /**
         * Represents a node whose context is known
         * (i.e. index, key and isInIterable)
         * and that is not necessarily a leaf node (i.e. subnodes can
         * be added).
         */
        interface NodeBuilderDefinedContext {

            /**
             * Adds a node to the path the {@link ConstraintViolation} will be associated to.
             * <p/>
             * {@code name} describes a single property. In particular,
             * dot (.) is not allowed.
             *
             * @param name property name
             * @return a builder representing node {@code name}
             * @deprecated since 1.1 - replaced by {@link #addPropertyNode(String)}
             *             and {@link #addBeanNode()}
             */
            NodeBuilderCustomizableContext addNode(String name);

            /**
             * Adds a property node to the path the {@link ConstraintViolation}
             * will be associated to.
             * <p/>
             * {@code name} describes a single property. In particular,
             * dot (.) is not allowed.
             *
             * @param name property name
             * @return a builder representing node {@code name}
             * @throws IllegalArgumentException if the name is null
             *
             * @since 1.1
             */
            NodeBuilderCustomizableContext addPropertyNode(String name);

            /**
             * Adds a bean node (class-level) to the path the {@link ConstraintViolation}
             * will be associated to.
             * Note that bean nodes are always leaf nodes.
             *
             * @return a builder representing the bean node
             *
             * @since 1.1
             */
            LeafNodeBuilderCustomizableContext addBeanNode();

            /**
             * Adds the new {@link ConstraintViolation} to be generated if the
             * constraint validator marks the value as invalid.
             * <p/>
             * Methods of the {@code ConstraintViolationBuilder} instance this object
             * comes from and the constraint violation builder nested
             * objects throw {@code IllegalStateException} after this call.
             *
             * @return {@code ConstraintValidatorContext} instance the
             *           {@code ConstraintViolationBuilder} comes from
             */
            ConstraintValidatorContext addConstraintViolation();
        }

        /**
         * Represents a node whose context is
         * configurable (i.e. index, key and isInIterable)
         * and that is not necessarily a leaf node (i.e. subnodes can
         * be added).
         */
        interface NodeBuilderCustomizableContext {

            /**
             * Marks the node as being in an {@code Iterable} or a {@code Map}.
             *
             * @return a builder representing iterable details
             */
            NodeContextBuilder inIterable();

            /**
             * Adds a node to the path the {@link ConstraintViolation} will be associated to.
             *
             * {@code name} describes a single property. In particular,
             * dot (.) is not allowed.
             *
             * @param name property name
             * @return a builder representing node {@code name}
             * @deprecated since 1.1 - replaced by {@link #addPropertyNode(String)}
             *             and {@link #addBeanNode()}
             */
            NodeBuilderCustomizableContext addNode(String name);

            /**
             * Adds a property node to the path the {@link ConstraintViolation}
             * will be associated to.
             *
             * {@code name} describes a single property. In particular,
             * dot (.) is not allowed.
             *
             * @param name property name
             * @return a builder representing node {@code name}
             * @throws IllegalArgumentException if the name is null
             *
             * @since 1.1
             */
            NodeBuilderCustomizableContext addPropertyNode(String name);

            /**
             * Adds a bean node (class-level) to the path the {@link ConstraintViolation}
             * will be associated to.
             * Note that bean nodes are always leaf nodes.
             *
             * @return a builder representing the bean node
             *
             * @since 1.1
             */
            LeafNodeBuilderCustomizableContext addBeanNode();

            /**
             * Adds the new {@link ConstraintViolation} to be generated if the
             * constraint validator mark the value as invalid.
             * <p/>
             * Methods of the {@code ConstraintViolationBuilder} instance this object
             * comes from and the constraint violation builder nested
             * objects throw {@code IllegalStateException} after this call.
             *
             * @return {@code ConstraintValidatorContext} instance the
             *           {@code ConstraintViolationBuilder} comes from
             */
            ConstraintValidatorContext addConstraintViolation();
        }

        /**
         * Represents refinement choices for a node which is
         * in an {@code Iterator} or {@code Map}.
         * <p/>
         * If the iterator is an indexed collection or a map,
         * the index or the key should be set.
         * <p/>
         * The node is not necessarily a leaf node (i.e. subnodes can
          * be added).
         */
        interface NodeContextBuilder {

            /**
             * Defines the key the object is into the {@code Map}.
             *
             * @param key map key
             * @return a builder representing the current node
             */
            NodeBuilderDefinedContext atKey(Object key);

            /**
             * Defines the index the object is into the {@code List} or array.
             *
             * @param index index
             * @return a builder representing the current node
             */
            NodeBuilderDefinedContext atIndex(Integer index);

            /**
             * Adds a node to the path the {@code ConstraintViolation} will be associated to.
             *
             * {@code name} describes a single property. In particular,
             * dot (.) is not allowed.
             *
             * @param name property name
             * @return a builder representing node {@code name}
             * @deprecated since 1.1 - replaced by {@link #addPropertyNode(String)}
             *             and {@link #addBeanNode()}
             */
            NodeBuilderCustomizableContext addNode(String name);

            /**
             * Adds a property node to the path the {@link ConstraintViolation}
             * will be associated to.
             *
             * {@code name} describes a single property. In particular,
             * dot (.) is not allowed.
             *
             * @param name property name
             * @return a builder representing node {@code name}
             * @throws IllegalArgumentException if the name is null
             *
             * @since 1.1
             */
            NodeBuilderCustomizableContext addPropertyNode(String name);

            /**
             * Adds a bean node (class-level) to the path the {@link ConstraintViolation}
             * will be associated to.
             * <p/>
             * Note that bean nodes are always leaf nodes.
             *
             * @return a builder representing the bean node
             *
             * @since 1.1
             */
            LeafNodeBuilderCustomizableContext addBeanNode();

            /**
             * Adds the new {@link ConstraintViolation} to be generated if the
             * constraint validator mark the value as invalid.
             * <p/>
             * Methods of the {@code ConstraintViolationBuilder} instance this object
             * comes from and the constraint violation builder nested
             * objects throw {@code IllegalStateException} after this call.
             *
             * @return {@code ConstraintValidatorContext} instance the
             *         {@code ConstraintViolationBuilder} comes from
             */
            ConstraintValidatorContext addConstraintViolation();
        }
    }
}
----

The [classname]`ConstraintValidatorContext` interface allows redefinition of the default constraint message generated when a constraint is not valid. [tck-testable]#By default, each invalid constraint leads to the generation of one error object represented by a [classname]`ConstraintViolation` object. This object is built from the default constraint message template as defined by the constraint declaration and the context in which the constraint declaration is placed (bean, property, executable parameter, cross-parameter or executable return value).#

[tck-testable]#The [classname]`ConstraintValidatorContext` methods let the constraint implementation disable the default [classname]`ConstraintViolation` generation and create one or more custom ones.# [tck-testable]#The non-interpolated message passed as a parameter is used to build the [classname]`ConstraintViolation` message (the message interpolation operation is applied to it).#

[tck-testable]#By default, the [classname]`Path` exposed on the [classname]`ConstraintViolation` represents the path to the bean, property, parameter, cross-parameter or return value hosting the constraint (see <<validationapi-constraintviolation>> for more information).# [tck-testable]#You can point it to a subpath of this default path by using the constraint violation builder fluent API.#

<<example-constraintsdefinitionimplementation-validationimplementation-errorbuilder>> shows a few examples.

[[example-constraintsdefinitionimplementation-validationimplementation-errorbuilder]]

.Using the fluent API to build custom constraint violations
====

[source, JAVA]
----
//assuming the following domain model
public class User {
    public Map<String,Address> getAddresses() { [...] }
}

public class Address {
    public String getStreet() { [...] }
    public Country getCountry() { [...] }
}

public class Country {
   public String getName() { [...] }
}

//From a property-level constraint on User.addresses
//Build a constraint violation on the default path - i.e. the "addresses" property
context.buildConstraintViolationWithTemplate( "this detail is wrong" )
            .addConstraintViolation();

//From a class level constraint on Address
//Build a constraint violation on the default path + "street"
//i.e. the street property of Address
context.buildConstraintViolationWithTemplate( "this detail is wrong" )
            .addPropertyNode( "street" )
            .addConstraintViolation();

//From a property-level constraint on  User.addresses
//Build a constraint violation on the default path + the bean stored
//under the "home" key in the map
context.buildConstraintViolationWithTemplate( "Incorrect home address" )
            .addBeanNode()
                .inIterable().atKey( "home" )
            .addConstraintViolation();

//From a class level constraint on User
//Build a constraint violation on the default path + addresses["home"].country.name
//i.e. property "country.name" on the object stored under "home" in the map
context.buildConstraintViolationWithTemplate( "this detail is wrong" )
            .addPropertyNode( "addresses" )
            .addPropertyNode( "country" )
                .inIterable().atKey( "home" )
            .addPropertyNode( "name" )
            .addConstraintViolation();

//To create a subnode representing a method parameter from a cross-parameter constraint violation

//Cross-parameter constraint on method createUser(String password, String passwordRepeat)
//Build a constraint violation on the default path + "passwordRepeat"
context.buildConstraintViolationWithTemplate("Passwords do not match")
            .addParameterNode(1)
            .addConstraintViolation();

//Cross-parameter constraint on a method
//mergeAddresses(Map<String,Address> addresses, Map<String,Address> otherAddresses)
//Build a constraint violation on the default path + "otherAddresses["home"]
//i.e. the Address bean hosted in the "home" key of the "otherAddresses" map parameter
context.buildConstraintViolationWithTemplate(
        "Map entry home present in both and does not match" )
            .addParameterNode( 1 )
            .addBeanNode()
                .inIterable().atKey( "home" )
            .addConstraintViolation();

//Cross-parameter constraint on a method
//mergeAddresses(Map<String,Address> addresses, Map<String,Address> otherAddresses)
//Build a constraint violation on the default path + "otherAddresses["home"].city
//i.e. on the "city" property of the Address bean hosted in
//the "home" key of the "otherAddresses" map
context.buildConstraintViolationWithTemplate(
        "Map entry home present in both but city does not match" )
            .addParameterNode( 1 )
            .addPropertyNode( "city" )
                .inIterable().atKey( "home" )
            .addConstraintViolation();
----

====

[tck-testable]#If [methodname]`disableDefaultConstraintViolation()` is called, no custom error is added (using the error builder) and if the constraint is not valid, a [classname]`ValidationException` is raised.#

[[constraintsdefinitionimplementation-validationimplementation-example]]

==== Examples

.ConstraintValidator implementation
====

[source, JAVA]
----
/**
 * Check that a text is within the authorized syntax
 */
public class SyntaxValidator implements ConstraintValidator<Syntax, String> {
    private Set<Format> allowedFormats;

    /**
     * Configure the constraint validator based on the elements
     * specified at the time it was defined.
     * @param constraint the constraint definition
     */
    public void initialize(Syntax constraint) {
        allowedFormats = new HashSet( Arrays.asList( constraint.value() ) );
    }

    /**
     * Validate a specified value.
     * returns false if the specified value does not conform to the definition
     */
    public boolean isValid(String value, ConstraintValidatorContext context) {
        if ( value == null ) return true;

        return allowedFormats.size() == 0
            || (! Collections.disjoint( guessFormat(value), allowedFormats ) );
    }

    Set<Format> guessFormats(String text) { [...] }
}
----

====

This [classname]`ConstraintValidator` checks that a text is within the accepted syntax. It also demonstrates an interesting best practice: return `true` on a null parameter.

The following listing shows a validator implementing the validation logic for a cross-parameter constraint.

.Cross-parameter validator implementation
====

[source, JAVA]
----
/**
 * Check that two date parameters of a method are in the expected order. Expects the
 * 2nd and 3rd parameter of the validated method to be of type java.util.Date.
 */
@SupportedValidationTarget(ValidationTarget.PARAMETERS)
public class DateParametersConsistentValidator implements<DateParametersConsistent, Object[]> {

    /**
     * Configure the constraint validator based on the elements
     * specified at the time it was defined.
     * @param constraint the constraint definition
     */
    public void initialize(DateParametersConsistent constraint) {
    }

    /**
     * Validate a specified value.
     * returns false if the specified value does not conform to the definition
     */
    public boolean isValid(Object[] value, ConstraintValidatorContext context) {
        if ( value.length != 3 ) {
            throw new IllegalStateException( "Unexpected method signature" );
        }
        // one or both limits are unbounded => always consistent
        if ( value[1] == null || value[2] == null ) return true;
        return ( (Date) value[1] ).before( (Date) value[2] );
    }
}
----

====

The following listing shows a validator implementing the validation logic for a constraint that is both generic and cross-parameter.

.Generic and cross-parameter validator implementation
====

[source, JAVA]
----
/**
 * Checks that an object passes the Expression Language expression
 * provided by the constraint.
 */
@SupportedValidationTarget({ValidationTarget.ANNOTATED_ELEMENT, ValidationTarget.PARAMETERS})
public class ELScriptValidator implements<ELScript, Object> {

    public void initialize(ELScript constraint) {
        [...]
    }

    public boolean isValid(Object value, ConstraintValidatorContext context) {
        [...]
    }
}
----

====

The next example shows how to use [classname]`ConstraintValidatorContext`.

.Use of ConstraintValidatorContext
====

[source, JAVA]
----
/**
 * Check that a text is within the authorized syntax
 * Error messages are using either key:
 *  - com.acme.constraint.Syntax.unknown if no particular syntax is detected
 *  - com.acme.constraint.Syntax.unauthorized if the syntax is not allowed
 */
public class FineGrainedSyntaxValidator implements ConstraintValidator<Syntax, String> {
    private Set<Format> allowedFormats;

    /**
     * Configure the constraint validator based on the elements
     * specified at the time it was defined.
     * @param constraint the constraint definition
     */
    public void initialize(Syntax constraint) {
        allowedFormats = new HashSet( Arrays.asList( constraint.value() ) );
    }

    /**
     * Validate a specified value.
     * returns false if the specified value does not conform to the definition
     */
    public boolean isValid(String value, ConstraintValidatorContext context) {
        if ( value == null ) return true;
        Set<Format> guessedFormats = guessFormats(value);

        context.disableDefaultConstraintViolation();
        if ( guessedFormats.size() == 0 ) {
            String unknown = "{com.acme.constraint.Syntax.unknown}";
            context.buildConstraintViolationWithTemplate(unknown)
                       .addConstraintViolation();
            return false;
        }
        if ( allowedFormats.size() != 0
            && Collections.disjoint( guessedFormats, allowedFormats ) ) {

            String unauthorized = "{com.acme.constraint.Syntax.unauthorized}";
            context.buildConstraintViolationWithTemplate(unauthorized)
                       .addConstraintViolation();
            return false;
        }
        return true;
    }

    Set<Format> guessFormats(String text) { [...] }
}
----

====

The default error message is disabled and replaced by a specific error message depending on the type of constraint violation detected. In this case, only one error report is returned at a given time but a constraint validation implementation can return several error reports.

[[constraintsdefinitionimplementation-constraintfactory]]

=== The ConstraintValidatorFactory

Constraint validation implementation instances are created by a [classname]`ConstraintValidatorFactory`.

The lifecycle of [classname]`ConstraintValidator` instances is fully dependent of the Bean Validation provider and piloted by the [classname]`ConstraintValidatorFactory` methods. Therefore, [classname]`ConstraintValidatorFactory` implementations (such as dependency injection frameworks) must consider these instances as belonging to a dependent scope. [tck-not-testable]#Bean Validation providers must release each instance retrieved. The [classname]`ConstraintValidatorFactory` instance that has created a [classname]`ConstraintValidator` instance must be the one that releases it. In other words, passing an instance of [classname]`ConstraintValidator` to a [classname]`ConstraintValidatorFactory` that has not created it is an error.#

[NOTE]
====
[classname]`ConstraintValidator` instances created by the [classname]`ValidatorFactory` -level [classname]`ConstraintValidatorFactory` can be released when the [classname]`ValidatorFactory` is being closed.
====

.ConstraintValidatorFactory interface
====

[source, JAVA]
----
/**
 * Instantiates a {@link ConstraintValidator} instance based off its class.
 * The {@code ConstraintValidatorFactory} is <b>not</b> responsible
 * for calling {@link ConstraintValidator#initialize(java.lang.annotation.Annotation)}.
 *
 * @author Dhanji R. Prasanna
 * @author Emmanuel Bernard
 * @author Hardy Ferentschik
 */
public interface ConstraintValidatorFactory {

    /**
     * @param key The class of the constraint validator to instantiate
     *
     * @return A new constraint validator instance of the specified class
     */
    <T extends ConstraintValidator<?, ?>> T getInstance(Class<T> key);

    /**
     * Signals {@code ConstraintValidatorFactory} that the instance is no longer
     * being used by the Bean Validation provider.
     *
     * @param instance validator being released
     *
     * @since 1.1
     */
    void releaseInstance(ConstraintValidator<?, ?> instance);
}
----

====

[tck-testable]#The default [classname]`ConstraintValidatorFactory` provided by the Bean Validation provider implementation uses the public no-arg constructor of the [classname]`ConstraintValidator` class.# A custom [classname]`ConstraintValidatorFactory` can be provided; for example it may benefit from dependency injection control in constraint implementations (see <<bootstrapping-usageandcontainerexpectation>>). Any constraint implementation relying on [classname]`ConstraintValidatorFactory` behaviors specific to an implementation (dependency injection, no no-arg constructor and so on) is not portable, hence great care should be given before walking that path. Make sure to configure the Bean Validation provider to honor any specific needs your [classname]`ConstraintValidator` has. As constraint designer and writer, make sure to document any specific non compliant requirements.

[classname]`ConstraintValidatorFactory` should not cache instances as the state of each instance can be altered in the [methodname]`initialize()` method.

[tck-testable]#If an exception occurs in the factory while retrieving the [classname]`ConstraintValidator` instance, the runtime exception is wrapped in a [classname]`ValidationException`.# [tck-testable]#If the instance returned by the factory is null, a [classname]`ValidationException` is raised.#
