// Jakarta Validation
//
// License: Apache License, Version 2.0
// See the license.txt file in the root directory or <http://www.apache.org/licenses/LICENSE-2.0>.
:validation-api-source-dir: ../target/validation-api/
:spec-examples-source-dir: ../spec-examples/src/test/java/

[[constraintsdefinitionimplementation]]

== Constraint definition

Constraints are defined by the combination of a constraint annotation and a list of constraint validation implementations. The constraint annotation is applied on types, fields, methods, constructors, parameters, container elements or other constraint annotations in case of composition.

Unless stated otherwise the default package name for the {spec-name-bv} APIs is [classname]`jakarta.validation`.

[[constraintsdefinitionimplementation-constraintdefinition]]

=== Constraint annotation

A constraint on a JavaBean is expressed through one or more annotations. [tck-not-testable]#An annotation is considered a constraint definition if its retention policy contains `RUNTIME` and if the annotation itself is annotated with `jakarta.validation.Constraint`# .

[role="api"]
.`@Constraint` annotation
====
[source, JAVA, indent=0]
----
include::{validation-api-source-dir}jakarta/validation/Constraint.java[lines=19..-1]
----
====

A constraint is said to be generic if it has at least one constraint validator targeting the element annotated i.e. targeting the (returned) element annotated by the constraint (a bean, a field, a getter, a method/constructor return value or a method/constructor parameter). A constraint is said to be cross-parameter if it has one constraint validator targeting the array of parameters of a method or constructor (to validate the consistency of several method/constructor parameters). A {spec-name-bv} constraint is most of the time either a generic constraint or a cross-parameter constraint. In rare situations, a constraint can be both.

[tck-not-testable]
--
Generic constraint annotations can target any of the following [classname]``ElementType``s:

* `FIELD` for constrained attributes
* `METHOD` for constrained getters and constrained method return values
* `CONSTRUCTOR` for constrained constructor return values
* `PARAMETER` for constrained method and constructor parameters
* `TYPE` for constrained beans
* `ANNOTATION_TYPE` for constraints composing other constraints
* `TYPE_USE` for container element constraints
--

[tck-not-testable]
--
Cross-parameter constraint annotations can target any of the following [classname]``ElementType``s:

* `METHOD`
* `CONSTRUCTOR`
* `ANNOTATION_TYPE` for cross-parameter constraints composing other cross-parameter constraints
--

[tck-not-testable]#A constraint annotation that is both can target the union of the generic and cross-parameter constraint annotations targets.#

While other [classname]``ElementType``s are not forbidden, the provider does not have to recognize and process constraints placed on such types.

Since a given constraint definition applies to one or more specific Java types, the JavaDoc for the constraint annotation should clearly state which types are supported. [tck-testable]#Applying a constraint annotation to an incompatible type will raise an [classname]`UnexpectedTypeException`.# Care should be taken on defining the list of [classname]``ConstraintValidator``s. The type resolution algorithm (see <<constraintdeclarationvalidationprocess-validationroutine-typevalidatorresolution>>) could lead to exceptions if the [classname]`ConstraintValidator` list leads to ambiguities.

[tck-testable]#At most one [classname]`ConstraintValidator` supporting cross-parameter validation must be present for a given constraint. A [classname]`ConstraintDefinitionException` is raised otherwise.# The JavaDoc should clearly state if the constraint is a generic and / or a cross-parameter constraint.

[tck-testable]#If a constraint definition is not valid, a [classname]`ConstraintDefinitionException` is raised either at validation time or when the metadata is requested.# Invalid constraint definitions causes are multiple but include missing or illegal [methodname]`message` or [methodname]`groups` elements (see <<constraintsdefinitionimplementation-constraintdefinition-properties>>).

[NOTE]
====
{spec-name-bv} defines rules for applying constraint annotations in inheritance hierarchies, described in <<constraintdeclarationvalidationprocess-inheritance>> and <<constraintdeclarationvalidationprocess-methodlevelconstraints-inheritance>>. It is therefore not recommended to specify the meta annotation [classname]`java.lang.annotation.Inherited` at constraint annotation types, as it is not relevant in the context of {spec-name-bv} and would conflict with the proposed rules.
====

[[constraintsdefinitionimplementation-constraintdefinition-properties]]

==== Constraint definition properties

[tck-testable]#A constraint definition may have attributes that are specified at the time the constraint is applied to a JavaBean.# The properties are mapped as annotation elements. The annotation element names `message`, `groups`, `validationAppliesTo` and `payload` are considered reserved names; [tck-testable]#annotation elements starting with `valid` are not allowed# ; a constraint may use any other element name for its attributes.

[[constraintsdefinitionimplementation-constraintdefinition-properties-message]]

===== message

[tck-testable]#Every constraint annotation must define a `message` element of type `String`.#

[source, JAVA]
----
String message() default "{com.acme.constraint.MyConstraint.message}";
----

The [methodname]`message` element value is used to create the error message. See <<validationapi-message>> for a detailed explanation. It is recommended to default `message` values to resource bundle keys to enable internationalization. It is also recommended to use the following convention: the resource bundle key should be the fully qualified class name of the constraint annotation concatenated to `.message` as shown in the previous program listing.

Built-in {spec-name-bv} constraints follow this convention.

[[constraintsdefinitionimplementation-constraintdefinition-properties-groups]]

===== groups

[tck-testable]#Every constraint annotation must define a `groups` element that specifies the processing groups with which the constraint declaration is associated.# [tck-testable]#The type of the `groups` parameter is [classname]`Class<?>[]`.#

[source, JAVA]
----
Class<?>[] groups() default {};
----

[tck-testable]#The default value must be an empty array.#

[tck-testable]#If no group is specified when declaring the constraint on an element, the `Default` group is considered declared.#

See <<validationapi-validatorapi-groups>> for more information.

Groups are typically used to control the order in which constraints are evaluated, or to perform validation of the partial state of a JavaBean.

[[constraintsdefinitionimplementation-constraintdefinition-properties-payload]]

===== payload

[tck-testable]#Constraint annotations must define a `payload` element that specifies the payload with which the constraint declaration is associated. The type of the `payload` parameter is [classname]`Payload[]`.#

[source, JAVA]
----
Class<? extends Payload>[] payload() default {};
----

[tck-testable]#The default value must be an empty array.#

[tck-testable]#Each attachable payload extends [classname]`Payload`.#

[role="api"]
.`Payload` interface
====
[source, JAVA, indent=0]
----
include::{validation-api-source-dir}jakarta/validation/Payload.java[lines=11..-1]
----
====

Payloads are typically used by validation clients to associate some metadata information with a given constraint declaration.
Describing payloads as interface extensions as opposed to a string-based approach allows an easier and more type-safe approach.
Payloads are typically non-portable.
An exception are the `Unwrapping.Skip` and `Unwrapping.Unwrap` payload types which are defined by this specification (see <<constraintdeclarationvalidationprocess-containerelementconstraints-implicitunwrapping>>).

One use case for payload shown in <<example-payload>> is to associate a severity to a constraint. This severity can be exploited by a presentation framework to adjust how a constraint failure is displayed.

[[example-payload]]

.Use of payload to associate severity to a constraint
====

[source, JAVA]
----
package com.acme.severity;

public class Severity {
    public static class Info implements Payload {};
    public static class Error implements Payload {};
}

public class Address {
    @NotNull(message="would be nice if we had one", payload=Severity.Info.class)
    public String getZipCode() { [...] }

    @NotNull(message="the city is mandatory", payload=Severity.Error.class)
    String getCity() { [...] }
}
----

====

The `payload` information can be retrieved from error reports via the [classname]`ConstraintDescriptor` either accessed through the [classname]`ConstraintViolation` objects (see <<validationapi-constraintviolation>>) or through the metadata API (see <<constraintmetadata-constraintdescriptor>>).

[[constraintsdefinitionimplementation-constraintdefinition-properties-validationappliesto]]

===== validationAppliesTo

`validationAppliesTo` is used at constraint declaration time to clarify what the constraint targets (i.e. the annotated element, the method return value or the method parameters).

[tck-testable]#The element `validationAppliesTo` must only be present for constraints that are both generic and cross-parameter, it is mandatory in this situation. A [classname]`ConstraintDefinitionException` is raised if these rules are violated.#

[tck-testable]#The type of the `validationAppliesTo` parameter is [classname]`ConstraintTarget`. The default value must be [classname]`ConstraintTarget.IMPLICIT`.#

[role="api"]
.validationAppliesTo and ConstraintTarget
====

[source, JAVA]
----
ConstraintTarget validationAppliesTo() default ConstraintTarget.IMPLICIT;
----

[source, JAVA, indent=0]
----
include::{validation-api-source-dir}jakarta/validation/ConstraintTarget.java[lines=9..-1]
----

====

[tck-testable]#If a [classname]`ConstraintTarget` is used in an illegal situation, a [classname]`ConstraintDeclarationException` is raised either at validation time or when the metadata is requested.# Examples of illegal situations are:

* [tck-testable]#using `IMPLICIT` in a situation that cannot be inferred (see the JavaDoc for the detailed rules),#
* [tck-testable]#using `PARAMETERS` on a constructor or method that has no parameter,#
* [tck-testable]#using `RETURN_VALUE` on a method with no return value,#
* [tck-testable]#using `PARAMETERS` or `RETURN_VALUE` on a type - class or interface - or on a field.#


Constraint users are encouraged to explicitly set the [classname]`ConstraintTarget` target when using a constraint supporting both on a method or constructor as it improves readability.

[[constraintsdefinitionimplementation-constraintdefinition-properties-specific]]
===== Constraint specific parameter

The constraint annotation definitions may define additional elements to parameterize the constraint. For example, a constraint that validates the length of a string can use an annotation element named `length` to specify the maximum length at the time the constraint is declared.

[[constraintsdefinitionimplementation-constraintdefinition-examples]]
==== Examples

[[example-definition-notnull]]

.Simple constraint definition
====

[source, JAVA, indent=0]
----
//assuming OrderNumberValidator is a generic constraint validator

package com.acme.constraint;

include::{spec-examples-source-dir}org/beanvalidation/specexamples/constraintdefinition/annotation/OrderNumber.java[tags=include]
----

====

<<example-definition-notnull>> marks a [classname]`String` as a well-formed order number. The constraint validator is implemented by [classname]`OrderNumberValidator`.

[[example-definition-crossparameter]]

.Simple cross-parameter constraint definition
====

[source, JAVA, indent=0]
----
//assuming DateParametersConsistentValidator is a cross-parameter
//constraint validator

package com.acme.constraint;

include::{spec-examples-source-dir}org/beanvalidation/specexamples/constraintdefinition/annotation/DateParametersConsistent.java[tags=include]
----

====

<<example-definition-crossparameter>> shows a cross-parameter constraint which ensures that two date parameters of a method are in the correct order. The constraint validator is implemented by [classname]`DateParametersConsistentValidator`.

[[example-definition-genericandcrossparameter]]

.Constraint that is both generic and cross parameter
====

[source, JAVA, indent=0]
----
//assuming ELAssertValidator is both a generic and cross-parameter
//constraint validator

package com.acme.constraint;

include::{spec-examples-source-dir}org/beanvalidation/specexamples/constraintdefinition/annotation/ELAssert.java[tags=include]
----

[source, JAVA]
----
@ELAssert(
    message="Please check that your passwords match and try again.",
    expression="param[1]==param[2]",
    validationAppliesTo=ConstraintType.PARAMETERS
)
public User createUser(String email, String password, String repeatPassword) { [...] }
----

====

<<example-definition-genericandcrossparameter>> shows a constraint that can be applied both on the annotated element and across parameters of a method or a constructor. Note in this case the presence of [methodname]`validationAppliesTo`.

[[example-definition-length]]

.Constraint definition with default parameter
====

[source, JAVA, indent=0]
----
package com.acme.constraint;

include::{spec-examples-source-dir}org/beanvalidation/specexamples/constraintdefinition/annotation/Audible.java[tags=include]
----

====

<<example-definition-length>> ensures that a given frequency is within the scope of human ears. The constraint definition includes an optional parameter that may be specified when the constraint is applied.

[[example-definition-mandatory]]

.Constraint definition with mandatory parameter
====

[source, JAVA, indent=0]
----
package com.acme.constraint;

include::{spec-examples-source-dir}org/beanvalidation/specexamples/constraintdefinition/annotation/Acceptable.java[tags=include]
----

====

<<example-definition-mandatory>> defines a list of acceptable values expressed as an array: the [methodname]`value` property must be specified when the constraint is applied.

[[constraintsdefinitionimplementation-multipleconstraints]]

=== Applying multiple constraints of the same type

It is often useful to declare the same constraint more than once to the same target, with different properties. A common example is the `@Pattern` constraint, which validates that its target matches a specified regular expression. Other constraints have this requirement as well. The same constraint type can belong to different groups and have specific error messages depending on the targeted group.

To support this requirement, [tck-testable]#the {spec-name-bv} provider treats regular annotations (annotations not annotated by [classname]`@Constraint`) whose `value` element has a return type of an array of constraint annotations in a special way. Each element in the `value` array are processed by the {spec-name-bv} implementation as regular constraint annotations.# This means that each constraint specified in the `value` element is applied to the target. The annotation must have retention `RUNTIME` and can be applied on a type, field, property, executable parameter, executable return value, executable cross-parameter or another annotation. It is recommended to use the same set of targets as the initial constraint.

Note to constraint designers: each constraint annotation should be coupled with its corresponding multi-valued annotation. The specification recommends, though does not mandate, the definition of an inner annotation named [classname]`List`.
Each constraint annotation type should be meta-annotated with [classname]`java.lang.annotation.Repeatable`, referencing the corresponding [classname]`List` annotation.
[tck-testable]#This marks the constraint annotation type as repeatable and lets users specify the constraint several times without explicitly using the [classname]`List` annotation.#
All built-in annotations follow this pattern.

.Multi-valued constraint definition
====
[source, JAVA, indent=0]
----
include::{spec-examples-source-dir}org/beanvalidation/specexamples/constraintdefinition/multivaluedconstraint/ZipCode.java[tags=include]
----
====

.Multi-valued constraint declaration
====
[source, JAVA, indent=0]
----
include::{spec-examples-source-dir}org/beanvalidation/specexamples/constraintdefinition/multivaluedconstraint/Address.java[tags=include]
----
====

In this example, both constraints apply to the [methodname]`zipCode` field but with different groups and with different error messages.
It is also possible to specify a constraint several times by explicitly using the [classname]`@List` annotation
(though simply repeating the annotation is the preferred idiom as of {spec-name-bv} 2.0 and Java 8):

.Multi-valued constraint declaration using explicit [classname]`@List` annotation (discouraged)
====
[source, JAVA, indent=0]
----
include::{spec-examples-source-dir}org/beanvalidation/specexamples/constraintdefinition/multivaluedconstraint/explicitlist/Address.java[tags=include]
----
====

Using two different multi-constraint annotations for the same underlying constraint type on the same target (i.e. class or property) is not considered portable and is discouraged.

[[constraintsdefinitionimplementation-constraintcomposition]]

=== Constraint composition

This specification allows you to compose constraints to create higher level constraints.

Constraint composition is useful in several ways:

* Avoid duplication and facilitate reuse of more primitive constraints.
* Expose primitive constraints as part of a composed constraint in the metadata API and enhance tool awareness.


Composition is done by annotating a constraint annotation with the composing constraint annotations.

.Composition is done by annotating the composed constraint
====

[source, JAVA]
----
include::{spec-examples-source-dir}org/beanvalidation/specexamples/constraintdefinition/constraintcomposition/FrenchZipCode.java[tags=include]
----

====

Annotating an element with [classname]`@FrenchZipCode` (the composed annotation) is equivalent to annotating it with [classname]`@Pattern(regexp="[0-9]*")`, [classname]`@Size(min=5, max=5)` (the composing annotations) and [classname]`@FrenchZipCode`. [tck-testable]#More formally, each constraint annotation hosted on a constraint annotation is applied to the target element and this is done recursively.# [tck-testable]#Note that the main annotation and its constraint validation implementation is also applied.# [tck-testable]#By default, each failing constraint generates an error report.# [tck-testable]#Groups from the main constraint annotation are inherited by the composing annotations.# [tck-testable]#Any [methodname]`groups` definition on a composing annotation is ignored.# [tck-testable]#Payload from the main constraint annotation is inherited by the composing annotations.# [tck-testable]#Any [methodname]`payload` definition on a composing annotation is ignored.# [tck-testable]#The constraint target from the main constraint annotation is inherited by the composing annotations.# [tck-testable]#Any [methodname]`validationAppliesTo` definition on a composing annotation is ignored.#

[tck-testable]#The type upon which composed constraint is placed must be compatible with all constraints (composing and composed).# A constraint designer should ensure that such a type exists and lists in the JavaDoc all the compatible types.

[tck-testable]#All composed and composing constraints must have a constraint type in common.# In particular, it is not legal to mix a pure generic constraint and a pure cross-parameter constraint.

It is possible to ensure that composing annotations do not raise individual error reports. In this scenario, if one or more composing annotations are invalid, the main constraint is automatically considered invalid and the corresponding error report is generated. To mark a constraint as raising a single constraint error report if either the composed or one of the composing constraints fail, use the [classname]`@ReportAsSingleViolation` annotation.

.If any of the composing constraints fail, the error report corresponding to [classname]`@FrenchZipCode` is raised and none other.
====

[source, JAVA, indent=0]
----
include::{spec-examples-source-dir}org/beanvalidation/specexamples/constraintdefinition/constraintcomposition/single/FrenchZipCode.java[tags=include]
----

====

The definition of [classname]`@ReportAsSingleViolation` is as follows.

[role="api"]
.`@ReportAsSingleViolation` annotation
====
[source, JAVA, indent=0]
----
include::{validation-api-source-dir}jakarta/validation/ReportAsSingleViolation.java[lines=16..-1]
----
====

[tck-testable]#More specifically, if a composed constraint is marked as [classname]`@ReportAsSingleViolation`, the evaluation of the composing constraints stops at the first failing constraint and the error report corresponding to the composed constraint is generated and returned.#

[tck-testable]#Composing annotations can define the value of `message` and custom attributes (excluding [methodname]`groups`, [methodname]`payload` and [methodname]`validationAppliesTo`) but these are fixed in the composed constraint definition.#

.Composing annotations can use attributes. They are fixed for a given main annotation. All [classname]`@FrenchZipCode` constraints have a [classname]`@Size` restricted to 5.
====

[source, JAVA, indent=0]
----
include::{spec-examples-source-dir}org/beanvalidation/specexamples/constraintdefinition/constraintcomposition/FrenchZipCode.java[tags=include]
----

====

[tck-testable]
--
It is possible to override attributes and messages defined on a composing annotation.
An attribute from the main annotation is used to override one or more attributes of the composing annotations.
Such an attribute is annotated with one or more `@OverridesAttribute` annotations.
--

[[example-composing-overridden]]

.Attributes from composing annotations can be overridden by attributes from the composed annotation
====

[source, JAVA, indent=0]
----
include::{spec-examples-source-dir}org/beanvalidation/specexamples/constraintdefinition/constraintcomposition/overriding/FrenchZipCode.java[tags=include]
----

====

The value of the composed constraint attribute annotated with [classname]`@OverridesAttribute` ([methodname]`@FrenchZipCode.sizeMessage`) is applied to the composing constraint attribute named after [methodname]`@OverridesAttribute.name` and hosted on the composing constraint of type [methodname]`@OverridesAttribute.constraint` ([methodname]`@Size.message`). Similarly, [classname]`@FrenchZipCode.numberMessage` value is mapped to [classname]`@Pattern.message`.

[tck-testable]#If left undefined, the default value for [methodname]`@OverridesAttribute.name` is the name of the composed constraint attribute hosting the [classname]`@OverridesAttribute` annotation.#

[tck-testable]#The types of the overridden and overriding attributes must be identical.#

[NOTE]
====
[tck-testable]#A composing constraint can itself be a composed constraint. In this case, attribute values are overridden recursively according to the described rules.# Note however, that a forwarding rule (as defined by [classname]`@OverridesAttribute`) is only applied to the direct composing constraints.
====

Using <<example-composing-overridden>>,

[source, JAVA]
----
@FrenchZipCode(size=9, sizeMessage="Zip code should be of size {max}")
----

is equivalent to

[source, JAVA]
----
@FrenchZipCode
----

if [classname]`@FrenchZipCode` is defined as

[source, JAVA, indent=0]
----
include::{spec-examples-source-dir}org/beanvalidation/specexamples/constraintdefinition/constraintcomposition/overriding/interpreted/FrenchZipCode.java[tags=include]
----

[tck-testable]#If a constraint is used more than once as a composing constraint, the multi value constraints model as described in <<constraintsdefinitionimplementation-multipleconstraints>> is used.#

To select a specific composing constraint, [methodname]`OverridesAttribute.constraintIndex` is used.
[tck-testable]#If the composing constraints are directly given on the composed constraint (i.e. via the repeatable annotation feature), `constraintIndex` refers to the left-to-right order of the constraints of this type in which they are given on the composed constraint.#
[tck-testable]#If the composing constraints are specified using their corresponding `List` annotation, `constraintIndex` refers to the index within the `value` array.#
[tck-testable]
--
A composing constraint must not be given directly on the composed constraint and using the corresponding `List` annotation at the same time.
A `ConstraintDeclarationException` will be raised in this case.
--

[tck-testable]#If `index` is undefined, the single constraint declaration is targeted.#

.Use of constraintIndex in @OverridesAttribute
====

[source, JAVA, indent=0]
----
include::{spec-examples-source-dir}org/beanvalidation/specexamples/constraintdefinition/constraintcomposition/overriding/constraintindex/EmmanuelsEmail.java[tags=include]
----

====

[classname]`@OverridesAttribute` definition is as follows:

[role="api"]
.`@OverridesAttribute` annotation
====
[source, JAVA, indent=0]
----
include::{validation-api-source-dir}jakarta/validation/OverridesAttribute.java[lines=20..-1]
----
====

The following elements uniquely identify an overridden constraint attribute:

* [methodname]`@OverridesAttribute.constraint`
* [methodname]`@OverridesAttribute.name`
* [methodname]`@OverridesAttribute.constraintIndex`


[tck-testable]
--
If the composition is invalid, e.g.

* infinitely recursive composition
* wrong attribute overriding
* a single attribute mapped to more than one source attribute
* a composing and composed constraint marked as different constraint types (i.e., generic and cross-parameter)
* etc.

a [classname]`ConstraintDefinitionException` is raised either at validation time or when the metadata is requested.
--

Constraint designers are encouraged to make use of composition (recursively or not) based on the built-in constraints defined by the specification. The composing constraints are exposed through the {spec-name-bv} metadata API (<<constraintmetadata-constraintdescriptor>>). This metadata is particularly useful for third-party metadata consumers like persistence frameworks generating database schemas (such as {spec-name-persistence}) or presentation frameworks.

[[constraintsdefinitionimplementation-validationimplementation]]

=== Constraint validation implementation

[tck-testable]#A constraint validation implementation performs the validation of a given constraint annotation for a given type.# [tck-testable]#The implementation classes are specified by the `validatedBy` element of the [classname]`@Constraint` annotation that decorates the constraint definition.# [tck-not-testable]#The constraint validation implementation implements the [classname]`ConstraintValidator` interface.#

[role="api"]
.`ConstraintValidator` interface
====
[source, JAVA, indent=0]
----
include::{validation-api-source-dir}jakarta/validation/ConstraintValidator.java[lines=12..-1]
----
====

[tck-not-testable]
--
Some restrictions apply on the generic type [classname]`T` (used in the [methodname]`isValid()` method). [classname]`T` must

* resolve to a non parameterized type (i.e. because the type is not using generics or because the raw type is used instead of the generic version)
* or generic parameters of [classname]`T` must be unbounded wildcard types (i.e. `<?>`).
--

[NOTE]
====
This restriction is not a theoretical limitation and a future version of the specification might allow it.
====

[tck-testable]#By default, a [classname]`ConstraintValidator` targets the (returned) element annotated by the constraint. You can make a [classname]`ConstraintValidator` target the array of parameters of a method or constructor (aka cross-parameter) by annotating the validator implementation with [classname]`@SupportedValidationTarget`.#

[role="api"]
.`@SupportedValidationTarget` annotation and `ValidationTarget` enum
====

[source, JAVA, indent=0]
----
include::{validation-api-source-dir}jakarta/validation/constraintvalidation/SupportedValidationTarget.java[lines=7..8;17..-1]
----

[source, JAVA, indent=0]
----
include::{validation-api-source-dir}jakarta/validation/constraintvalidation/ValidationTarget.java[lines=7..8;11..-1]
----

====

[tck-testable]#A [classname]`ConstraintValidator` implementation can target both annotated elements and array of parameters.#

[tck-testable]#If a [classname]`ConstraintValidator` targets array of parameters (cross-parameter), [classname]`T` must resolve to [classname]`Object[]` (or [classname]`Object`) in order to have the array of parameter values passed to the [methodname]`isValid()` method. A [classname]`ConstraintDefinitionException` is raised otherwise.#

.Example of cross parameter ConstraintValidator
====

[source, JAVA]
----
@SupportedValidationTarget(ValidationTarget.PARAMETERS)
public class ScriptAssertValidator implements ConstraintValidator<ScriptAssert,Object[]> {
    @Override
    public void initialize(ScriptAssert constraintAnnotation) {
        [...]
    }

    @Override
    public boolean isValid(Object[] value, ConstraintValidatorContext context) {
        [...]
    }
}
----

====

<<example-constraintsdefinitionimplementation-validationimplementation-validdef>> shows some examples of valid definitions.

[[example-constraintsdefinitionimplementation-validationimplementation-validdef]]

.Valid ConstraintValidator definitions
====

[source, JAVA]
----
//String is not making use of generics
public class SizeValidatorForString implements ConstraintValidator<Size, String> {
    [...]
}

//Collection uses generics but the raw type is used
public class SizeValidatorForCollection implements ConstraintValidator<Size, Collection> {
    [...]
}

//Collection uses generics and unbounded wildcard type
public class SizeValidatorForCollection implements ConstraintValidator<Size, Collection<?>> {
    [...]
}

//Validator for cross-parameter constraint
@SupportedValidationTarget(ValidationTarget.PARAMETERS)
public class DateParametersConsistentValidator
    implements ConstraintValidator<DateParametersConsistent, Object[]> {
    [...]
}

//Validator for both annotated elements and executable parameters
@SupportedValidationTarget({ValidationTarget.ANNOTATED_ELEMENT, ValidationTarget.PARAMETERS})
public class ELScriptValidator implements ConstraintValidator<ELScript, Object> {
    [...]
}
----

====

And some invalid definitions in <<example-constraintsdefinitionimplementation-validationimplementation-invaliddef>>.

[[example-constraintsdefinitionimplementation-validationimplementation-invaliddef]]

.Invalid ConstraintValidator definitions
====

[source, JAVA]
----
//parameterized type
public class SizeValidatorForString implements ConstraintValidator<Size, Collection<String>> {
    [...]
}

//parameterized type using bounded wildcard
public class SizeValidatorForCollection implements ConstraintValidator<Size, Collection<? extends Address>> {
    [...]
}

//cross-parameter validator accepting the wrong type
@SupportedValidationTarget(ValidationTarget.PARAMETERS)
public class NumberPositiveValidator implements ConstraintValidator<NumberPositive, Number> {
    [...]
}
----

====

The lifecycle of a constraint validation implementation instance is undefined. {spec-name-bv} providers are allowed to cache [classname]`ConstraintValidator` instances retrieved from the [classname]`ConstraintValidatorFactory`.

[tck-testable]#The [methodname]`initialize()` method is called by the {spec-name-bv} provider prior to any use of the constraint implementation.#
[tck-testable]#As of {spec-name-bv} 2.0, `initialize()` has an empty default implementation,
allowing to omit the implementation from validators that don't need to access any constraint attributes.#

[tck-testable]#The [methodname]`isValid()` method is evaluated by the {spec-name-bv} provider each time a given value is validated.# [tck-not-testable]#It returns `false` if the value is not valid, `true` otherwise.# [tck-not-testable]#`isValid()` implementations must be thread-safe.#

[tck-testable]#If the property is of an unanticipated type, an `UnexpectedTypeException` is raised.# [classname]`ConstraintValidator` implementations raise this exception themselves if they receive an unsupported type. However, constraint designers are encouraged to make use of specialized [classname]`ConstraintValidator` implementations and delegate the type resolution to the {spec-name-bv} provider (see the type matching algorithm described in <<constraintdeclarationvalidationprocess-validationroutine-typevalidatorresolution>>).

[tck-testable]#If an exception occurs either in the [methodname]`initialize()` or [methodname]`isValid()` method, the runtime exception is wrapped into a [classname]`ValidationException` by the {spec-name-bv} engine.#

[tck-not-testable]#The constraint validation implementation is not allowed to change the state of the value passed to [methodname]`isValid()`.#

[NOTE]
====
While not mandatory, it is considered a good practice to split the core constraint validation from the not null constraint validation (for example, an [classname]`@Email` constraint will return `true` on a null object, i.e. will not take care of the [classname]`@NotNull` validation).

[code]`null` can have multiple meanings but is commonly used to express that a value does not make sense, is not available or is simply unknown. Those constraints on the value are orthogonal in most cases to other constraints. For example a String, if present, must be an email but can be null. Separating both concerns is a good practice.
====

The [classname]`ConstraintValidatorContext` object passed to the [methodname]`isValid()` method carries information and operations available in the context the constraint is validated to.

[role="api"]
.`ConstraintValidatorContext` interface
====
[source, JAVA]
----
include::{validation-api-source-dir}jakarta/validation/ConstraintValidatorContext.java[lines=11..-1]
----
====

The [classname]`ConstraintValidatorContext` interface provides access to contextual information useful for the validation of specific constraints (e.g. `getClockProvider()`, see <<constraintsdefinitionimplementation-validationimplementation-temporalvalidators>> ).

It also allows redefinition of the default constraint message generated when a constraint is not valid. [tck-testable]#By default, each invalid constraint leads to the generation of one error object represented by a [classname]`ConstraintViolation` object.
This object is built from the default constraint message template as defined by the constraint declaration and the context in which the constraint declaration is placed (bean, property, executable parameter, cross-parameter, executable return value or container element).#

[tck-testable]#The [classname]`ConstraintValidatorContext` methods let the constraint implementation disable the default [classname]`ConstraintViolation` generation and create one or more custom ones.# [tck-testable]#The non-interpolated message passed as a parameter is used to build the [classname]`ConstraintViolation` message (the message interpolation operation is applied to it).#

[tck-testable]#By default, the [classname]`Path` exposed on the [classname]`ConstraintViolation` represents the path to the bean, property, parameter, cross-parameter, return value or container element hosting the constraint (see <<validationapi-constraintviolation>> for more information).# [tck-testable]#You can point it to a subpath of this default path by using the constraint violation builder fluent API.#

<<example-constraintsdefinitionimplementation-validationimplementation-errorbuilder>> shows a few examples.

[[example-constraintsdefinitionimplementation-validationimplementation-errorbuilder]]

.Using the fluent API to build custom constraint violations
====

[source, JAVA]
----
//assuming the following domain model
public class User {
    public Map<String,Address> getAddresses() { [...] }
}

public class Address {
    public String getStreet() { [...] }
    public Country getCountry() { [...] }
}

public class Country {
   public String getName() { [...] }
}

//From a property-level constraint on User.addresses
//Build a constraint violation on the default path - i.e. the "addresses" property
context.buildConstraintViolationWithTemplate( "this detail is wrong" )
            .addConstraintViolation();

//From a class level constraint on Address
//Build a constraint violation on the default path + "street"
//i.e. the street property of Address
context.buildConstraintViolationWithTemplate( "this detail is wrong" )
            .addPropertyNode( "street" )
            .addConstraintViolation();

//From a property-level constraint on  User.addresses
//Build a constraint violation on the default path + the bean stored
//under the "home" key in the map
context.buildConstraintViolationWithTemplate( "Incorrect home address" )
            .addBeanNode()
                .inContainer( Map.class, 1 )
                .inIterable().atKey( "home" )
            .addConstraintViolation();

//From a class level constraint on User
//Build a constraint violation on the default path + addresses["home"].country.name
//i.e. property "country.name" on the object stored under "home" in the map
context.buildConstraintViolationWithTemplate( "this detail is wrong" )
            .addPropertyNode( "addresses" )
            .addPropertyNode( "country" )
                .inContainer( Map.class, 1 )
                .inIterable().atKey( "home" )
            .addPropertyNode( "name" )
            .addConstraintViolation();

//From a class level constraint on User
//Build a constraint violation on the default path + addresses["home"].<map key>
//i.e. a container element constraint violation for the map key
context.buildConstraintViolationWithTemplate( "the map key is invalid" )
            .addPropertyNode( "addresses" )
            .addContainerElementNode( "<map key>", Map.class, 0 )
                .inIterable().atKey( "home" )
            .addConstraintViolation();

//To create a subnode representing a method parameter from a cross-parameter constraint violation

//Cross-parameter constraint on method createUser(String password, String passwordRepeat)
//Build a constraint violation on the default path + "passwordRepeat"
context.buildConstraintViolationWithTemplate("Passwords do not match")
            .addParameterNode( 1 )
            .addConstraintViolation();

//Cross-parameter constraint on a method
//mergeAddresses(Map<String,Address> addresses, Map<String,Address> otherAddresses)
//Build a constraint violation on the default path + "otherAddresses["home"]
//i.e. the Address bean hosted in the "home" key of the "otherAddresses" map parameter
context.buildConstraintViolationWithTemplate(
        "Map entry home present in both and does not match" )
            .addParameterNode( 1 )
            .addBeanNode()
                .inContainer( Map.class, 1 )
                .inIterable().atKey( "home" )
            .addConstraintViolation();

//Cross-parameter constraint on a method
//mergeAddresses(Map<String,Address> addresses, Map<String,Address> otherAddresses)
//Build a constraint violation on the default path + "otherAddresses["home"].city
//i.e. on the "city" property of the Address bean hosted in
//the "home" key of the "otherAddresses" map
context.buildConstraintViolationWithTemplate(
        "Map entry home present in both but city does not match" )
            .addParameterNode( 1 )
            .addPropertyNode( "city" )
                .inContainer( Map.class, 1 )
                .inIterable().atKey( "home" )
            .addConstraintViolation();
----

====

[tck-testable]#If [methodname]`disableDefaultConstraintViolation()` is called, no custom error is added (using the error builder) and if the constraint is not valid, a [classname]`ValidationException` is raised.#

[[constraintsdefinitionimplementation-validationimplementation-temporalvalidators]]

==== Implementation of temporal constraint validators

[tck-testable]#Constraint validators for temporal constraints (either the built-in constraints `@Past`, `@PastOrPresent`, `@Future` and `@FutureOrPresent` or custom temporal constraints) can obtain the current instant from the `ClockProvider` object exposed by `ConstraintValidatorContext#getClockProvider()`.#

[role="api"]
.`ClockProvider` interface
====
[source, JAVA]
----
include::{validation-api-source-dir}jakarta/validation/ClockProvider.java[lines=11..-1]
----
====

[tck-testable]#The `getClock()` method returns a `java.time.Clock` object which represents the current instant, date and time using a time zone.
A conforming {spec-name-bv} implementation provides a default clock provider which returns a clock representing the current system time and default time zone.#
It is recommended that implementations call `Clock#systemDefaultZone()` to obtain the clock.

When bootstrapping a validator factory or validator, an alternative clock provider can be registered (see <<validationapi-bootstrapping>>).
This can for instance be useful for testing, for applying the time zone of the currently logged in user in a multi-user, multi time zone application or for running batch applications with a logical date and time different from the actual current date and time.

[[constraintsdefinitionimplementation-validationimplementation-example]]

==== Examples

.ConstraintValidator implementation
====

[source, JAVA, indent=0]
----
include::{spec-examples-source-dir}org/beanvalidation/specexamples/constraintdefinition/validator/BeginsWithValidator.java[tags=include]
----

====

This [classname]`ConstraintValidator` checks that a String begins with one of the accepted prefixes.
It also demonstrates an interesting best practice: return `true` on a null parameter.

The following listing shows a validator implementing the validation logic for a cross-parameter constraint.

.Cross-parameter validator implementation
====

[source, JAVA, indent=0]
----
include::{spec-examples-source-dir}org/beanvalidation/specexamples/constraintdefinition/validator/DateParametersConsistentValidator.java[tags=include]
----

====

The following listing shows a validator implementing the validation logic for a constraint that is both generic and cross-parameter.

.Generic and cross-parameter validator implementation
====

[source, JAVA]
----
/**
 * Checks that an object passes the Jakarta Expression Language expression
 * provided by the constraint.
 */
@SupportedValidationTarget({ValidationTarget.ANNOTATED_ELEMENT, ValidationTarget.PARAMETERS})
public class ELScriptValidator implements ConstraintValidator<ELScript, Object> {

    public void initialize(ELScript constraint) {
        [...]
    }

    public boolean isValid(Object value, ConstraintValidatorContext context) {
        [...]
    }
}
----

====

The next example shows how to use [classname]`ConstraintValidatorContext`.

.Use of ConstraintValidatorContext
====

[source, JAVA, indent=0]
----
include::{spec-examples-source-dir}org/beanvalidation/specexamples/constraintdefinition/validator/SerialNumberValidator.java[tags=include]
----

====

The default error message is disabled and replaced by a specific error message depending on the type of constraint violation detected.
In this case, only one error report is returned at a given time but a constraint validation implementation can return several error reports.

The following example shows how to obtain the current date and time via the `ClockProvider` when validating a temporal constraint such as `@Past`:

.Validation of a temporal constraint
====

[source, JAVA, indent=0]
----
include::{spec-examples-source-dir}org/beanvalidation/specexamples/constraintdefinition/temporal/PastValidatorForZonedDateTime.java[tags=include]
----

====

[[constraintsdefinitionimplementation-constraintfactory]]

=== The ConstraintValidatorFactory

Constraint validation implementation instances are created by a [classname]`ConstraintValidatorFactory`.

The lifecycle of [classname]`ConstraintValidator` instances is fully dependent of the {spec-name-bv} provider and piloted by the [classname]`ConstraintValidatorFactory` methods. Therefore, [classname]`ConstraintValidatorFactory` implementations (such as dependency injection frameworks) must consider these instances as belonging to a dependent scope. [tck-not-testable]#{spec-name-bv} providers must release each instance retrieved. The [classname]`ConstraintValidatorFactory` instance that has created a [classname]`ConstraintValidator` instance must be the one that releases it. In other words, passing an instance of [classname]`ConstraintValidator` to a [classname]`ConstraintValidatorFactory` that has not created it is an error.#

[NOTE]
====
[classname]`ConstraintValidator` instances created by the [classname]`ValidatorFactory` -level [classname]`ConstraintValidatorFactory` can be released when the [classname]`ValidatorFactory` is being closed.
====

[role="api"]
.`ConstraintValidatorFactory` interface
====

[source, JAVA, indent=0]
----
include::{validation-api-source-dir}jakarta/validation/ConstraintValidatorFactory.java[lines=9..-1]
----

====

[tck-testable]#The default [classname]`ConstraintValidatorFactory` provided by the {spec-name-bv} provider implementation uses the public no-arg constructor of the [classname]`ConstraintValidator` class.# A custom [classname]`ConstraintValidatorFactory` can be provided; for example it may benefit from dependency injection control in constraint implementations (see <<validationapi-bootstrapping-usageandcontainerexpectation>>). Any constraint implementation relying on [classname]`ConstraintValidatorFactory` behaviors specific to an implementation (dependency injection, no no-arg constructor and so on) is not portable, hence great care should be given before walking that path. Make sure to configure the {spec-name-bv} provider to honor any specific needs your [classname]`ConstraintValidator` has. As constraint designer and writer, make sure to document any specific non compliant requirements.

[classname]`ConstraintValidatorFactory` should not cache instances as the state of each instance can be altered in the [methodname]`initialize()` method.

[tck-testable]#If an exception occurs in the factory while retrieving the [classname]`ConstraintValidator` instance, the runtime exception is wrapped in a [classname]`ValidationException`.# [tck-testable]#If the instance returned by the factory is null, a [classname]`ValidationException` is raised.#
