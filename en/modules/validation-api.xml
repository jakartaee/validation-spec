<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"../../docbook-support/support/docbook-dtd/docbookx.dtd" [
<!ENTITY % BOOK_ENTITIES SYSTEM "../global.ent">
%BOOK_ENTITIES;
]>
<chapter id="validationapi">
  <title>Validation APIs</title>

  <para>The default package for the Bean Validation APIs is
  <classname>javax.validation.</classname></para>

  <section id="validationapi-validatorapi">
    <title>Validator API</title>

    <para>The main Bean Validation API is the
    <classname>javax.validation.Validator</classname> interface.</para>

    <para>A <classname>Validator</classname> instance is able to validate
    instances of beans and their associated objects if any. It is recommended
    to leave the caching of <classname>Validator</classname> instances to the
    <classname>ValidatorFactory</classname>. <phrase
    role="tck-not-testable"><classname>Validator</classname> implementations
    are thread-safe.</phrase></para>

    <example revisionflag="changed">
      <title>Validator interface</title>

      <programlisting>/**
 * Validates bean instances. Implementations of this interface must be thread-safe.
 *
 * @author Emmanuel Bernard
 * @author Hardy Ferentschik
 * @author Gunnar Morling
 */
public interface Validator {
    /**
     * Validates all constraints on {@code object}.
     *
     * @param object object to validate
     * @param groups The group or list of groups targeted for validation (defaults to
     * {@link Default}).
     *
     * @return constraint violations or an empty set if none
     *
     * @throws IllegalArgumentException if object is {@code null}
     * or if {@code null} is passed to the varargs groups
     * @throws ValidationException if a non recoverable error happens
     * during the validation process
     */
    &lt;T&gt; Set&lt;ConstraintViolation&lt;T&gt;&gt; validate(T object, Class&lt;?&gt;... groups);

    /**
     * Validates all constraints placed on the property of {@code object}
     * named {@code propertyName}.
     *
     * @param object object to validate
     * @param propertyName property to validate (i.e. field and getter constraints)
     * @param groups The group or list of groups targeted for validation (defaults to
     * {@link Default}).
     *
     * @return constraint violations or an empty set if none
     *
     * @throws IllegalArgumentException if {@code object} is {@code null},
     * if {@code propertyName} is {@code null}, empty or not a valid object property
     * or if {@code null} is passed to the varargs groups
     * @throws ValidationException if a non recoverable error happens
     * during the validation process
     */
    &lt;T&gt; Set&lt;ConstraintViolation&lt;T&gt;&gt; validateProperty(T object,
                                                     String propertyName,
                                                     Class&lt;?&gt;... groups);

    /**
     * Validates all constraints placed on the property named {@code propertyName}
     * of the class {@code beanType} would the property value be {@code value}.
     * &lt;p&gt;
     * {@code ConstraintViolation} objects return {@code null} for
     * {@link ConstraintViolation#getRootBean()} and {@link ConstraintViolation#getLeafBean()}
     * &lt;/p&gt;
     *
     * @param beanType the bean type
     * @param propertyName property to validate
     * @param value property value to validate
     * @param groups The group or list of groups targeted for validation (defaults to
     * {@link Default}).
     *
     * @return constraint violations or an empty set if none
     *
     * @throws IllegalArgumentException if {@code beanType} is {@code null},
     * if {@code propertyName} is {@code null}, empty or not a valid object property
     * or if {@code null} is passed to the varargs groups
     * @throws ValidationException if a non recoverable error happens
     * during the validation process
     */
    &lt;T&gt; Set&lt;ConstraintViolation&lt;T&gt;&gt; validateValue(Class&lt;T&gt; beanType,
                                                  String propertyName,
                                                  Object value,
                                                  Class&lt;?&gt;... groups);

    /**
     * Return the descriptor object describing bean constraints.
     * The returned object (and associated objects including
     * {@code ConstraintDescriptor}s) are immutable.
     *
     * @param clazz class or interface type evaluated
     *
     * @return the bean descriptor for the specified class.
     *
     * @throws IllegalArgumentException if clazz is {@code null}
     * @throws ValidationException if a non recoverable error happens
     * during the metadata discovery or if some
     * constraints are invalid.
     */
    BeanDescriptor getConstraintsForClass(Class&lt;?&gt; clazz);

    /**
     * Return an instance of the specified type allowing access to
     * provider-specific APIs. If the Bean Validation provider
     * implementation does not support the specified class,
     * {@code ValidationException} is thrown.
     *
     * @param type the class of the object to be returned.
     *
     * @return an instance of the specified class
     *
     * @throws ValidationException if the provider does not support the call.
     */
    &lt;T&gt; T unwrap(Class&lt;T&gt; type);

    /**
     * Returns a delegate for validating parameters and return values of methods
     * respectively constructors.
     *
     * @return A delegate for method and constructor validation.
     *
     * @since 1.1
     */
    ExecutableValidator forExecutables();
}</programlisting>
    </example>

    <para revisionflag="added">The methods
    <methodname>validate()</methodname>,
    <methodname>validateProperty()</methodname> and
    <methodname>validateValue()</methodname> are used for the validation of
    Java beans respectively single bean properties. See the next section for
    more details.</para>

    <para revisionflag="added"><methodname>forExecutables()</methodname>
    provides access to a delegate for the validation of method and constructor
    parameters respectively return values. The individual methods for method
    and constructor validation are described in <xref
    linkend="validationapi-validatorapi-methodlevelvalidationmethods"/>.</para>

    <remark revisionflag="added">TODO: Do we find another term than
    "delegate"?</remark>

    <para
    revisionflag="changed"><methodname>getConstraintsForClass()</methodname>
    returns constraint-related metadata for given types and is described in
    detail in <xref linkend="constraintmetadata"/>.</para>

    <para revisionflag="changed"><methodname>unwrap()</methodname> is provided
    as a way to access objects of a given type specific to a Bean Validation
    provider typically as a complement to the <classname>Validator</classname>
    contract. Using this method makes your code non portable.</para>

    <example>
      <title>Using unwrap to access a provider specific contract</title>

      <programlisting>//if using the ACME provider
ACMEValidator acmeValidator = factory.unwrap(ACMEValidator.class);
acmeValidator.setSpecificConfiguration(...);</programlisting>
    </example>

    <section id="validationapi-validatorapi-validationmethods">
      <title>Validation methods</title>

      <para><phrase role="tck-testable"><methodname>&lt;T&gt;
      Set&lt;ConstraintViolation&lt;T&gt;&gt; validate(T object,
      Class&lt;?&gt;... groups)</methodname> is used to validate a given
      object.</phrase> This method implements the logic described in <xref
      linkend="constraintdeclarationvalidationprocess-validationroutine"/>.
      <phrase revisionflag="added" role="tck-testable">An
      <classname>IllegalArgumentException</classname> is thrown when null is
      passed for the <varname>object</varname> parameter or the varargs
      <varname>groups</varname> parameter.</phrase> <phrase
      role="tck-testable">A <classname>Set</classname> containing all
      <classname>ConstraintViolation</classname> objects representing the
      failing constraints is returned, an empty <classname>Set</classname> is
      returned otherwise.</phrase></para>

      <para><phrase role="tck-testable"><methodname>&lt;T&gt;
      Set&lt;ConstraintViolation&lt;T&gt;&gt; validateProperty(T object,
      String propertyName, Class&lt;?&gt;... groups)</methodname> validates a
      given field or property of an object. </phrase><phrase
      revisionflag="added" role="tck-testable">An
      <classname>IllegalArgumentException</classname> is thrown when
      <methodname>validateProperty</methodname> is called and
      <varname>object</varname> is null or <varname>propertyName</varname> is
      null empty or invalid or null is passed to the varargs
      <varname>groups</varname> parameter.</phrase><phrase
      role="tck-testable"> The property name is the JavaBeans property name
      (as defined by the JavaBeans <classname>Introspector</classname>
      class).</phrase> This method implements the logic described in <xref
      linkend="constraintdeclarationvalidationprocess-validationroutine"/> but
      only to the given property. <phrase
      role="tck-testable"><literal>@Valid</literal> is not honored by this
      method.</phrase> This method is useful for partial object
      validation.</para>

      <para><phrase role="tck-testable"><methodname>&lt;T&gt;
      Set&lt;ConstraintViolation&lt;T&gt;&gt; validateValue(Class&lt;T&gt;
      beanType, String propertyName, Object value, Class&lt;?&gt;...
      groups)</methodname> validates the property referenced by
      <parameter>propertyName</parameter> present on
      <literal>beanType</literal> or any of its superclasses, if the property
      value were <parameter>value</parameter>.</phrase> <phrase
      revisionflag="added" role="tck-testable">An
      <classname>IllegalArgumentException</classname> is thrown when
      <methodname>validateValue</methodname> is called and
      <varname>object</varname> is null or <varname>propertyName</varname> is
      null empty or invalid or null is passed to the varargs
      <varname>groups</varname> parameter.</phrase> This method implements the
      logic described in <xref
      linkend="constraintdeclarationvalidationprocess-validationroutine"/> and
      apply it only to the given property and for the given value. <phrase
      role="tck-testable"><literal>@Valid</literal> is not honored by this
      method.</phrase> This method is useful for ahead of time validation
      (i.e. before the JavaBean is populated or updated).</para>

      <note>
        <para>If multiple constrained fields or getters share the same name
        and hide one another in the class hierarchy according to the Java
        visibility rules, the list of constraints evaluated is unspecified.
        This will be clarified in a later version of this specification. Note
        that method overriding is not impacted.</para>

        <para>If getters and fields share the same name and are present at
        different levels of the hierarchy, the list of constraints evaluated
        is unspecified. This will be clarified in a later version of this
        specification.</para>

        <para>However, constraints hosted on the most specific (hierarchy
        wise) element type are always evaluated.</para>
      </note>

      <note>
        <para><methodname>validateProperty</methodname> and
        <methodname>validateValue</methodname> accept property names and not
        full paths. Bean Validation implementations might accept string
        representations of paths but this behavior is not portable.</para>
      </note>

      <para><phrase role="tck-testable">If some unrecoverable failure happens
      during validation, a <classname>ValidationException</classname> is
      raised.</phrase> This exception can be specialized in some situations
      (invalid group definition, invalid constraint definition, invalid
      constraint declaration). See <xref linkend="exception"/> or the relative
      sections for more information).</para>

      <section>
        <title>Examples</title>

        <para>All the examples will be based on the following class
        definition, constraint declarations and address instance.</para>

        <programlisting>public class Address {
    <emphasis role="bold">@NotNull @Size(max=30)</emphasis>
    private String addressline1;

    <emphasis role="bold">@Size(max=30)</emphasis>
    private String addressline2;

    private String zipCode;

    private String city;

    public String getAddressline1() {
        return addressline1;
    }

    public void setAddressline1(String addressline1) {
        this.addressline1 = addressline1;
    }

    public String getAddressline2() {
        return addressline2;
    }

    public void setAddressline2(String addressline2) {
        this.addressline2 = addressline2;
    }

    public String getZipCode() {
        return zipCode;
    }

    public void setZipCode(String zipCode) {
        this.zipCode = zipCode;
    }

    <emphasis role="bold">@Size(max=30) @NotNull</emphasis>
    public String getCity() {
        return city;
    }

    public void setCity(String city) {
        this.city = city;
    }
}

Address address = new Address();
address.setAddressline1( null );
address.setAddressline2( null );
address.setCity("Llanfairpwllgwyngyllgogerychwyrndrobwyll-llantysiliogogogoch");
//town in North Wales</programlisting>

        <para>The following code will return two
        <classname>ConstraintViolation</classname> objects. One for
        <literal>addressline1</literal> violating <literal>@NotNull</literal>
        and one for <literal>city</literal> violating
        <literal>@Size</literal>.</para>

        <programlisting>validator.validate(address).size() == 2</programlisting>

        <para>The following code will return one
        <classname>ConstraintViolation</classname> since
        <literal>city</literal> violates <literal>@Size</literal> and only
        <literal>city</literal> is validated.</para>

        <programlisting>validator.validateProperty(address, "city").size() == 1</programlisting>

        <para>The following code will return no
        <classname>ConstraintViolation</classname> object because the value
        "Paris" for <literal>city</literal> would not raise any constraint
        failure.</para>

        <programlisting>validator.validateValue("city", "Paris").size() == 0</programlisting>
      </section>
    </section>

    <section id="validationapi-validatorapi-methodlevelvalidationmethods"
             revisionflag="added">
      <title>Methods for validating method and constructor constraints</title>

      <para>The methods for the validation of parameters and return values of
      methods and constructors can be found on the interface
      <classname>javax.validation.ExecutableValidator</classname>.</para>

      <example>
        <title>ExecutableValidator interface</title>

        <programlisting>/**
 * Validates parameters and return values of methods and constructors.
 * Implementations of this interface must be thread-safe.
 *
 * @author Gunnar Morling
 * @since 1.1
 */
public interface ExecutableValidator {

    /**
     * Validates all constraints placed on the parameters of the given method.
     *
     * @param &lt;T&gt; The type hosting the method to validate.
     * @param object The object on which the method to validate was invoked.
     * @param method The method for which the parameter constraints shall be validated.
     * @param parameterValues The values provided by the caller for the given method's
     * parameters.
     * @param groups The group or list of groups targeted for validation (defaults to
     * {@link Default}).
     *
     * @return A set with the constraint violations caused by this validation.
     *         Will be empty, if no error occurs, but never {@code null}.
     *
     * @throws IllegalArgumentException if {@code null} is passed for any of the parameters
     * @throws ValidationException if a non recoverable error happens during the
     * validation process
     */
    &lt;T&gt; Set&lt;ConstraintViolation&lt;T&gt;&gt; validateParameters(
        T object, Method method, Object[] parameterValues, Class&lt;?&gt;... groups);

    /**
     * Validates all return value constraints of the given method.
     *
     * @param &lt;T&gt; The type hosting the method to validate.
     * @param object The object on which the method to validate was invoked.
     * @param method The method for which the return value constraints shall be validated.
     * @param returnValue The value returned by the given method.
     * @param groups The group or list of groups targeted for validation (defaults to
     * {@link Default}).
     *
     * @return A set with the constraint violations caused by this validation.
     *         Will be empty, if no error occurs, but never {@code null}.
     *
     * @throws IllegalArgumentException if {@code null} is passed for any of the object,
     * method or groups parameters
     * @throws ValidationException if a non recoverable error happens during the
     * validation process
     */
    &lt;T&gt; Set&lt;ConstraintViolation&lt;T&gt;&gt; validateReturnValue(
        T object, Method method, Object returnValue, Class&lt;?&gt;... groups);

    /**
     * Validates all constraints placed on the parameters of the given constructor.
     *
     * @param &lt;T&gt; The type hosting the constructor to validate.
     * @param constructor The constructor for which the parameter constraints shall be validated.
     * @param parameterValues The values provided by the caller for the given constructor's
     * parameters.
     * @param groups The group or list of groups targeted for validation (defaults to
     * {@link Default}).
     *
     * @return A set with the constraint violations caused by this validation.
     *         Will be empty, if no error occurs, but never {@code null}.
     *
     * @throws IllegalArgumentException if {@code null} is passed for any of the parameters
     * @throws ValidationException if a non recoverable error happens during the
     * validation process
     */
    &lt;T&gt; Set&lt;ConstraintViolation&lt;T&gt;&gt; validateConstructorParameters(
        Constructor&lt;T&gt; constructor, Object[] parameterValues, Class&lt;?&gt;... groups);

    /**
     * Validates all return value constraints of the given constructor.
     *
     * @param &lt;T&gt; The type hosting the constructor to validate.
     * @param constructor The constructor for which the return value constraints shall be validated.
     * @param createdObject The object instantiated by the given method.
     * @param groups The group or list of groups targeted for validation (defaults to
     * {@link Default}).
     *
     * @return A set with the constraint violations caused by this validation.
     *         Will be empty, if no error occurs, but never {@code null}.
     *
     * @throws IllegalArgumentException if {@code null} is passed for any of the parameters
     * @throws ValidationException if a non recoverable error happens during the
     * validation process
     */
    &lt;T&gt; Set&lt;ConstraintViolation&lt;T&gt;&gt; validateConstructorReturnValue(
        Constructor&lt;T&gt; constructor, T createdObject, Class&lt;?&gt;... groups);
}</programlisting>
      </example>

      <para><phrase role="tck-testable"><methodname>&lt;T&gt;
      Set&lt;ConstraintViolation&lt;T&gt;&gt; validateParameters(T object,
      Method method, Object[] parameterValues, Class&lt;?&gt;...
      groups)</methodname> validates the arguments (as given in
      <varname>parameterValues</varname>) for the parameters of a given method
      (identified by <varname>method</varname>).</phrase> <phrase
      role="tck-testable">A set containing all
      <classname>ConstraintViolation</classname> objects representing the
      failing constraints is returned, an empty set is returned if no
      constraint violation occurred. </phrase><phrase role="tck-testable">An
      <classname>IllegalArgumentException</classname> will be thrown if null
      is passed for any of the parameters.</phrase></para>

      <para><phrase role="tck-testable"><methodname>&lt;T&gt;
      Set&lt;ConstraintViolation&lt;T&gt;&gt; validateReturnValue(T object,
      Method method, Object returnValue, Class&lt;?&gt;...
      groups)</methodname> validates the return value (specified by
      <varname>returnValue</varname>) of a given method (identified by
      <varname>method</varname>).</phrase> <phrase role="tck-testable">A set
      containing all <classname>ConstraintViolation</classname> objects
      representing the failing constraints is returned, an empty set is
      returned if no constraint violation occurred.</phrase><phrase
      role="tck-testable"> An <classname>IllegalArgumentException</classname>
      will be thrown if null is passed for any of the parameters
      <varname>object</varname>, <varname>method</varname> and
      <varname>groups</varname>.</phrase></para>

      <para><phrase role="tck-testable"><methodname>&lt;T&gt;
      Set&lt;ConstraintViolation&lt;T&gt;&gt;
      validateConstructorParameters(Constructor&lt;T&gt; constructor, Object[]
      parameterValues, Class&lt;?&gt;... groups)</methodname> validates the
      arguments (as given in <varname>parameterValues</varname>) for the
      parameters of a given constructor (identified by
      <varname>constructor</varname>).</phrase> <phrase role="tck-testable">A
      set containing all <classname>ConstraintViolation</classname> objects
      representing the failing constraints is returned, an empty set is
      returned if no constraint violation occurred.</phrase> <phrase
      role="tck-testable">An <classname>IllegalArgumentException</classname>
      will be thrown if null is passed for any of the
      parameters.</phrase></para>

      <para><phrase role="tck-testable"><methodname>&lt;T&gt;
      Set&lt;ConstraintViolation&lt;T&gt;&gt;
      validateConstructorReturnValue(Constructor&lt;T&gt; constructor, T
      createdObject, Class&lt;?&gt;... groups)</methodname> validates the
      object (specified by <varname>createdObject</varname>) of a given
      constructor (identified by <varname>constructor</varname>).</phrase>
      <phrase role="tck-testable">A set containing all
      <classname>ConstraintViolation</classname> objects representing the
      failing constraints is returned, an empty set is returned if no
      constraint violation occurred.</phrase><phrase role="tck-testable"> An
      <classname>IllegalArgumentException</classname> will be thrown if null
      is passed for any of the parameters.</phrase></para>

      <section>
        <title>Examples</title>

        <para>All the examples will be based on the following class
        definitions, constraint declarations and instances.</para>

        <programlisting>public class OrderService {

    @NotNull
    private CreditCardProcessor creditCardProcessor;

    @Valid
    public OrderService(@NotNull CreditCardProcessor creditCardProcessor) {
        //...
    }

    @NotNull
    public Order placeOrder(
        @NotNull @Size(min=3, max=20) String customerCode,
        @NotNull @Valid Item item,
        @Min(1) int quantity) {

        //...
    }
}

public class Item {

    @NotNull;
    private String name;

    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
}

Item item1 = new Item();
item1.setName("Kiwi");

Item item2 = new Item();
item2.setName(null);

Constructor&lt;OrderService&gt; constructor = ... ; //get constructor object
Method placeOrder = ... ; //get method object

OrderService orderService = new OrderService(new DefaultCreditCardProcessor());

ExecutableValidator executableValidator = Validation
    .buildDefaultValidatorFactory().getValidator().forMethods();</programlisting>

        <para>The following method parameter validation will return one
        <classname>ConstraintViolation</classname> object as the customer code
        is null:</para>

        <programlisting>//orderService.placeOrder(null, item1, 1);
executableValidator.validateParameters(
    orderService, placeOrder, new Object[] { null, item1, 1 }).size() == 1</programlisting>

        <para>The following method parameter validation will return one
        <classname>ConstraintViolation</classname> object as the
        <varname>item</varname> parameter is marked for cascaded validation
        and the given <classname>Item</classname> instance is not valid (its
        name is null):</para>

        <programlisting>//orderService.placeOrder("CUST-123", item2, 1);
executableValidator.validateParameters(
    orderService, placeOrder, new Object[] { "CUST-123", item2, 1 }).size() == 1</programlisting>

        <para>The following constructor parameter validation will return one
        <classname>ConstraintViolation</classname> object as null is passed
        for the <varname>creditCardProcessor</varname> parameter:</para>

        <programlisting>//new OrderService(null);
executableValidator.validateConstructorParameters(constructor, new Object[] { null }).size() == 1</programlisting>

        <para>Assuming the <methodname>placeOrder()</methodname> method
        returned <varname>null</varname>, the following return value
        validation will return one
        <classname>ConstraintViolation</classname>:</para>

        <programlisting>executableValidator.validateReturnValue(orderService, placeOrder, null).size() == 1</programlisting>

        <para>Assuming the constructor of <classname>OrderService</classname>
        failed to store the given credit card processor into the
        <varname>creditCardProcessor</varname>, field the following validation
        of the constructor return value would fail as the constructor is
        marked with <classname>@Valid</classname> and the
        <classname>@NotNull</classname> constraint of the
        <classname>OrderService</classname> class would be violated:</para>

        <programlisting>executableValidator.validateConstructorReturnValue(constructor, orderService).size() == 1</programlisting>

        <para><remark>Do we need more examples?</remark></para>
      </section>
    </section>

    <section id="validationapi-validatorapi-groups">
      <title>groups</title>

      <para revisionflag="changed">Groups allow you to restrict the set of
      constraints applied during validation. Groups targeted are passed as
      parameters to the <methodname>validate</methodname>,
      <methodname>validateProperty</methodname> and
      <methodname>validateValue</methodname> methods as well as the methods to
      validate method/constructor constraints (see <xref
      linkend="validationapi-validatorapi-methodlevelvalidationmethods"/>).
      <phrase role="tck-testable">All constraints belonging to the targeted
      group are applied during the <xref
      linkend="constraintdeclarationvalidationprocess-validationroutine"/>.</phrase>
      <phrase role="tck-testable">If no group is passed, the
      <literal><classname>Default</classname></literal> group is
      assumed.</phrase> <xref
      linkend="constraintsdefinitionimplementation-constraintdefinition-groups"/>
      describes how to define groups on constraints.</para>

      <para><phrase role="tck-not-testable">When more than one group is
      evaluated and passed to the various validate methods, order is not
      constrained.</phrase> It is equivalent to the validation of a group
      <literal>G</literal> inheriting all groups (i.e. implementing all
      interfaces) passed to the validation method.</para>

      <section>
        <title>Examples</title>

        <programlisting>/** Validates a minimal set of constraints */
public interface Minimal {}

public class Address {

    @NotEmpty(groups = Minimal.class)
    @Size(max=50)
    private String street1;
    
    @NotEmpty
    private String city;

    @NotEmpty(groups = {Minimal.class, Default.class})
    private String zipCode;
    ...
}</programlisting>

        <para>In the previous example, <classname>@NotEmpty</classname> (and
        it's composing constraints) on <methodname>street1</methodname>
        applies to the group <classname>Minimal</classname>,
        <classname>@Size</classname> on <methodname>street1</methodname>
        applies to the group <literal>Default</literal> and
        <classname>@NotEmpty </classname>(and it's composing constraints) on
        <methodname>zipCode</methodname> applies to the groups
        <literal><classname>Default</classname></literal> and
        <literal><classname>Minimal</classname></literal>.</para>

        <programlisting>validator.validate(address);</programlisting>

        <para>validates the group <classname>Default</classname> (implicitly)
        and applies <classname>@Size</classname> on
        <methodname>street1</methodname>, <classname>@NotEmpty</classname>
        (and its composing constraints) on <methodname>city</methodname>,
        <classname>@NotEmpty</classname> (and its composing constraints) on
        <methodname>zipCode</methodname>. Particularly,
        <classname>@NotEmpty</classname> (and its composing constraints) on
        <methodname>street1</methodname> are not applied.</para>

        <programlisting>validator.validate(address, Minimal.class);</programlisting>

        <para>applies <classname>@NotEmpty</classname> (and its composing
        constraints) on <methodname>street1</methodname> and
        <classname>@NotEmpty</classname> (and its composing constraints) on
        <methodname>zipCode</methodname> because they belong to the
        <classname>Minimal</classname> group.</para>

        <programlisting>validator.validate(address, Minimal.class, Default.class);</programlisting>

        <para>validates both <classname>Default</classname> and
        <classname>Minimal</classname> groups. The routine applies
        <classname>@NotEmpty</classname> (and its composing constraints) and
        <classname>@Size</classname> on <methodname>street1</methodname>,
        <classname>@NotEmpty</classname> (and its composing constraints) on
        <methodname>city</methodname>, <classname>@NotEmpty</classname> (and
        its composing constraints) on <methodname>zipCode</methodname>. Note
        that if <methodname>zipCode</methodname> is empty, only one
        <classname>ConstraintViolation</classname> object will represent the
        failure and the not empty validation will only be executed
        once.</para>

        <para>Let's look at a more complex example involving group
        sequence.</para>

        <programlisting>public class Address {
    @NotEmpty(groups = Minimal.class)
    @Size(max=50, groups=FirstStep.class)
    private String street1;
    
    @NotEmpty(groups=SecondStep.class)
    private String city;

    @NotEmpty(groups = {Minimal.class, SecondStep.class})
    private String zipCode;
    ...

    public interface FirstStep {}

    public interface SecondStep {}
    
    @GroupSequence({Firststep.class, SecondStep.class})
    public interface Total {}
}</programlisting>

        <para>When running:</para>

        <programlisting>validator.validate(address, Minimal.class, Total.class);</programlisting>

        <para>the validation process will process
        <classname>@NotEmpty</classname> (and it's composing constraints) and
        <classname>@Size</classname> from <methodname>street1</methodname> and
        <classname>@NotEmpty</classname> (and it's composing constraints) from
        <methodname>zipCode</methodname>. If <classname>@Size</classname> from
        <methodname>street1</methodname> does not generate a failure, then
        <classname>@NotEmpty</classname> (and it's composing constraints) from
        <methodname>city</methodname> will be processed as part of
        <classname>SecondStep</classname>. Note that
        <classname>@NotEmpty</classname> (and it's composing constraints) from
        <methodname>zipCode</methodname> are not reprocessed as they have
        already been processed before.</para>

        <para>When running:</para>

        <programlisting>validator.validate(address, Total.class, SecondStep.class);</programlisting>

        <para><classname>@NotEmpty</classname> (and it's composing
        constraints) from <methodname>city</methodname> and
        <classname>@NotEmpty</classname> (and it's composing constraints) from
        <methodname>zipCode</methodname> will be processed even if
        <classname>@Size</classname> from <methodname>street1</methodname>
        fails: while <literal><classname>SecondStep</classname></literal> is
        in the <literal><classname>Total</classname></literal> group sequence
        and hence should not be triggered if
        <literal><classname>FirstStep</classname></literal> has a failure, it
        also has been requested outside the sequence (in this case
        explicitly).</para>

        <note>
          <para>If the group definition is invalid, a
          <classname>GroupDefinitionException</classname> is raised.</para>
        </note>
      </section>
    </section>
  </section>

  <section id="validationapi-constraintviolation">
    <title>ConstraintViolation</title>

    <para><classname>ConstraintViolation</classname> is the class describing a
    single constraint failure. A set of
    <classname>ConstraintViolation</classname> is returned for an object
    validation.</para>

    <programlisting revisionflag="changed">/**
 * Describe a constraint violation. This object exposes the constraint
 * violation context as well as the message describing the violation.
 *
 * @author Emmanuel Bernard
 */
public interface ConstraintViolation&lt;T&gt; {

    /**
     * @return The interpolated error message for this constraint violation.
     */
    String getMessage();

    /**
     * @return The non-interpolated error message for this constraint violation.
     */
    String getMessageTemplate();

    /**
     * @return The root bean being validated. Null when returned by
     *         {@link javax.validation.Validator#validateValue(Class, String, Object, Class[])}
     */
    T getRootBean();

    /**
     * @return The class of the root bean being validated
     */
    Class&lt;T&gt; getRootBeanClass();

    /**
     * If a bean constraint, the bean instance the constraint is applied on
     * If a property constraint, the bean instance hosting the property the
     * constraint is applied on
     *
     * @return the leaf bean the constraint is applied on. Null when returned by
     *         {@link javax.validation.Validator#validateValue(Class, String, Object, Class[])}
     */
    Object getLeafBean();

    /**
     * @return the property path to the value from {@code rootBean}.
     */
    Path getPropertyPath();

    /**
     * Returns the value failing to pass the constraint.
     * For cross-parameter constraints, an {@code Object[]} representing
     * the method invocation arguments is returned.
     *
     * @return the value failing to pass the constraint.
     */
    Object getInvalidValue();

    /**
     * Constraint metadata reported to fail.
     * The returned instance is immutable.
     *
     * @return constraint metadata
     */
    ConstraintDescriptor&lt;?&gt; getConstraintDescriptor();
}</programlisting>

    <para><phrase role="tck-testable">The <methodname>getMessage</methodname>
    method returns the interpolated (localized) message for the failing
    constraint</phrase> (see <xref linkend="validationapi-message"/> for more
    information on message interpolator). This can be used by clients to
    expose user friendly messages.</para>

    <para><phrase role="tck-testable">The
    <methodname>getMessageTemplate</methodname> method returns the
    non-interpolated error message</phrase> (usually the
    <literal>message</literal> attribute on the constraint declaration).
    Frameworks can use this as an error code key.</para>

    <para><phrase role="tck-testable">The <methodname>getRootBean</methodname>
    method returns the root object being validated that led to the failing
    constraint</phrase> (i.e. the object the client code passes to the
    <methodname>Validator.validate</methodname> method).</para>

    <para><phrase role="tck-testable tck-needs-update">The
    <methodname>getInvalidValue</methodname> method returns the value (field,
    property<phrase revisionflag="added">, method/constructor parameter,
    method/constructor return value</phrase> or validated object) being passed
    to <methodname>isValid</methodname>.</phrase> <phrase revisionflag="added"
    role="tck-testable">For a cross-parameter constraint, an
    <code>Object[]</code> representing the method/constructor invocation
    arguments is returned.</phrase></para>

    <para><phrase
    role="tck-testable"><methodname>getConstraintDescriptor</methodname>
    provides access to the failing constraint metadata</phrase> (see <xref
    linkend="constraintmetadata-constraintdescriptor"/>).</para>

    <para role="tck-testable tck-needs-update">The
    <methodname>getPropertyPath</methodname> <phrase
    revisionflag="added">method</phrase> returns the Path object representing
    the navigation path from the root object to the failing object.</para>

    <example revisionflag="changed">
      <title>Path and Node interfaces</title>

      <programlisting>/**
 * Represents the navigation path from an object to another
 * in an object graph.
 * Each path element is represented by a &lt;code&gt;Node&lt;/code&gt;.
 *
 * The path corresponds to the succession of nodes
 * in the order they are returned by the &lt;code&gt;Iterator&lt;/code&gt;
 *
 * @author Emmanuel Bernard
 * @author Gunnar Morling
 */
public interface Path extends Iterable&lt;Path.Node&gt; {

    /**
     * Represents an element of a navigation path.
     */
    interface Node {
        /**
         * Name of the property, constructor, method or parameter which the node
         * represents or null if representing an entity on the leaf node or the
         * return value of a constructor or method (in particular the node in a
         * &lt;code&gt;Path&lt;/code&gt; representing the root object has its name null).
         * 
         * @return Name of the property, constructor, method or parameter which
         *         the node represents
         */
        String getName();

        /**
         * @return true if the node represents an object contained in an Iterable
         * or in a Map.
         */
        boolean isInIterable();

        /**
         * @return The index the node is placed in if contained
         * in an array or List. Null otherwise.
         */
        Integer getIndex();

        /**
         * @return The key the node is placed in if contained
         * in a Map. Null otherwise.
         */
        Object getKey();

        /**
         * Returns a descriptor for the element (bean, property, method etc.)
         * represented by this node. The specific type of the element can be
         * determined using {@link ElementDescriptor#getKind()}.
         *
         * @return An element descriptor for this node.
         */
        ElementDescriptor getElementDescriptor();
    }
}</programlisting>
    </example>

    <para><classname>Path</classname> is made of <classname>Node</classname>s
    and is built according to the following rules:</para>

    <itemizedlist>
      <listitem revisionflag="added">
        <para role="tck-testable">The runtime type is considered, not the
        static type. For example if a property is declared
        <classname>Collection&lt;String&gt;</classname> but its runtime type
        is <classname>ArrayList&lt;String&gt;</classname>, the property is
        considered an <classname>ArrayList&lt;String&gt;</classname>.</para>
      </listitem>

      <listitem>
        <para role="tck-testable tck-needs-update">If the failing object is
        the root object, a <classname>Node</classname> with name set to null
        is added to the <classname>Path</classname>. <phrase
        revisionflag="added">The <classname>Kind</classname> of the node's
        <classname>ElementDescriptor</classname> is
        <varname>Kind.BEAN</varname>. </phrase></para>
      </listitem>

      <listitem>
        <para>When an association is traversed:</para>

        <itemizedlist>
          <listitem>
            <para role="tck-testable tck-needs-update">a
            <classname>Node</classname> object whose <literal>name</literal>
            equals the name of the association property (field name or Java
            Bean property name) is added to <classname>Path</classname>.
            <phrase revisionflag="added">The <classname>Kind</classname> of
            the node's <classname>ElementDescriptor</classname> is
            <varname>Kind.PROPERTY</varname>.</phrase></para>
          </listitem>

          <listitem>
            <para role="tck-testable">if the association is a
            <classname>List</classname> or an array, the following
            <classname>Node</classname> object added contains the index value
            in <methodname>getIndex</methodname>.</para>
          </listitem>

          <listitem>
            <para role="tck-testable">if the association is a
            <classname>Map</classname>, the following
            <classname>Node</classname> object added (representing a given map
            entry) contains the key value in
            <methodname>getKey</methodname></para>
          </listitem>

          <listitem>
            <para role="tck-testable">for all <classname>Iterable</classname>
            or <classname>Map</classname>, the following
            <classname>Node</classname> object added is marked as
            <literal>inIterable</literal>
            (<methodname>isInIterable</methodname>)</para>
          </listitem>
        </itemizedlist>
      </listitem>

      <listitem role="tck-testable tck-needs-update">
        <para>For a property level constraint (field and getter)</para>

        <itemizedlist>
          <listitem>
            <para>a <classname>Node</classname> object is added to
            <classname>Path</classname> whose <literal>name</literal> equals
            the name of the property (field name or Java Bean property name).
            <phrase revisionflag="added">The <classname>Kind</classname> of
            the node's <classname>ElementDescriptor</classname> is
            <varname>Kind.PROPERTY</varname>.</phrase></para>
          </listitem>

          <listitem>
            <para>the property path is considered complete</para>
          </listitem>
        </itemizedlist>
      </listitem>

      <listitem role="tck-testable tck-needs-update">
        <para>For a class level constraint:</para>

        <itemizedlist>
          <listitem>
            <para>a <classname>Node</classname> object is added to
            <classname>Path</classname> whose <literal>name</literal> is null.
            <phrase revisionflag="added">The <classname>Kind</classname> of
            the node's <classname>ElementDescriptor</classname> is
            <varname>Kind.BEAN</varname>.</phrase></para>
          </listitem>

          <listitem>
            <para>the property path is considered complete</para>
          </listitem>
        </itemizedlist>
      </listitem>

      <listitem revisionflag="added">
        <para>For a method/constructor constraint (parameter or return value
        constraint on a method or constructor):</para>

        <itemizedlist>
          <listitem>
            <para role="tck-testable">a <classname>Node</classname> object is
            added to the <classname>Path</classname> which represents the
            validated method or constructor. The <literal>name</literal> of
            the node equals the validated method or constructor, the
            <classname>Kind</classname> of the node's
            <classname>ElementDescriptor</classname> is
            <varname>Kind.METHOD</varname> respectively
            <varname>Kind.CONSTRUCTOR</varname>.</para>
          </listitem>

          <listitem>
            <para role="tck-testable">a <classname>Node</classname> object is
            added to the <classname>Path</classname> which represents the
            validated parameter or return value. In the parameter case, the
            <literal>name</literal> of the node equals the parameter name as
            determined by the current parameter name provider (see <xref
            linkend="constraintdeclarationvalidationprocess-methodlevelconstraints-definingparameterconstraints-namingparameters"/>).
            In the return value case, the <literal>name</literal> of the node
            is null. The <classname>Kind</classname> of the node's
            <classname>ElementDescriptor</classname> is
            <varname>Kind.PARAMETER</varname> respectively
            <varname>Kind.RETURN_VALUE</varname>.</para>
          </listitem>

          <listitem>
            <para role="tck-testable">the property path is considered
            complete</para>
          </listitem>

          <listitem>
            <remark>TODO: Decide what to return for cross-parameter
            constraints. Maybe we could have a
            <classname>CrossParameterDescriptor</classname>/<varname>Kind.CROSS_PARAMETER</varname>?</remark>
          </listitem>
        </itemizedlist>
      </listitem>

      <listitem revisionflag="added">
        <para>If a parameter or the return value of a method or constructor is
        traversed:</para>

        <itemizedlist>
          <listitem>
            <para role="tck-testable">a <classname>Node</classname> object is
            added to the <classname>Path</classname> which represents the
            concerned method or constructor. The <literal>name</literal> of
            the node equals the concerned method or constructor, the
            <classname>Kind</classname> of the node's
            <classname>ElementDescriptor</classname> is
            <varname>Kind.METHOD</varname> respectively
            <varname>Kind.CONSTRUCTOR</varname>.</para>
          </listitem>

          <listitem>
            <para role="tck-testable">a <classname>Node</classname> object is
            added to the <classname>Path</classname> which represents the
            traversed parameter or return value. In the parameter case, the
            <literal>name</literal> of the node equals the parameter name as
            determined by the current parameter name provider. In the return
            value case, the <literal>name</literal> of the node is null. The
            <classname>Kind</classname> of the node's
            <classname>ElementDescriptor</classname> is
            <varname>Kind.PARAMETER</varname> respectively
            <varname>Kind.RETURN_VALUE</varname>.</para>
          </listitem>

          <listitem>
            <para role="tck-testable">if the parameter/return value is a
            <classname>List</classname> or an array, the following
            <classname>Node</classname> object added contains the index value
            in <methodname>getIndex</methodname>.</para>
          </listitem>

          <listitem>
            <para role="tck-testable">if the parameter/return value is a
            <classname>Map</classname>, the following
            <classname>Node</classname> object added (representing a given map
            entry) contains the key value
            in<methodname>getKey</methodname>.</para>
          </listitem>

          <listitem>
            <para role="tck-testable">for all <classname>Iterable</classname>
            or <classname>Map</classname>, the following
            <classname>Node</classname> object added is marked as
            <literal>inIterable</literal>
            (<methodname>isInIterable</methodname>)</para>
          </listitem>
        </itemizedlist>
      </listitem>
    </itemizedlist>

    <note revisionflag="changed">
      <para>A given <classname>Node</classname> object derives its
      <literal>inIterable</literal>, <literal>key</literal> and
      <literal>index</literal> properties from the previous association,
      method parameter or return value traversed.</para>
    </note>

    <note>
      <para>From <methodname>rootBean</methodname> and
      <methodname>propertyPath</methodname>, it is possible to rebuild the
      context of the failure</para>
    </note>

    <note revisionflag="added">
      <para><classname>ConstraintViolation</classname>s occurred during
      standard bean validation can be distinguished from violations occurred
      during method/constructor validation by analyzing the
      <classname>Kind</classname> of the
      <classname>ElementDescriptor</classname> of the first node in the
      violation's property path. In case of method-validation, that
      <classname>Kind</classname> will be either
      <varname>CONSTRUCTOR</varname> or <varname>METHOD</varname>.</para>
    </note>

    <para revisionflag="changed">Let there be the following object
    definitions:</para>

    <example revisionflag="changed">
      <title>Object model definition for examples</title>

      <programlisting>@SecurityChecking
public class Author {
    private String firstName;
    
    @NotEmpty(message="lastname must not be null")
    private String lastName;

    @Size(max=30)
    private String company;
    ...
}

@AvailableInStore(groups={Availability.class})
public class Book {
    @NotEmpty(groups={FirstLevelCheck.class, Default.class})
    private String title;

    @Valid
    @NotNull
    private List&lt;Author&gt; authors;

    @Valid
    private Map&lt;String, Review&gt; reviewsPerSource;

    @Valid
    private Review pickedReview;
    ...
}

public class Review {
    @Min(0) private int rating;
    ...
}

public class Library {

    public Library(@NotNull name, @NotNull location) { ... }

    public void addBook(@NotNull @Valid Book book) { ... }

    public void addAllBooks(@NotNull @Valid List&lt;Book&gt; books) { ... }

    @NotNull public String getLocation() { ... }

    @Valid public Map&lt;Author, Book&gt; getMostPopularBookPerAuthor() { ... }
}</programlisting>
    </example>

    <para revisionflag="changed">Assuming a <classname>Book</classname>
    instance gets validated, the property paths to the different constraints
    would be as described in <xref linkend="table-propertypath"/>:</para>

    <table id="table-propertypath">
      <title>propertyPath examples</title>

      <tgroup cols="2">
        <thead>
          <row>
            <entry>Constraint</entry>

            <entry>propertyPath</entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry><classname>@AvailableInStore</classname> on
            <classname>Book</classname></entry>

            <entry><para>Node(name=null,inIterable=false, index=null,
            key=null<phrase revisionflag="added">,
            elementDescriptor=BeanDescriptor()</phrase>)</para></entry>
          </row>

          <row>
            <entry><classname>@NotEmpty</classname> on
            <classname>Book.title</classname></entry>

            <entry><para>Node(name=title,inIterable=false, index=null,
            key=null<phrase revisionflag="added">,
            elementDescriptor=PropertyDescriptor()</phrase>)</para></entry>
          </row>

          <row>
            <entry><classname>@NotNull</classname> on
            <classname>Book.authors</classname></entry>

            <entry><para>Node(name=authors,inIterable=false, index=null,
            key=null<phrase revisionflag="added">,
            elementDescriptor=PropertyDescriptor()</phrase>)</para></entry>
          </row>

          <row>
            <entry><classname>@SecurityChecking</classname> on the fourth
            author, <classname>Author</classname></entry>

            <entry><para>Node(name=authors,inIterable=false, index=null,
            key=null<phrase revisionflag="added">,
            elementDescriptor=PropertyDescriptor()</phrase>)</para><para>Node(name=null,inIterable=true,
            index=3, key=null<phrase revisionflag="added">,
            elementDescriptor=BeanDescriptor()</phrase>)</para></entry>
          </row>

          <row>
            <entry><classname>@Size</classname> on the fourth author,
            <classname>Author.lastname</classname></entry>

            <entry><para>Node(name=authors,inIterable=false, index=null,
            key=null<phrase revisionflag="added">,
            elementDescriptor=PropertyDescriptor()</phrase>)</para><para>Node(name=lastname,inIterable=true,
            index=4, key=null<phrase revisionflag="added">,
            elementDescriptor=PropertyDescriptor()</phrase>)</para></entry>
          </row>

          <row>
            <entry><classname>@NotEmpty</classname> on the first author,
            <classname>Author.company</classname></entry>

            <entry><para>Node(name=authors,inIterable=false, index=null,
            key=null<phrase revisionflag="added">,
            elementDescriptor=PropertyDescriptor()</phrase>)</para><para>Node(name=company,inIterable=true,
            index=0, key=null<phrase revisionflag="added">,
            elementDescriptor=PropertyDescriptor()</phrase>)</para></entry>
          </row>

          <row>
            <entry><classname>@Min</classname> on the review associated to
            Consumer Report, <classname>Review.rating</classname></entry>

            <entry><para>Node(name=reviewsPerSource,inIterable=false,
            index=null, key=null<phrase revisionflag="added">,
            elementDescriptor=PropertyDescriptor()</phrase>)</para><para>Node(name=rating,inIterable=true,
            index=null, key="Consumer Report"<phrase revisionflag="added">,
            elementDescriptor=PropertyDescriptor()</phrase>)</para></entry>
          </row>

          <row>
            <entry><classname>@Min</classname> on the picked review,
            <classname>Review.rating</classname></entry>

            <entry><para>Node(name=pickedReview,inIterable=false, index=null,
            key=null<phrase revisionflag="added">,
            elementDescriptor=PropertyDescriptor()</phrase>)</para><para>Node(name=rating,inIterable=false,
            index=null, key=null<phrase revisionflag="added">,
            elementDescriptor=PropertyDescriptor()</phrase>)</para></entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <para revisionflag="added">Assuming the constructor and methods of the
    <classname>Library</classname> class are subject to method constraint
    validation, the following property paths would exist for the different
    constraints:</para>

    <para><table id="table-method-level-propertypath" revisionflag="added">
        <title>Property path examples for constrained methods or
        constructors</title>

        <tgroup cols="2">
          <thead>
            <row>
              <entry>Constraint</entry>

              <entry>propertyPath</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><classname>@NotNull</classname> on the <varname>location
              </varname>parameter of the constructor</entry>

              <entry><para>Node(name=Library, inIterable=false, index=null,
              key=null,
              elementDescriptor=ConstructorDescriptor())</para><para>Node(name=arg1,
              inIterable=false, index=null, key=null,
              elementDescriptor=ParameterDescriptor())</para></entry>
            </row>

            <row>
              <entry><classname>@NotNull </classname>on the <varname>book
              </varname>parameter of the <methodname>addBook()</methodname>
              method</entry>

              <entry><para>Node(name=addBook, inIterable=false, index=null,
              key=null,
              elementDescriptor=MethodDescriptor())</para><para>Node(name=arg0,
              inIterable=false, index=null, key=null,
              elementDescriptor=ParameterDescriptor())</para></entry>
            </row>

            <row>
              <entry><classname>@NotEmpty</classname> on
              <classname>Book.title</classname> during validation of
              <methodname>addBook()</methodname></entry>

              <entry><para>Node(name=addBook, inIterable=false, index=null,
              key=null,
              elementDescriptor=MethodDescriptor())</para><para>Node(name=arg0,
              inIterable=false, index=null, key=null,
              elementDescriptor=ParameterDescriptor())</para><para>Node(name=title,
              inIterable=false, index=null, key=null,
              elementDescriptor=PropertyDescriptor())</para></entry>
            </row>

            <row>
              <entry><classname>@NotEmpty</classname> on fourth book,
              <classname>Book.title</classname> during validation of
              <methodname>addAllBooks()</methodname></entry>

              <entry><para>Node(name=addAllBooks, inIterable=false,
              index=null, key=null,
              elementDescriptor=MethodDescriptor())</para><para>Node(name=arg0,
              inIterable=false, index=null, key=null,
              elementDescriptor=ParameterDescriptor())</para><para>Node(name=title,inIterable=true,
              index=3, key=null,
              elementDescriptor=PropertyDescriptor())</para></entry>
            </row>

            <row>
              <entry><classname>@NotNull</classname> on the return value of
              the <methodname>getLocation()</methodname> method</entry>

              <entry><para>Node(name=getLocation, inIterable=false,
              index=null, key=null,
              elementDescriptor=MethodDescriptor())</para><para>Node(name=null,
              inIterable=false, index=null, key=null,
              elementDescriptor=ReturnValueDescriptor())</para></entry>
            </row>

            <row>
              <entry><classname>@NotEmpty</classname> on most popular book of
              author "John Doe", <classname>Book.title</classname> during
              validation of
              <methodname>getMostPopularBookPerAuthor()</methodname></entry>

              <entry><para>Node(name=getMostPopularBookPerAuthor,
              inIterable=false, index=null, key=null,
              elementDescriptor=MethodDescriptor())</para><para>Node(name=null,
              inIterable=false, index=null, key=null,
              elementDescriptor=ReturnValueDescriptor())</para><para>Node(name=title,inIterable=true,
              index=null, key=Author(firstName=John, lastName=Doe),
              elementDescriptor=PropertyDescriptor())</para></entry>
            </row>
          </tbody>
        </tgroup>
      </table><remark>TODO: Add paths for cross-parameter
    constraints.</remark></para>

    <note>
      <para role="tck-not-testable">Bean Validation implementations should
      ensure that a <classname>ConstraintViolation</classname> implementation
      is <classname>Serializable</classname> provided that the root bean, the
      leaf bean, the invalid value and keys in the <classname>Path</classname>
      object are <classname>Serializable</classname> objects.</para>

      <para>If a user wishes to send
      <classname>ConstraintViolation</classname> remotely, it should make sure
      the object graph validated is itself
      <classname>Serializable</classname>.</para>
    </note>

    <section>
      <title>Examples</title>

      <para>These examples assume the following definition of
      <classname>@NotEmpty</classname>.</para>

      <programlisting>package com.acme.constraint;

@Documented
@NotNull
@Size(min=1)
@ReportAsSingleViolation
@Constraint(validatedBy = NotEmpty.NotEmptyValidator.class)
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
public @interface NotEmpty {
    String message() default "{com.acme.constraint.NotEmpty.message}"
    Class&lt;?&gt; groups() default {};
    Class&lt;? extends Payload&gt;[] payload() default {};

    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
    @Retention(RUNTIME)
    @Documented
    @interface List {
        NotEmpty[] value();
    }

    class NotEmptyValidator implements ConstraintValidator&lt;NotEmpty, String&gt; {
        public void initialize(NotEmpty constraintAnnotation) {}

        public boolean isValid(String value, ConstraintValidatorContext context) {
            return true;
        }
    }
}</programlisting>

      <para>and the following class definitions</para>

      <programlisting>public class Author {
    private String firstName;
    
    @NotEmpty(message="lastname must not be null")
    private String lastName;

    @Size(max=30)
    private String company;

    public String getFirstName() {
        return firstName;
    }

    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }

    public String getLastName() {
        return lastName;
    }

    public void setLastName(String lastName) {
        this.lastName = lastName;
    }

    public String getCompany() {
        return company;
    }

    public void setCompany(String company) {
        this.company = company;
    }
}

public class Book {
    @NotEmpty(groups={FirstLevelCheck.class, Default.class})
    private String title;

    @Valid
    @NotNull
    private Author author;

    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public Author getAuthor() {
        return author;
    }

    public void setAuthor(Author author) {
        this.author = author;
    }
}

Author author = new Author();
author.setCompany("ACME");
Book book = new Book();
book.setTitle("");
book.setAuthor(author);

Set&lt;ConstraintViolation&gt; constraintViolations = validator.validate(book);</programlisting>

      <para><classname>ConstraintViolations</classname> is a set of size 2.
      One of the entries represents the failure of
      <literal>@NotEmpty</literal> (or more precisely
      <classname>@Size(min=1)</classname> a composing constraint of
      <classname>@NotEmpty</classname>) on the <literal>title</literal>
      property.</para>

      <para>The <classname>ConstraintViolation</classname> object for this
      failure passes the following assertions:</para>

      <example revisionflag="changed">
        <title>Test assertions on ContraintViolation</title>

        <programlisting>//assuming an english locale, the interpolated message is returned
assert "may not be null or empty".equals( constraintViolation.getMessage() );
assert book == constraintViolation.getRootBean();
assert book == constraintViolation.getLeafBean();

//the offending value
assert book.getTitle().equals( constraintViolation.getInvalidValue() );

//the offending property
Iterator&lt;Node&gt; nodeIter = constraintViolation.getPropertyPath().iterator();
Node node = nodeIter.next();
assert "title".equals( node.getName() );
assert Kind.PROPERTY.equals( node.getElementDescriptor().getKind() );

assert false == nodeIter.hasNext();</programlisting>
      </example>

      <para>The second failure, <literal>@NotEmpty</literal> (or more
      precisely <classname>@NotNull</classname> a composing constraint of
      <classname>@NotEmpty</classname>) on the author's
      <methodname>lastname</methodname>, will produce the
      <classname>ConstraintViolation</classname> object satisfying the
      following assertions:</para>

      <programlisting>assert "lastname must not be null".equals( constraintViolation.getMessage() );
assert book == constraintViolation.getRootBean();
assert author == constraintViolation.getLeafBean();

//the offending value
assert book.getAuthor().getLastName() == constraintViolation.getInvalidValue();

//the offending property
Iterator&lt;Node&gt; nodeIter = constraintViolation.getPropertyPath().iterator();

Node node = nodeIter.next();
assert "author".equals( node.getName() );
assert Kind.PROPERTY.equals( node.getElementDescriptor().getKind() );

node = nodeIter.next();
assert "lastName".equals( node.getName() );
assert Kind.PROPERTY.equals( node.getElementDescriptor().getKind() );

assert false == nodeIter.hasNext();</programlisting>
    </section>

    <section revisionflag="added">
      <title>Examples for method/constructor constraint violations</title>

      <remark>TODO: Add examples for cross-parameter constraints. Do we need
      any more examples here?</remark>

      <para>The following examples assume the constraint, class and object
      definitions given in the previous section. Additionally the following
      class and object definitions are assumed:</para>

      <programlisting>public class Library {

    public void addBook(@NotNull @Valid Book book) { ... }

    @Valid public Map&lt;Author, Book&gt; getMostPopularBookPerAuthor() { ... }
}

Library library = new Library();
author.setLastName("Doe");</programlisting>

      <para>Assuming the following invocation of
      <methodname>addBook()</methodname> is subject to method constraint
      validation:</para>

      <programlisting>library.addBook(null);</programlisting>

      <para>Then one <classname>ConstraintViolation</classname> object would
      be returned by
      <methodname>ExecutableValidator#validateParameters()</methodname> which
      satisfies the following assertions:</para>

      <programlisting>//assuming an english locale, the interpolated message is returned
assert "may not be null".equals( constraintViolation.getMessage() );
assert library == constraintViolation.getRootBean();
assert library == constraintViolation.getLeafBean();

assert null == constraintViolation.getInvalidValue();

Iterator&lt;Node&gt; nodeIter = constraintViolation.getPropertyPath().iterator();

Node node = nodeIter.next();
assert "addBook".equals( node.getName() );
assert Kind.METHOD.equals( node.getElementDescriptor().getKind() );

node = nodeIter.next();
//assuming the default parameter name provider is used
assert "arg0".equals( node.getName() );
assert Kind.PARAMETER.equals( node.getElementDescriptor().getKind() );

assert false == nodeIter.hasNext();</programlisting>

      <para>Assuming the following invocation of
      <methodname>addBook()</methodname> is subject to method constraint
      validation:</para>

      <programlisting>library.addBook(book);</programlisting>

      <para>Then one <classname>ConstraintViolation</classname> object would
      be returned by
      <methodname>ExecutableValidator#validateParameters()</methodname> which
      satisfies the following assertions:</para>

      <programlisting>//assuming an english locale, the interpolated message is returned
assert "may not be null or empty".equals( constraintViolation.getMessage() );
assert library == constraintViolation.getRootBean();
assert book == constraintViolation.getLeafBean();

assert book.getTitle().equals( constraintViolation.getInvalidValue() );

Iterator&lt;Node&gt; nodeIter = constraintViolation.getPropertyPath().iterator();

Node node = nodeIter.next();
assert "addBook".equals( node.getName() );
assert Kind.METHOD.equals( node.getElementDescriptor().getKind() );

node = nodeIter.next();
//assuming the default parameter name provider is used
assert "arg0".equals( node.getName() );
assert Kind.PARAMETER.equals( node.getElementDescriptor().getKind() );

node = nodeIter.next();
assert "title".equals( node.getName() );
assert Kind.PROPERTY.equals( node.getElementDescriptor().getKind() );

assert false == nodeIter.hasNext();</programlisting>

      <para>Assuming the following invocation of
      <methodname>getMostPopularBookPerAuthor()</methodname> is subject to
      method constraint validation and returns a <classname>Map</classname>
      containing one entry with key <varname>author</varname> and value
      <varname>book</varname>:</para>

      <programlisting>Map&lt;Author, Book&gt; mostPopularBookPerAuthor = library.getMostPopularBookPerAuthor();</programlisting>

      <para>Then one <classname>ConstraintViolation</classname> object would
      be returned by
      <methodname>ExecutableValidator#validateReturnValue()</methodname> which
      satisfies the following assertions:</para>

      <programlisting>//assuming an english locale, the interpolated message is returned
assert "may not be null or empty".equals( constraintViolation.getMessage() );
assert library == constraintViolation.getRootBean();
assert book == constraintViolation.getLeafBean();

assert book.getTitle().equals( constraintViolation.getInvalidValue() );

Iterator&lt;Node&gt; nodeIter = constraintViolation.getPropertyPath().iterator();

Node node = nodeIter.next();
assert "getMostPopularBookPerAuthor".equals( node.getName() );
assert Kind.METHOD.equals( node.getElementDescriptor().getKind() );

node = nodeIter.next();
assert null == node.getName();
assert Kind.RETURN_VALUE.equals( node.getElementDescriptor().getKind() );

node = nodeIter.next();
assert "title".equals( node.getName() );
assert Kind.PROPERTY.equals( node.getElementDescriptor().getKind() );
assert author.equals( node.getKey() );
assert true == node.isInIterable();

assert false == nodeIter.hasNext();</programlisting>
    </section>
  </section>

  <section id="validationapi-message">
    <title>Message interpolation</title>

    <para>A message interpolator is responsible for transforming the so called
    message descriptor specified via the message attribute of the constraint
    into a fully expanded, human-readable error message.</para>

    <section id="default-messageresolver" revisionflag="changed">
      <title>Default message interpolation</title>

      <para><phrase role="tck-testable">Every conforming Bean Validation
      implementation includes a default message interpolator which has to
      comply with </phrase>the algorithm defined here to interpolate message
      descriptors. As precondition for message interpolation the following
      applies:</para>

      <itemizedlist>
        <listitem>
          <phrase role="tck-testable">Each constraint defines a message
          descriptor via its <methodname>message</methodname>
          property.</phrase>
        </listitem>

        <listitem>
          <phrase role="tck-testable">Every constraint definition shall define
          a default message descriptor for that constraint.</phrase>
        </listitem>

        <listitem>
          <phrase role="tck-testable">Messages can be overridden at constraint
          declaration time by setting the <methodname>message</methodname>
          property on the constraint.</phrase>
        </listitem>
      </itemizedlist>

      <para><phrase role="tck-testable">The message descriptor is a string
      literal and may contain one or more message parameters or expressions.
      Message parameters and expressions are string literals enclosed in
      <constant>{}</constant> or <constant>${}</constant>
      respectively.</phrase> The following character escaping rules
      apply:</para>

      <itemizedlist>
        <listitem>
          <para role="tck-testable"><code>\{</code> is considered as the
          literal <literal>{</literal> instead of being considered as the
          beginning of a message parameter</para>
        </listitem>

        <listitem>
          <para role="tck-testable"><code>\}</code> is considered as the
          literal <literal>}</literal> instead of being considered as the end
          of a message parameter</para>
        </listitem>

        <listitem>
          <para role="tck-testable"><code>\\</code> is considered as the
          literal <literal>\</literal> instead of being considered as the
          escaping character</para>
        </listitem>

        <listitem>
          <para role="tck-testable"><code>\$</code> is considered as the
          literal <literal>$</literal> instead of being considered as the
          beginning of a message expression</para>
        </listitem>
      </itemizedlist>

      <para>Below are two examples using message parameters and expressions.
      The second is evaluated using Expression Language as defined in <xref
      linkend="message-expressions"/>.</para>

      <example>
        <title>Message using parameters</title>

        <programlisting>Value must be between {min} and {max}</programlisting>
      </example>

      <example>
        <title>Message using expressions</title>

        <programlisting>Must be greater than ${inclusive == true ? 'or equal to ' : ''}{value}</programlisting>
      </example>

      <section id="default-resolution-algorithm">
        <title>Default message interpolation algorithm</title>

        <para>The default message interpolator uses the following
        steps:</para>

        <orderedlist>
          <listitem>
            <para><phrase role="tck-testable">Message parameters are extracted
            from the message string and used as keys to search the
            <classname>ResourceBundle</classname> named
            <literal>ValidationMessages</literal></phrase> (often materialized
            as the property file
            <filename>/ValidationMessages.properties</filename> and its locale
            variations) using the defined locale (see <xref
            linkend="message-interpolation-default-locale"/>). If a property
            is found, the message parameter is replaced with the property
            value in the message string. <phrase role="tck-testable">Step 1 is
            applied recursively until no replacement is performed</phrase>
            (i.e. a message parameter value can itself contain a message
            parameter).</para>
          </listitem>

          <listitem>
            <para><phrase role="tck-testable">Message parameters are extracted
            from the message string and used as keys to search the Bean
            Validation provider's built-in
            <classname>ResourceBundle</classname> using the defined locale
            (see <xref linkend="message-interpolation-default-locale"/>). If a
            property is found, the message parameter is replaced with the
            property value in the message string.</phrase> <phrase
            role="tck-not-testable">Contrary to step 1, step 2 is not
            processed recursively.</phrase></para>
          </listitem>

          <listitem>
            <para><phrase role="tck-not-testable">If step 2 triggers a
            replacement, then step 1 is applied again.</phrase> Otherwise step
            4 is performed.</para>
          </listitem>

          <listitem>
            <para role="tck-testable">Message parameters are extracted from
            the message string. Those matching the name of an attribute of the
            constraint are replaced by the value of that attribute in the
            constraint declaration. Parameter interpolation has precedence
            over message expressions. For example for the message descriptor
            <constant>${value}</constant>, trying to evaluate
            <constant>{value}</constant> as message parameter has precedence
            over evaluating <constant>${value} </constant>as message
            expression.</para>
          </listitem>

          <listitem>
            <para role="tck-testable">Message expressions are extracted from
            the message string and evaluated using Expression Language. See
            also <xref linkend="message-expressions"/>.</para>
          </listitem>
        </orderedlist>

        <note>
          <para>The proposed algorithm ensures that custom resource bundle
          always have priority over built-in resource bundle at all level of
          the recursive resolution. It also ensures that constraint
          declarations attributes values are not interpolated further.</para>
        </note>

        <note>
          <para>The precedence of message parameter over expression
          interpolation ensures backwards compatibility to Bean Validation
          1.0.</para>
        </note>
      </section>

      <section id="message-interpolation-default-locale">
        <title>Locale for default message interpolation</title>

        <para>The locale to be used for message interpolation is defined as
        following:<itemizedlist>
            <listitem>
              <para role="tck-testable">if the locale is passed explicitly to
              the interpolator method via <methodname>interpolate(String,
              Context, Locale)</methodname>, this provided instance is
              used.</para>
            </listitem>

            <listitem>
              <para role="tck-testable">otherwise, the default
              <classname>Locale</classname> as provided by
              <methodname>Locale.getDefault()</methodname> is used.</para>
            </listitem>
          </itemizedlist></para>
      </section>

      <section>
        <title id="message-expressions">Message expressions using Expression
        Language (EL)</title>

        <para><phrase role="tck-testable">The default message interpolation
        allows the use of Expression Language (EL) as defined as </phrase>in
        JSR 341. <phrase role="tck-testable">Expressions to be evaluated by EL
        need to be enclosed in <constant>${}</constant> within the message
        descriptor</phrase>. The following properties and beans have to be
        made available in the EL context:</para>

        <para><itemizedlist>
            <listitem>
              <para role="tck-testable">the attribute values of the constraint
              declaration mapped to their attribute name</para>
            </listitem>

            <listitem>
              <para role="tck-testable">the validated value mapped under the
              name <constant>validatedValue</constant>.</para>
            </listitem>

            <listitem>
              <para role="tck-testable">a bean mapped to the name
              <constant>formatter</constant> exposing the vararg method
              <methodname>format(String format, Object... args)</methodname>.
              This method must behave like
              <methodname>java.util.Formatter#format(String format, Object...
              args)</methodname>. The locale used for formatting is defined by
              <xref linkend="message-interpolation-default-locale"/>. The
              <constant>formatter</constant> bean allows to format property
              values, for example in the case of the validated value being
              98.12345678, <constant>${formatter.format("%1$2f",
              validatedValue}</constant> would format it to 98.12 (two digits
              after the decimal point, where the use of '.' vs ',' would be
              locale specific).</para>
            </listitem>
          </itemizedlist>If an exception occurs during message interpolation,
        e.g. due invalid expressions or references to an unknown property, the
        message expression stays unchanged.</para>
      </section>
    </section>

    <section id="custom-message-resolution">
      <title>Custom message interpolation</title>

      <para>A custom message interpolator may be provided (e.g., to
      interpolate contextual data, or to adjust the default <classname>Locale
      </classname>used). A message interpolator implements the
      <classname>MessageInterpolator</classname> interface.</para>

      <programlisting>/**
 * Interpolate a given constraint violation message.
 * Implementations should be as tolerant as possible on syntax errors.
 *
 * @author Emmanuel Bernard
 * @author Hardy Ferentschik
 */
public interface MessageInterpolator {
    /**
     * Interpolate the message template based on the contraint validation context.
     * The locale is defaulted according to the &lt;code&gt;MessageInterpolator&lt;/code&gt;
     * implementation. See the implementation documentation for more detail.
     *
     * @param messageTemplate The message to interpolate.
     * @param context contextual information related to the interpolation
     *
     * @return Interpolated error message.
     */
    String interpolate(String messageTemplate, Context context);

    /**
     * Interpolate the message template based on the contraint validation context.
     * The &lt;code&gt;Locale&lt;/code&gt; used is provided as a parameter.
     *
     * @param messageTemplate The message to interpolate.
     * @param context contextual information related to the interpolation
     * @param locale the locale targeted for the message
     *
     * @return Interpolated error message.
     */
    String interpolate(String messageTemplate, Context context,  Locale locale);

    /**
     * Information related to the interpolation context
     */
    interface Context {
        /**
         * @return ConstraintDescriptor corresponding to the constraint being validated
         */
        ConstraintDescriptor&lt;?&gt; getConstraintDescriptor();

        /**
         * @return value being validated
         */
        Object getValidatedValue();
    }
}</programlisting>

      <para><parameter>messageTemplate</parameter> is the value of the
      <literal>message</literal> attribute of the constraint declaration or
      provided to the <classname>ConstraintValidatorContext</classname>
      methods.</para>

      <para>The <classname>Context</classname> object contains contextual
      information related to the interpolation.</para>

      <para><parameter>getConstraintDescriptor</parameter> is the
      <classname>ConstraintDescriptor</classname> object representing the
      metadata of the failing constraint (see <xref
      linkend="constraintmetadata"/>).</para>

      <para><parameter>getValidatedValue</parameter> is the value being
      validated.</para>

      <para><methodname>MessageInterpolator.interpolate(String,
      Context)</methodname> is invoked for each constraint violation report
      generated. The default <classname>Locale</classname> is implementation
      specific.</para>

      <para><methodname>MessageInterpolator.interpolate(String, Context,
      Locale)</methodname> can be invoked by a wrapping
      <classname>MessageInterpolator</classname> to enforce a specific
      <classname>Locale</classname> value by bypassing or overriding the
      default <classname>Locale</classname> strategy (see <xref
      linkend="validationapi-message-examples-specificlocale"/>).</para>

      <para role="tck-not-testable">A message interpolator implementation
      shall be thread-safe.</para>

      <para>The message interpolator is provided to the
      <classname>ValidatorFactory</classname> at construction time using
      <methodname>Configuration.messageInterpolator(MessageInterpolator)</methodname>.
      This message interpolator is shared by all
      <classname>Validator</classname> objects generated by this
      <classname>ValidatorFactory</classname>.</para>

      <para role="tck-testable">It is possible to override the
      <classname>MessageInterpolator</classname> implementation for a given
      <classname>Validator</classname> instance by invoking
      <methodname>ValidatorFactory.usingContext().messageInterpolator(messageInterpolator).getValidator()</methodname>.</para>

      <para>It is recommended that <classname>MessageInterpolator</classname>
      implementations delegate final interpolation to the Bean Validation
      default <classname>MessageInterpolator</classname> to ensure standard
      Bean Validation interpolation rules are followed, The default
      implementation is accessible through
      <methodname>Configuration.getDefaultMessageInterpolator()</methodname>.</para>

      <para>If the interpolation process leads to an exception, the exception
      is wrapped into a <classname>ValidationException</classname>.</para>
    </section>

    <section id="validationapi-message-examples">
      <title>Examples</title>

      <para>These examples describe message interpolation based on the default
      message interpolator's built-in messages (see <xref
      linkend="standard-resolver-messages"/>), and the
      <filename>ValidationMessages.properties</filename> file shown in table
      <xref linkend="table-messageinterpolation"/>. The current locale is
      assumed English.</para>

      <programlisting>//ValidationMessages.properties
myapp.creditcard.error=credit card number not valid</programlisting>

      <table id="table-messageinterpolation">
        <title>message interpolation</title>

        <tgroup cols="2">
          <colspec align="center"/>

          <tbody>
            <row>
              <entry>Failing constraint declaration</entry>

              <entry>interpolated message</entry>
            </row>

            <row>
              <entry><classname>@NotNull</classname></entry>

              <entry>must not be null</entry>
            </row>

            <row>
              <entry><classname>@Max(30)</classname></entry>

              <entry>must be less than or equal to 30</entry>
            </row>

            <row>
              <entry><classname>@Size(min=5, max=15, message="Key must have
              \\{{min}\\} \\ \\{{max}\\} characters")</classname></entry>

              <entry>Key must have {5} \ {15} characters</entry>
            </row>

            <row>
              <entry><classname>@Digits(integer=9,
              fraction=2)</classname></entry>

              <entry>numeric value out of bounds (&lt;9 digits&gt;.&lt;2
              digits&gt; expected)</entry>
            </row>

            <row>
              <entry><classname>@CreditCard(message={myapp.creditcard.error})</classname></entry>

              <entry>credit card number not valid</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>Here is an approach to specify the <classname>Locale</classname>
      value to choose on a given <classname>Validator</classname>.
      <classname>Locale</classname> aware
      <classname>MessageInterpolator</classname>. See <xref
      linkend="bootstrapping"/> for more details on the APIs.</para>

      <example id="validationapi-message-examples-specificlocale">
        <title>Use MessageInterpolator to use a specific Locale value</title>

        <programlisting>/**
 * delegates to a MessageInterpolator implementation but enforce a given Locale
 */
public class LocaleSpecificMessageInterpolator implements MessageInterpolator {
    private final MessageInterpolator defaultInterpolator;
    private final Locale defaultLocale;

    public LocaleSpecificMessageInterpolator(MessageInterpolator interpolator, Locale locale) {
        this.defaultLocale = locale;
        this.defaultInterpolator = interpolator;
    }

    /**
     * enforece the locale passed to the interpolator
     */
    public String interpolate(String message, 
                              Context context) {
        return defaultInterpolator.interpolate(message, 
                                               context, 
                                               this.defaultLocale);
    }

    // no real use, implemented for completeness
    public String interpolate(String message,
                              Context context,
                              Locale locale) {
        return defaultInterpolator.interpolate(message, context, locale);
    }
}


Locale locale = getMyCurrentLocale();
MessageInterpolator interpolator = new LocaleSpecificMessageInterpolator(
                                       validatorFactory.getMessageInterpolator(),
                                       locale);

Validator validator = validatorFactory.usingContext()
                                      .messageInterpolator(interpolator)
                                      .getValidator();</programlisting>
      </example>

      <para>Most of the time, however, the relevant
      <classname>Locale</classname> will be provided by your application
      framework transparently. This framework will implement its own version
      of <classname>MessageInterpolator</classname> and pass it during the
      <classname>ValidatorFactory</classname> configuration. The application
      will not have to set the <classname>Locale</classname> itself. This
      example shows how a container framework would implement
      <classname>MessageInterpolator</classname> to provide a user specific
      default locale.</para>

      <example id="validationapi-message-examples-jsflocale">
        <title>Contextual container possible
        <classname>MessageInterpolator</classname> implementation</title>

        <programlisting>public class ContextualMessageInterpolator implements MessageInterpolator {
    private final MessageInterpolator delegate;

    public ContextualMessageInterpolator(MessageInterpolator delegate) { 
        this.delegate = delegate; 
    }

    public String interpolate(String message, Context context) {
        Locale locale = Container.getManager().getUserLocale();
        return this.delegate.interpolate(
                        message, context, locale );
    }

    public String interpolate(String message, Context context, Locale locale) {
        return this.delegate.interpolate(message, context, locale);
    }
}


//Build the ValidatorFactory
Configuration&lt;?&gt; configuration = Validation.byDefaultProvider().configure();
ValidatorFactory factory = configuration
    .messageInterpolator( 
        new ContextualMessageInterpolator( 
                configuration.getDefaultMessageInterpolator() ) )
    .buildValidatorFactory();

//The container uses the factory to validate constraints using the specific MessageInterpolator
Validator validator = factory.getValidator();</programlisting>
      </example>
    </section>
  </section>

  <section id="validationapi-triggeringmethodvalidation" revisionflag="added">
    <title>Triggering method validation</title>

    <para>Bean Validation itself doesn't trigger the evaluation of method
    constraints. That is, just annotating any methods or constructors with
    parameter or return value constraints doesn't automatically enforce these
    constraints, just as annotating any fields or properties with bean
    constraints doesn't enforce these either.</para>

    <para>Instead method constraints must be validated by invoking the
    appropriate methods on
    <classname>javax.validation.ExecutableValidator</classname>. Typically
    this won't happen by manually calling these methods but rather
    automatically upon invocation of the constrained methods or constructors,
    using approaches and techniques such as CDI/EJB interceptors,
    aspect-oriented programming or dynamic proxies.</para>

    <para>The validation of method / constructor constraints comprises the
    following steps:</para>

    <itemizedlist>
      <listitem>
        <para>Intercept the method call to be validated</para>
      </listitem>

      <listitem>
        <para>Validate the parameter values provided by the method caller
        using
        <methodname>ExecutableValidator#validateParameters()</methodname> or
        <methodname>ExecutableValidator#validateConstructorParameters()</methodname>.</para>
      </listitem>

      <listitem>
        <para>If this validation yields a non-empty set of constraint
        violations, throw a
        <classname>ConstraintViolationException</classname> wrapping the
        violations. Otherwise proceed with the actual method
        invocation.</para>
      </listitem>

      <listitem>
        <para>Validate the result returned by the invoked method using
        <methodname>ExecutableValidator#validateReturnValue()</methodname> or
        <methodname>ExecutableValidator#validateConstructorReturnValue()</methodname>.</para>
      </listitem>

      <listitem>
        <para>If this validation yields a non-empty set of constraint
        violations, throw a
        <classname>ConstraintViolationException</classname> wrapping the
        violations. Otherwise return the invocation result to the method
        caller.</para>
      </listitem>
    </itemizedlist>

    <para>By throwing a <classname>ConstraintViolationException</classname> if
    either of the validation steps fails, it is ensured that the control
    flow</para>

    <itemizedlist>
      <listitem>
        <para>only arrives at the method's body if the caller has satisfied
        the method's preconditions and</para>
      </listitem>

      <listitem>
        <para>only returns to the method caller if the method's postconditions
        are guaranteed.</para>
      </listitem>
    </itemizedlist>

    <para>By default, integrators should intercept and validate all methods
    hosting either a constraint or cascading constraint violation
    (<classname>@Valid</classname>) whether it be on the method itself or on
    any of its parameters. The <classname>Default</classname> group should be
    used for validation out of the box.</para>

    <para>Integrators are encouraged to use Bean Validation's metadata API to
    find whether or not a method or a constructor should be intercepted. This
    guarantees that XML descriptors as well as future mapping strategies are
    taken into account. Here is an example of what such usage would be:</para>

    <example>
      <title>Using metadata API to figure out if method interception is
      required</title>

      <programlisting>//For methods

// is there any constrained method on this type
public boolean interceptMethods(Class&lt;?&gt; type) {
    return validator.getConstraintsForClass( type ).getConstrainedMethods().size() &gt; 0;
}

// is this method constrained
public boolean interceptMethod(Class&lt;?&gt; type, Method method) {
    BeanDescriptor bean = validator.getConstraintsForClass( type );
    MethodDescriptor methodDescriptor = bean.getConstraintsForMethod(
        method.getName(), method.getParameterTypes() );
    return methodDescriptor != null;
}

// should method parameters be validated
public boolean requiresParametersValidation(Class&lt;?&gt; type, Method method) {
    BeanDescriptor bean = validator.getConstraintsForClass( type );
    MethodDescriptor methodDescriptor = bean.getConstraintsForMethod(
        method.getName(), method.getParameterTypes() );
    if ( methodDescriptor != null ) {
        return methodDescriptor.areParametersConstrained();
    }
    else {
        return false;
    }
}

// should method return value be validated?
public boolean requiresReturnValueValidation(Class&lt;?&gt; type, Method method) {
    BeanDescriptor bean = validator.getConstraintsForClass( type );
    MethodDescriptor methodDescriptor = bean.getConstraintsForMethod(
        method.getName(), method.getParameterTypes() );
    if ( methodDescriptor != null ) {
        return methodDescriptor.isReturnValueConstrained();
    }
    else {
        return false;
    }
}</programlisting>
    </example>

    <example>
      <title>Using metadata API to figure out if constructor interception is
      required</title>

      <programlisting>//For constructors

// is there any constrained constructor on this type
public &lt;T&gt; boolean interceptConstructors(Class&lt;T&gt; type) {
    BeanDescriptor bean = validator.getConstraintsForClass( type );
    return bean.getConstrainedConstructors().size() &gt; 0;
}

// is this constructor constrained
public &lt;T&gt; boolean interceptConstructor(Class&lt;T&gt; type, Constructor&lt;T&gt; ctor) {
    BeanDescriptor bean = validator.getConstraintsForClass( type );
    ConstructorDescriptor constructorDescriptor = bean.getConstraintsForConstructor(
        ctor.getParameterTypes() );
    return constructorDescriptor != null;
}

// should constructor parameters be validated
public &lt;T&gt; boolean requiresParametersValidation(Class&lt;T&gt; type, Constructor&lt;T&gt; ctor) {
    BeanDescriptor bean = validator.getConstraintsForClass( type );
    ConstructorDescriptor constructorDescriptor = bean.getConstraintsForConstructor(
        ctor.getParameterTypes() );
    if ( constructorDescriptor != null ) {
        return constructorDescriptor.areParametersConstrained();
    }
    else {
        return false;
    }
}

// should constructor return value be validated?
public boolean requiresReturnValueValidation(Class&lt;?&gt; type, Constructor&lt;T&gt; ctor) {
    BeanDescriptor bean = validator.getConstraintsForClass( type );
    ConstructorDescriptor constructorDescriptor = bean.getConstraintsForConstructor(
        ctor.getName(), 
        ctor.getParameterTypes()
    );
    if ( constructorDescriptor != null ) {
        return constructorDescriptor.isReturnValueConstrained();
    }
    else {
        return false;
    }
}</programlisting>
    </example>

    <note>
      <para>Calls to the metadata API is likely only going to be needed during
      the initialization phase of the interception framework. Results can then
      be cached.</para>
    </note>

    <note>
      <para>Only methods or constructors intercepted by the underlying
      interception technology can be validated.</para>
    </note>

    <para>The integration technology must put the validation interceptor as
    late as possible (if not last) in the interception stack. In particular,
    validation of parameters should be done after the security and transaction
    start logic. Likewise, return value validation should be done before the
    transaction stop logic. Putting the validation interceptor as late as
    possible in the stack ensures this.</para>

    <note>
      <title>Why have the validation interceptor after other
      interceptors?</title>

      <para>There are several reasons for delaying validation compared to
      other interceptors:</para>

      <itemizedlist>
        <listitem>
          <para>You don't want to start business code before security has been
          cleared</para>
        </listitem>

        <listitem>
          <para>You might need transaction support in your validations</para>
        </listitem>

        <listitem>
          <para>You want transaction to fail if the return value is
          invalid</para>
        </listitem>

        <listitem>
          <para>Generally speaking, it makes more sense to apply technical
          layers around the more business focused constraints</para>
        </listitem>
      </itemizedlist>
    </note>

    <section>
      <title>PROPOSAL: customizing method interception</title>

      <para>By default, all constrained methods (that can be intercepted) are
      validated using the default group.</para>

      <para>You can customize whether or not a method is validated and which
      group is used via the <classname>MethodValidationActivator</classname>
      and <classname>MethodValidationGroupSelector</classname> contracts and
      providing implementations to the Bean Validation bootstrap or via the
      XML deployment descriptor.</para>

      <example>
        <title>MethodValidationActivator contract</title>

        <programlisting language="JAVA" role="JAVA">/**
 * Decides if constraints of a given method should be validated
 * 
 * @author Emmanuel Bernard
 */
interface MethodValidationActivator {
    boolean activateMethodValidation(Method method):
    boolean activateConstructorValidation(Constructor constructor);
}</programlisting>
      </example>

      <example>
        <title>MethodValidationGroupSelector contract</title>

        <programlisting language="JAVA" role="JAVA">/**
 * Provides the (set of) groups that should be used when validating the
 * given constrained method.
 * 
 * @author Emmanuel Bernard
 */
interface MethodValidationGroupSelector {
    Class&lt;?&gt;[] selectGroupsForMethod(Method method):
    Class&lt;?&gt;[] selectGroupsForConstructor(Constructor constructor);
}</programlisting>
      </example>

      <para>The components <classname>MethodValidationActivator</classname>
      and <classname>MethodValidationGroupSelector</classname> are accepting
      injection points in a container environment (CDI in particular).
      Implementations must be thread-safe.</para>

      <para>Method and constructor validations can be globally disabled via
      the XML configuration descriptor by using the
      <literal>disable-method-validation</literal> element. Likewise, you can
      disable validation for a specific method / constructor or for all
      methods / constructors of a given bean by using the
      <literal>disable-method-validation</literal> attribute on the respective
      elements.</para>

      <remark>TODO: should we change the boolean disable-method-validation
      with the following enum based method-validation: NONE, PARAMETERS,
      RETURN_VALUE, ALL. What would be the use case for PARAMETERS /
      RETURN_VALUE? We could also use the enum but restrict it to NONE and ALL
      to plan for the future.</remark>

      <para>Here are a few use cases :</para>

      <itemizedlist>
        <listitem>
          <para>choose a different group depending on the caller stack: a
          batch input might want different validation than a user input</para>
        </listitem>

        <listitem>
          <para>choose a different group depending on a specific context: if a
          user is flagged as rogue, enforce more constraints</para>
        </listitem>

        <listitem>
          <para>disable validations for a given deployment as it is considered
          a "safe" environment</para>
        </listitem>

        <listitem>
          <para>disable a specific method validation for development purposes
          either via a custom
          <classname>MethodValidationGroupSelector</classname> implementation
          or via the XML deployment descriptor</para>
        </listitem>
      </itemizedlist>

      <para>Context or caller stack implementations can be implemented in a
      couple of ways:</para>

      <itemizedlist>
        <listitem>
          <para>use a thread local variable to carry the groups</para>
        </listitem>

        <listitem>
          <para>use a request scoped CDI component to carry the groups: this
          component being injected in the
          <classname>MethodValidationGroupSelector</classname>
          implementation.</para>
        </listitem>
      </itemizedlist>

      <para>Should we provide in the CDI integration a way to customize the
      group via an annotation? An annotation in the caller stack would set the
      expected group. This would resurrect the
      <classname>@MethodValidated</classname> annotation but not on the
      validated method itself.</para>
    </section>
  </section>

  <section id="bootstrapping">
    <title>Bootstrapping</title>

    <para>The bootstrapping API aims at providing a
    <classname>ValidatorFactory</classname> object which is used to create
    <classname>Validator</classname> instances. The bootstrap process is
    decoupled from the provider implementation initialization: <phrase
    role="tck-testable">a bootstrap implementation must be able to bootstrap
    any Bean Validation provider implementation.</phrase> The bootstrap
    sequence has been designed to achieve several goals:</para>

    <itemizedlist>
      <listitem>
        <para>plug multiple implementations</para>
      </listitem>

      <listitem>
        <para>choose a specific implementation</para>
      </listitem>

      <listitem>
        <para>extensibility: an application using a specific provider
        implementation can use specific configurations</para>
      </listitem>

      <listitem>
        <para>share and reuse of metadata across
        <classname>Validator</classname>s</para>
      </listitem>

      <listitem>
        <para>leave as much freedom as possible to implementations</para>
      </listitem>

      <listitem>
        <para revisionflag="changed">provide integration mechanisms to Java EE
        (starting from version 6) and other containers</para>
      </listitem>

      <listitem>
        <para>type safety</para>
      </listitem>
    </itemizedlist>

    <para>The main artifacts involved in the bootstrap process are:</para>

    <itemizedlist>
      <listitem>
        <para><classname>Validation</classname>: API entry point. Lets you
        optionally define the Bean Validation provider targeted as well as a
        provider resolution strategy. <classname>Validation</classname>
        generates <classname>Configuration</classname> objects and can
        bootstrap any provider implementation.</para>
      </listitem>

      <listitem>
        <para><classname>ValidationProvider</classname>: contract between the
        bootstrap procedure and a Bean Validation provider
        implementation.</para>
      </listitem>

      <listitem>
        <para><classname>ValidationProviderResolver</classname>: returns a
        list of all Bean Validation providers available in the execution
        context (generally the classpath).</para>
      </listitem>

      <listitem>
        <para><classname>Configuration</classname>: collects the configuration
        details that will be used to build
        <classname>ValidatorFactory</classname>. A specific sub interface of
        <classname>Configuration</classname> must be provided by Bean
        Validation providers. This sub interface typically hosts provider
        specific configurations.</para>
      </listitem>

      <listitem>
        <para><classname>ValidatorFactory</classname>: result of the bootstrap
        process. Build <classname>Validator</classname> instances from a given
        Bean Validation provider.</para>
      </listitem>

      <listitem>
        <para><filename>META-INF/validation.xml</filename>: a configuration
        file, Bean Validation users can use to customize the configuration of
        the default <classname>ValidatorFactory</classname>.</para>
      </listitem>
    </itemizedlist>

    <para>Let's first see the API in action through some examples before
    diving into the concrete definitions.</para>

    <section>
      <title>Examples</title>

      <para>The most simple approach is to initialize the default Bean
      Validation provider or the one defined in the XML configuration file.
      The <classname>ValidatorFactory</classname> is then ready to provide
      <classname>Validator</classname> instances.</para>

      <example revisionflag="changed">
        <title>Simple Bean Validation bootstrap sequence</title>

        <programlisting>ValidatorFactory factory = Validation.buildDefaultValidatorFactory();

//cache the factory somewhere
Validator validator = factory.getValidator();

//when the application shuts down, close ValidatorFactory
factory.close()</programlisting>
      </example>

      <para><phrase role="tck-not-testable">The
      <classname>ValidatorFactory</classname> object is thread-safe.</phrase>
      Building <classname>Validator</classname> instances is typically a cheap
      operation. Building a <classname>ValidatorFactory</classname> is
      typically more expensive. Make sure to check your Bean Validation
      implementation documentation for more accurate details.</para>

      <para>The second example shows how a container can customize some Bean
      Validator resource handling to match its own behavior.</para>

      <example revisionflag="changed">
        <title>Customize message resolution, traversable resolver, constraint
        Validator factory and parameter name provider implementation</title>

        <programlisting>//some customization from a container
ValidatorFactory factory = Validation
       .byDefaultProvider().configure()
          .messageInterpolator( new ContainerMessageInterpolator() )
          .constraintValidatorFactory( new ContainerComponentConstraintValidatorFactory() )
          .traversableResolver( new JPAAwareTraversableResolver() )
          .parameterNameProvider( new AnnotationBasedParameterNameProvider() )
          .buildValidatorFactory();

//cache the factory somewhere
Validator validator = factory.getValidator();

//when the application shuts down, close ValidatorFactory
factory.close()</programlisting>
      </example>

      <para>The third example shows how to bootstrap Bean Validation in an
      environment not following the traditional Java classloader strategies
      (such as tools or alternative service containers like OSGi). They can
      provider some alternative provider resolution strategy to discover Bean
      Validation providers.</para>

      <example revisionflag="changed">
        <title>Customize the Bean Validation provider resolution
        mechanism</title>

        <programlisting>//osgi environment
ValidatorFactory factory = Validation
       .byDefaultProvider()
          .providerResolver( new OSGiServiceDiscoverer() )
          .configure()
             .buildValidatorFactory();

//cache the factory somewhere
Validator validator = factory.getValidator();

//when the bundle shuts down, close ValidatorFactory
factory.close()</programlisting>
      </example>

      <para>The next example shows how a client can choose a specific Bean
      Validation provider and configure provider specific properties
      programmatically in a type-safe way.</para>

      <example>
        <title>Use a specific provider and add specific configuration</title>

        <programlisting>ValidatorFactory factory = Validation
       .byProvider( ACMEProvider.class )  //chose a specific provider
       .configure()
          .messageInterpolator( new ContainerMessageInterpolator() ) //default configuration option
          .addConstraint(Address.class, customConstraintDescriptor) //ACME specific method
          .buildValidatorFactory();

//same initialization decomposing calls
ACMEConfiguration acmeConfiguration = Validation
       .byProvider( ACMEProvider.class )
       .configure();

ValidatorFactory factory = acmeConfiguration
          .messageInterpolator( new ContainerMessageInterpolator() ) //default configuration option
          .addConstraint(Address.class, customConstraintDescriptor) //ACME specific method
          .buildValidatorFactory();

/**
 * ACME specific validator configuration and configuration options
 */
public interface ACMEConfiguration extends Configuration&lt;ACMEConfiguration&gt; {
    /**
     * Programmatically add constraints. Specific to the ACME provider.
     */
    ACMEConfiguration addConstraint(Class&lt;?&gt; entity, 
                                    ACMEConstraintDescriptor constraintDescriptor);
}

/**
 * ACME validation provider
 * Note how ACMEConfiguration and ACMEProvider are linked together 
 * via the generic parameter.
 */
public class ACMEProvider implements ValidationProvider&lt;ACMEConfiguration&gt; {
    ...
}</programlisting>
      </example>

      <para>The last example shows how a <classname>Validator</classname> can
      use a specific <classname>MessageInterpolator</classname>
      implementation</para>

      <example>
        <title>Use a specific MessageInterpolator instance for a given
        Validator</title>

        <programlisting>ValidatorFactory factory = ...;
MessageInterpolator customInterpolator = new LocaleSpecificMessageInterpolator(
    locale, 
    factory.getMessageInterpolator()
);

Validator localizedValidator = 
    factory.usingContext()
                   .messageInterpolator(customInterpolator)
                   .getValidator();</programlisting>
      </example>

      <para>In the same way, a custom
      <classname>TraversableResolver</classname> can be passed.</para>

      <para>We will now explore the various interfaces, their constraints and
      usage. We will go from the <classname>ValidatorFactory</classname> to
      the <classname>Validation</classname> class walking up the bootstrap
      chain.</para>
    </section>

    <section>
      <title>ValidatorFactory</title>

      <para revisionflag="changed"><classname>ValidatorFactory</classname>
      objects build and provide initialized instances of
      <classname>Validator</classname> to Bean Validation clients. Each
      <classname>Validator</classname> instance is configured for a given
      context (message interpolator, traversable resolver). Clients should
      cache <classname>ValidatorFactory</classname> objects and reuse them for
      optimal performances. The API is designed to allow implementors to share
      constraint metadata in <classname>ValidatorFactory</classname>.
      <classname>ValidatorFactory</classname> instances must be closed (by
      calling the <methodname>close()</methodname> method) by its creator when
      no longer in use.</para>

      <para><classname>ValidatorFactory</classname> implementations must be
      thread-safe. <classname>ValidatorFactory</classname> implementations can
      cache <classname>Validator</classname> instances if needed.</para>

      <example revisionflag="changed">
        <title>ValidatorFactory interface</title>

        <programlisting>/**
 * Factory returning initialized {@code Validator} instances.
 *
 * Implementations are thread-safe and instances are typically cached and reused.
 *
 * @author Emmanuel Bernard
 * @author Gunnar Morling
 * @author Hardy Ferentschik
 */
public interface ValidatorFactory {
    /**
     * Returns an initialized {@code Validator} instance using the
     * factory defaults for message interpolator, traversable resolver
     * and constraint validator factory.
     * &lt;p&gt;
     * Validator instances can be pooled and shared by the implementation.
     * &lt;/p&gt;
     *
     * @return an initialized {@code Validator} instance
     */
    Validator getValidator();

    /**
     * Defines a new validator context and return a {@code Validator}
     * compliant this new context.
     *
     * @return a {@code ValidatorContext} instance
     */
    ValidatorContext usingContext();

    /**
     * Returns the {@code MessageInterpolator} instance configured at
     * initialization time for the {@code ValidatorFactory}.
     * This is the instance used by {@link #getValidator()}.
     *
     * @return MessageInterpolator instance
     */
    MessageInterpolator getMessageInterpolator();

    /**
     * Returns the {@code TraversableResolver} instance configured
     * at initialization time for the {@code ValidatorFactory}.
     * This is the instance used by {@link #getValidator()}.
     *
     * @return TraversableResolver instance
     */
    TraversableResolver getTraversableResolver();

    /**
     * Returns the {@code ConstraintValidatorFactory} instance
     * configured at initialization time for the
     * {@code ValidatorFactory}.
     * This is the instance used by #getValidator().
     *
     * @return ConstraintValidatorFactory instance
     */
    ConstraintValidatorFactory getConstraintValidatorFactory();

    /**
     * Returns the {@code ParameterNameProvider} instance configured at
     * initialization time for the {@code ValidatorFactory}.
     * This is the instance used by #getValidator().
     *
     * @return ParameterNameProvider instance
     */
    ParameterNameProvider getParameterNameProvider();
 
    /**
     * Returns an instance of the specified type allowing access to
     * provider-specific APIs. If the Bean Validation provider
     * implementation does not support the specified class, a
     * {@code ValidationException} is thrown.
     *
     * @param type the class of the object to be returned
     *
     * @return an instance of the specified class
     *
     * @throws ValidationException if the provider does not
     * support the call.
     */
    public &lt;T&gt; T unwrap(Class&lt;T&gt; type);

    /**
     * Close the {@code ValidatorFactory} instance.
     *
     * After the {@code ValidatorFactory} instance is closed, it is not allowed to call:
     * &lt;ul&gt;
     * &lt;li&gt;methods of this {@code ValidatorFactory} instance&lt;/li&gt;
     * &lt;li&gt;methods of {@code Validator} instances created by this {@code ValidatorFactory}&lt;/li&gt;
     * &lt;/ul&gt;
     */
    public void close();
}</programlisting>
      </example>

      <para>A <classname>ValidatorFactory</classname> is provided by a
      <classname>Configuration</classname> object.</para>

      <para><methodname>unwrap</methodname> is provided as a way to access
      objects of a given type specific to a Bean Validation provider typically
      as a complement to the <classname>ValidatorFactory</classname> contract.
      Using this method makes your code non portable.</para>

      <para revisionflag="added"><methodname>close</methodname> closes the
      <classname>ValidatorFactory</classname> instance which becomes
      unavailable and should be immediately discarded. This is also true of
      all the <classname>Validator</classname> instances it has
      spawned.</para>

      <example>
        <title>Using unwrap to access a provider specific contract</title>

        <programlisting>//if using the ACME provider
ACMEValidatorFactory acmeFactory = factory.unwrap(ACMEValidatorFactory.class);
acmeFactory.setSpecificConfiguration(...);</programlisting>
      </example>

      <para><phrase
      role="tck-testable"><methodname>getMessageInterpolator()</methodname>
      returns the <classname>MessageInterpolator</classname> instance
      configured during the initialization of the
      <classname>ValidatorFactory</classname>.</phrase> It is particularly
      useful to build a <classname>Validator</classname> specific
      <classname>MessageInterpolator</classname> wrapping the one from the
      <classname>ValidatorFactory</classname>.</para>

      <para><methodname>getTraversableResolver()</methodname> returns the
      <classname>TraversableResolver</classname> instance configured during
      the initialization of the <classname>ValidatorFactory</classname>. It is
      particularly useful to build a <classname>Validator</classname> specific
      <classname>TraversableResolver</classname> wrapping the one from the
      <classname>ValidatorFactory</classname>.</para>

      <para><methodname>getConstraintValidatorFactory()</methodname> returns
      the <classname>ConstraintValidatorFactory</classname> instance
      configured during the initialization of the
      <classname>ValidatorFactory</classname>. It is particularly useful to
      build a <classname>Validator</classname> specific
      <classname>ConstraintValidatorFactory</classname> wrapping the one from
      the <classname>ValidatorFactory</classname>.</para>

      <para revisionflag="added"><phrase
      role="tck-testable"><methodname>getParameterNameProvider()</methodname>
      returns the <classname>ParameterNameProvider</classname> instance
      configured during the initialization of the
      <classname>ValidatorFactory</classname>.</phrase> It is particularly
      useful to build a <classname>Validator</classname> specific
      <classname>ParameterNameProvider</classname> wrapping the one from the
      <classname>ValidatorFactory</classname>.</para>

      <para><classname>ValidatorContext</classname> returned by
      <methodname>usingContext</methodname> can be used to customize the state
      in which the <classname>Validator</classname> must be initialized. This
      is used to customize the <classname>MessageInterpolator</classname>, the
      <classname>TraversableResolver</classname> or the
      <classname>ConstraintValidatorFactory</classname>.</para>

      <example revisionflag="changed">
        <title>ValidatorContext interface</title>

        <programlisting>/**
 * Represents the context that is used to create &lt;code&gt;Validator&lt;/code&gt;
 * instances.
 *
 * A client may use methods of the &lt;code&gt;ValidatorContext&lt;/code&gt; returned by
 * &lt;code&gt;ValidatorFactory#usingContext&lt;/code&gt; to customize
 * the context used to create &lt;code&gt;Validator&lt;/code&gt; instances
 * (for instance establish different message interpolators or
 * traversable resolvers).
 * 
 * @author Emmanuel Bernard
 * @author Gunnar Morling
 */
public interface ValidatorContext {
    /**
     * Defines the message interpolator implementation used by the
     * &lt;code&gt;Validator&lt;/code&gt;.
     * If not set or if null is passed as a parameter,
     * the message interpolator of the &lt;code&gt;ValidatorFactory&lt;/code&gt;
     * is used.
     *
     * @return self following the chaining method pattern
     */
    ValidatorContext messageInterpolator(MessageInterpolator messageInterpolator);

    /**
     * Defines the traversable resolver implementation used by the
     * &lt;code&gt;Validator&lt;/code&gt;.
     * If not set or if null is passed as a parameter,
     * the traversable resolver of the &lt;code&gt;ValidatorFactory&lt;/code&gt; is used.
     *
     * @return self following the chaining method pattern
     */
    ValidatorContext traversableResolver(TraversableResolver traversableResolver);

    /**
     * Defines the constraint validator factory implementation used by the
     * &lt;code&gt;Validator&lt;/code&gt;.
     * If not set or if null is passed as a parameter,
     * the constraint validator factory of the &lt;code&gt;ValidatorFactory&lt;/code&gt; is used.
     *
     * @return self following the chaining method pattern
     */
    ValidatorContext constraintValidatorFactory(ConstraintValidatorFactory factory);

    /**
     * Defines the parameter name provider implementation used by the
     * &lt;code&gt;Validator&lt;/code&gt;. If not set or if null is passed as a parameter,
     * the parameter name provider of the &lt;code&gt;ValidatorFactory&lt;/code&gt; is used.
     *
     * @param parameterNameProvider Parameter name provider implementation.
     *
     * @return self following the chaining method pattern
     */
    ValidatorContext parameterNameProvider(ParameterNameProvider parameterNameProvider);

    /**
     * @return an initialized &lt;code&gt;Validator&lt;/code&gt; instance respecting the defined state.
     * Validator instances can be pooled and shared by the implementation.
     */
    Validator getValidator();
}</programlisting>
      </example>

      <para revisionflag="changed" role="tck-testable tck-needs-update">The
      <classname>MessageInterpolator</classname>, the
      <classname>TraversableResolver</classname>, the
      <classname>ConstraintValidatorFactory</classname> or the
      <classname>ParameterNameProvider</classname> passed to the
      <classname>ValidatorContext</classname> are used instead of the
      <classname>ValidatorFactory</classname>'s
      <classname>MessageInterpolator</classname>,
      <classname>TraversableResolver</classname>,
      <classname>ConstraintValidatorFactory</classname> or
      <classname>ParameterNameProvider</classname> instances.</para>

      <example>
        <title>Use of ValidatorFactory</title>

        <programlisting>ValidatorFactory factory = ...
Validator validatorUsingDefaults = factory.getValidator();
Validator validatorUsingCustomTraversable = factory
                     .usingContext()
                     .traversableResolver( new JPATraversableResolver() )
                     .getValidator();</programlisting>
      </example>

      <para>See <xref
      linkend="validationapi-message-examples-specificlocale"/> for an example
      using
      <methodname>ValidatorFactory.getMessageInterpolator()</methodname>.</para>
    </section>

    <section>
      <title>Configuration</title>

      <para revisionflag="changed">The responsibility of the
      <classname>Configuration</classname> is to collect configuration
      information, to determine the correct provider implementation and to
      delegate the <classname>ValidatorFactory</classname> creation to the
      seleced provider. More concretely <classname>Configuration</classname>
      lets you define:</para>

      <itemizedlist>
        <listitem>
          <para revisionflag="changed">the message interpolator
          instance</para>
        </listitem>

        <listitem>
          <para revisionflag="changed">the traversable resolver
          instance</para>
        </listitem>

        <listitem>
          <para>the constraint validator factory instance</para>
        </listitem>

        <listitem revisionflag="added">
          <para>the parameter name provider instance</para>
        </listitem>

        <listitem>
          <para>XML constraint mappings</para>
        </listitem>

        <listitem>
          <para>provider specific properties</para>
        </listitem>

        <listitem>
          <para revisionflag="changed">whether or not
          <classname>META-INF/validation.xml</classname> is considered</para>
        </listitem>
      </itemizedlist>

      <para><classname>Configuration</classname> does provide a
      <classname>MessageInterpolator</classname> implementation following the
      default Bean Validation <classname>MessageInterpolator</classname> rules
      as defined in <xref linkend="default-messageresolver"/>. You can access
      it by calling <methodname>getDefaultMessageInterpolator()</methodname>.
      Such an implementation is useful to let a custom
      <classname>MessageInterpolator</classname> delegate to the standard
      <classname>MessageInterpolator</classname> (see <xref
      linkend="custom-message-resolution"/> and an example making use of
      <methodname>getDefaultMessageInterpolator()</methodname> in <xref
      linkend="validationapi-message-examples-jsflocale"/>).</para>

      <para><classname>Configuration</classname> does provide a
      <classname>TraversableResolver</classname> implementation following the
      default Bean Validation <classname>TraversableResolver</classname> rules
      as defined in <xref
      linkend="constraintdeclarationvalidationprocess-validationroutine-traversable"/>.
      You can access it by calling
      <methodname>getDefaultTraversableResolver()</methodname>. Such an
      implementation is useful to let a custom
      <classname>TraversableResolver</classname> delegate to the standard
      <classname>TraversableResolver</classname>.</para>

      <para><classname>Configuration</classname> does provide a
      <classname>ConstraintValidatorFactory</classname> implementation
      following the default Bean Validation
      <classname>ConstraintValidatorFactory</classname> rules as defined in
      <xref linkend="constraintsdefinitionimplementation-constraintfactory"/>.
      You can access it by calling
      <methodname>getDefaultConstraintValidatorFactory()</methodname>. Such an
      implementation is useful to let a custom
      <classname>ConstraintValidatorFactory</classname> delegate to the
      standard <classname>ConstraintValidatorFactory</classname>.</para>

      <para revisionflag="added"><phrase
      role="tck-testable"><classname>Configuration</classname> does provide a
      <classname>ParameterNameProvider</classname> implementation following
      the default Bean Validation <classname>ParameterNameProvider</classname>
      rules as defined in <xref
      linkend="constraintdeclarationvalidationprocess-methodlevelconstraints-definingparameterconstraints-namingparameters"/>.
      You can access it by calling
      <methodname>getDefaultParameterNameProvider()</methodname></phrase>.
      Such an implementation is useful to let a custom
      <classname>ParameterNameProvider</classname> delegate to the standard
      <classname>ParameterNameProvider</classname>.</para>

      <para revisionflag="added"><phrase role="tck-testable">Via
      <classname>getBootstrapConfiguration()</classname>,
      <classname>Configuration</classname> also exposes data stored in
      <classname>META-INF/validation.xml</classname></phrase> (see <xref
      linkend="xml-config"/>). This is particularly useful for containers
      wishing to control the instance creation and life cycle (more
      information at <xref
      linkend="bootstrapping-usageandcontainerexpectation"/>).</para>

      <para revisionflag="added"><phrase role="tck-testable">Using
      <methodname>addMapping()</methodname>, additional constraint mapping XML
      descriptors can be added to the configuration</phrase> (see <xref
      linkend="xml-config"/>). The given input streams should support the
      <methodname>mark()</methodname> and <methodname>reset()</methodname>
      methods defined by <classname>java.io.InputStream</classname>. <phrase
      role="tck-testable">Streams not supporting the
      <methodname>mark()</methodname> and <methodname>reset()</methodname>
      methods will be wrapped with an <classname>InputStream</classname>
      implementation supporting these methods by the Bean Validation provider
      in order to allow the streams to be read several times.</phrase></para>

      <para>Clients call
      <methodname>Configuration.buildValidatorFactory()</methodname> to
      retrieve the initialized <classname>ValidatorFactory</classname>
      instance.<phrase revisionflag="added" role="tck-testable"> It is legal
      to invoke <methodname>buildValidatorFactory()</methodname> several
      times, e.g. in order to retrieval several
      <classname>ValidatorFactory</classname> instances with a slightly
      different configuration (see <xref
      linkend="using-configuration-several-times"/>).</phrase></para>

      <example revisionflag="changed">
        <title>Configuration and BootstrapConfiguration interfaces</title>

        <programlisting>package javax.validation;

/**
 * Receives configuration information, selects the appropriate
 * Bean Validation provider and builds the appropriate {@code ValidatorFactory}.
 * &lt;p/&gt;
 * Usage:
 * &lt;pre&gt;
 * {@code
 * Configuration&lt;?&gt; configuration = //provided by one of the Validation bootstrap methods
 *     ValidatorFactory = configuration
 *         .messageInterpolator( new CustomMessageInterpolator() )
 *         .buildValidatorFactory();}
 * &lt;/pre&gt;
 * &lt;p/&gt;
 * By default, the configuration information is retrieved from
 * &lt;i&gt;META-INF/validation.xml&lt;/i&gt;.
 * It is possible to override the configuration retrieved from the XML file
 * by using one or more of the {@code Configuration} methods.
 * &lt;p/&gt;
 * The {@link ValidationProviderResolver} is specified at configuration time
 * (see {@link javax.validation.spi.ValidationProvider}).
 * If none is explicitly requested, the default {@code ValidationProviderResolver} is used.
 * &lt;p/&gt;
 * The provider is selected in the following way:
 * &lt;ul&gt;
 * &lt;li&gt;if a specific provider is requested programmatically using
 * {@code Validation.byProvider(Class)}, find the first provider implementing
 * the provider class requested and use it&lt;/li&gt;
 * &lt;li&gt;if a specific provider is requested in &lt;i&gt;META-INF/validation.xml&lt;/i&gt;,
 * find the first provider implementing the provider class requested and use it&lt;/li&gt;
 * &lt;li&gt;otherwise, use the first provider returned by the {@code ValidationProviderResolver}&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;p/&gt;
 * Implementations are not meant to be thread-safe.
 *
 * @author Emmanuel Bernard
 * @author Gunnar Morling
 * @author Hardy Ferentschik
 */
public interface Configuration&lt;T extends Configuration&lt;T&gt;&gt; {

    /**
     * Ignore data from the &lt;i&gt;META-INF/validation.xml&lt;/i&gt; file if this
     * method is called.
     * This method is typically useful for containers that parse
     * &lt;i&gt;META-INF/validation.xml&lt;/i&gt; themselves and pass the information
     * via the {@code Configuration} methods.
     *
     * @return {@code this} following the chaining method pattern.
     */
    T ignoreXmlConfiguration();

    /**
     * Defines the message interpolator used. Has priority over the configuration
     * based message interpolator.
     * If {@code null} is passed, the default message interpolator is used
     * (defined in XML or the specification default).
     *
     * @param interpolator message interpolator implementation.
     *
     * @return {@code this} following the chaining method pattern.
     */
    T messageInterpolator(MessageInterpolator interpolator);

    /**
     * Defines the traversable resolver used. Has priority over the configuration
     * based traversable resolver.
     * If {@code null} is passed, the default traversable resolver is used
     * (defined in XML or the specification default).
     *
     * @param resolver traversable resolver implementation.
     *
     * @return {@code this} following the chaining method pattern.
     */
    T traversableResolver(TraversableResolver resolver);

    /**
     * Defines the constraint validator factory. Has priority over the configuration
     * based constraint factory.
     * If null is passed, the default constraint validator factory is used
     * (defined in XML or the specification default).
     *
     * @param constraintValidatorFactory constraint factory implementation.
     *
     * @return {@code this} following the chaining method pattern.
     */
    T constraintValidatorFactory(ConstraintValidatorFactory constraintValidatorFactory);

    /**
     * Defines the parameter name provider. Has priority over the configuration
     * based provider.
     * If null is passed, the default parameter name provider is used
     * (defined in XML or the specification default).
     *
     * @param parameterNameProvider Parameter name provider implementation.
     *
     * @return {@code this} following the chaining method pattern.
     */
    T parameterNameProvider(ParameterNameProvider parameterNameProvider);

    /**
     * Add a stream describing constraint mapping in the Bean Validation XML
     * format.
     * &lt;p/&gt;
     * The stream should be closed by the client API after the
     * {@code ValidatorFactory} has been built. The Bean Validation provider
     * must not close the stream.
     *
     * @param stream
     *            XML mapping stream. The given stream should support the
     *            mark/reset contract (see {@link InputStream#markSupported()}).
     *            If it doesn't, it will be wrapped into a stream supporting the
     *            mark/reset contract by the Bean Validation provider.
     *
     * @return {@code this} following the chaining method pattern.
     *
     * @throws IllegalArgumentException
     *             if {@code stream} is null
     */
    T addMapping(InputStream stream);

    /**
     * Add a provider specific property. This property is equivalent to
     * XML configuration properties.
     * If the underlying provider does not know how to handle the property,
     * it must silently ignore it.
     * &lt;p/&gt;
     * Note: Using this non type-safe method is generally not recommended.
     * &lt;p/&gt;
     * It is more appropriate to use, if available, the type-safe equivalent provided
     * by a specific provider via its {@code Configuration} subclass.
     * &lt;pre&gt;{@code ValidatorFactory factory = Validation.byProvider(ACMEProvider.class)
     * .configure()
     * .providerSpecificProperty(ACMEState.FAST)
     * .buildValidatorFactory();}
     * &lt;/pre&gt;
     * This method is typically used by containers parsing &lt;i&gt;META-INF/validation.xml&lt;/i&gt;
     * themselves and injecting the state to the Configuration object.
     * &lt;p/&gt;
     * If a property with a given name is defined both via this method and in the
     * XML configuration, the value set programmatically has priority.
     * &lt;p/&gt;
     * If null is passed as a value, the value defined in XML is used. If no value
     * is defined in XML, the property is considered unset.
     *
     * @param name property name.
     * @param value property value.
     *
     * @return {@code this} following the chaining method pattern.
     *
     * @throws IllegalArgumentException if {@code name} is null
     */
    T addProperty(String name, String value);

    /**
     * Return an implementation of the {@code MessageInterpolator} interface
     * following the default {@code MessageInterpolator} defined in the
     * specification:
     * &lt;ul&gt;
     * &lt;li&gt;use the ValidationMessages resource bundle to load keys&lt;/li&gt;
     * &lt;li&gt;use Locale.getDefault()&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @return default MessageInterpolator implementation compliant with the specification
     */
    MessageInterpolator getDefaultMessageInterpolator();

    /**
     * Return an implementation of the {@code TraversableResolver} interface
     * following the default {@code TraversableResolver} defined in the
     * specification:
     * &lt;ul&gt;
     * &lt;li&gt;if Java Persistence is available in the runtime environment,
     * a property is considered reachable if Java Persistence considers
     * the property as loaded&lt;/li&gt;
     * &lt;li&gt;if Java Persistence is not available in the runtime environment,
     * all properties are considered reachable&lt;/li&gt;
     * &lt;li&gt;all properties are considered cascadable.&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @return default TraversableResolver implementation compliant with the specification
     */
    TraversableResolver getDefaultTraversableResolver();

    /**
     * Return an implementation of the {@code ConstraintValidatorFactory} interface
     * following the default {@code ConstraintValidatorFactory} defined in the
     * specification:
     * &lt;ul&gt;
     * &lt;li&gt;uses the public no-arg constructor of the {@code ConstraintValidator}&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @return default ConstraintValidatorFactory implementation compliant with the specification
     */
    ConstraintValidatorFactory getDefaultConstraintValidatorFactory();

    /**
     * Return an implementation of the {@code ParameterNameProvider}
     * interface following the default {@code ParameterNameProvider}
     * defined in the specification:
     * &lt;ul&gt;
     * &lt;li&gt;returns names in the form {@code arg&amp;lt;PARAMETER_INDEX&amp;gt;}
     * where {@code PARAMETER_INDEX} starts at 0 for the first parameter,
     * e.g. {@code arg0}, {@code arg1} etc.&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @return default ParameterNameProvider implementation compliant with
     *         the specification
     */
    ParameterNameProvider getDefaultParameterNameProvider();

    /**
     * Return configuration information stored in the &lt;i&gt;META-INF/validation.xml&lt;/i&gt; file.
     * &lt;p/&gt;
     * &lt;b&gt;Note&lt;/b&gt;:&lt;br/&gt;
     * Implementations are encouraged to lazily build this object to delay parsing.
     *
     * @return Returns an instance of {@code BootstrapConfiguration}. This method returns never {@code null}. If there
     *         is no &lt;i&gt;META-INF/validation.xml&lt;/i&gt; the different getters of the returned instance will return {@code null} respective
     *         the empty set or map.
     */
    BootstrapConfiguration getBootstrapConfiguration();

    /**
     * Build a {@code ValidatorFactory} implementation.
     *
     * @return ValidatorFactory
     *
     * @throws ValidationException if the ValidatorFactory cannot be built
     */
    ValidatorFactory buildValidatorFactory();
}</programlisting>

        <programlisting revisionflag="added">package javax.validation;

/**
 * Represents the user specified default configuration in &lt;i&gt;META-INF/validation.xml&lt;/i&gt;.
 *
 * @author Emmanuel Bernard &lt;emmanuel@hibernate.org&gt;
 * @author Gunnar Morling
 * @author Hardy Ferentschik
 */
public interface BootstrapConfiguration {
    /**
     * Class name of the {@code ValidationProvider} implementation
     * or {@code null} if none is specified.
     *
     * @return validation provider class name
     */
    public String getDefaultProviderClassName();

    /**
     * Class name of the {@code ConstraintValidatorFactory} implementation
     * or {@code null} if none is specified.
     *
     * @return constraint validator factory class name
     */
    public String getConstraintValidatorFactoryClassName();

    /**
     * Class name of the {@code MessageInterpolator} implementation
     * or {@code null} if none is specified.
     *
     * @return message interpolator class name or {@code null}
     */
    public String getMessageInterpolatorClassName();

    /**
     * Class name of the {@code TraversableResolver} implementation
     * or {@code null} if none is specified.
     *
     * @return traversable resolver class name or {@code null}
     */
    public String getTraversableResolverClassName();

    /**
     * Class name of the {@code ParameterNameProvider} implementation
     * or {@code null} if none is specified.
     *
     * @return parameter name provider class name or {@code null}
     */
    public String getParameterNameProviderClassName();

    /**
     * Returns a set of resource paths pointing to XML constraint mapping files.
     * The set is empty if none are specified.
     *
     * @return set of constraint mapping resource paths
     */
    public Set&lt;String&gt; getConstraintMappingResourcePaths();

    /**
     * Returns properties as a map of string based key/value pairs.
     * The map is empty if no property has been specified.
     *
     * @return the properties map
     */
    public Map&lt;String, String&gt; getProperties();
}
</programlisting>
      </example>

      <para><phrase role="tck-testable">A Bean Validation provider must define
      a sub interface of <classname>Configuration</classname> uniquely
      identifying the provider.</phrase> This subclass is linked to its
      provider via the <classname>ValidationProvider</classname> generic
      parameter. The <classname>Configuration</classname> sub interface
      typically hosts provider specific configuration methods.</para>

      <para>To facilitate the use of provider specific configuration methods,
      <classname>Configuration</classname> uses generics:
      <classname>Configuration&lt;T extends
      Configuration&lt;T&gt;&gt;</classname> ; the generic return type
      <classname>T</classname> is returned by chaining methods. The provider
      specific sub interface must resolve the generic T as itself as shown in
      <xref linkend="example-providerspecific-config"/>.</para>

      <example id="example-providerspecific-config">
        <title>Example of provider specific Configuration sub
        interface</title>

        <programlisting>/**
 * Unique identifier of the ACME provider
 * also hosts some provider specific configuration methods
 */
public interface ACMEConfiguration 
    extends Configuration&lt;ACMEConfiguration&gt; {

    /**
     * Enables constraints implementation dynamic reloading when using ACME
     * default to false
     */
    ACMEConfiguration enableDynamicReloading(boolean);

}</programlisting>
      </example>

      <para>When
      <methodname>Configuration.buildValidatorFactory()</methodname> is
      called, the initialized <classname>ValidatorFactory</classname> is
      returned. More specifically, the requested Bean Validation provider is
      determined and the result of
      <code>validationProvider.buildValidatorFactory(ConfigurationState)</code>
      is returned. <classname>ConfigurationState</classname> gives access to
      the configuration artifacts defined in
      <filename>META-INF/validation.xml</filename> (unless XML configuration
      is ignored) and provided programmatically to
      <classname>Configuration</classname>. Generally speaking,
      programmatically defined elements have priority over XML defined
      configuration elements (read the <classname>Configuration</classname>
      JavaDoc and see <xref linkend="xml-config"/> for more
      information).</para>

      <note>
        <para>A typical implementation of <classname>Configuration</classname>
        also implements <classname>ConfigurationState</classname>, hence
        <code>this</code> can be passed to
        <methodname>buildValidatorFactory(ConfigurationState)</methodname>.</para>
      </note>

      <para><phrase role="tck-not-testable">Streams represented in the XML
      configuration and opened by the <classname>Configuration</classname>
      implementation must be closed by the
      <classname>Configuration</classname> implementation after the
      <classname>ValidatorFactory</classname> creation (or if an exception
      occurs).</phrase> Streams provided programmatically are the
      responsibility of the application.</para>

      <example revisionflag="changed">
        <title>ConfigurationState interface</title>

        <programlisting>package javax.validation.spi;

/**
 * Contract between a {@code Configuration} and a
 * {@code javax.validation.spi.ValidationProvider} to create a {@code ValidatorFactory}.
 * The configuration artifacts defined in the XML configuration and provided to the
 * {@code Configuration} are merged and passed along via
 * {@code ConfigurationState}.
 *
 * @author Emmanuel Bernard
 * @author Hardy Ferentschik
 * @author Gunnar Morling
 */
public interface ConfigurationState {

    /**
     * Returns true if Configuration.ignoreXMLConfiguration() has been called
     * In this case, the ValidatorFactory must ignore META-INF/validation.xml
     *
     * @return {@code true} if META-INF/validation.xml should be ignored
     */
    boolean isIgnoreXmlConfiguration();

    /**
     * Returns the message interpolator of this configuration.
     * Message interpolator is defined in the following decreasing priority:
     * &lt;ul&gt;
     * &lt;li&gt;set via the {@code Configuration} programmatic API&lt;/li&gt;
     * &lt;li&gt;defined in META-INF/validation.xml provided that ignoreXmlConfiguration
     * is false. In this case the instance is created via its no-arg constructor.&lt;/li&gt;
     * &lt;li&gt;{@code null} if undefined.&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @return message provider instance or null if not defined
     */
    MessageInterpolator getMessageInterpolator();

    /**
     * Returns a set of configuration streams. The streams are defined by:
     * &lt;ul&gt;
     * &lt;li&gt;mapping XML streams passed programmatically in {@code Configuration}&lt;/li&gt;
     * &lt;li&gt;mapping XML streams located in the resources defined in&lt;/li&gt;
     * META-INF/validation.xml (constraint-mapping element)
     * &lt;/ul&gt;
     * Streams represented in the XML configuration and opened by the
     * {@code Configuration} implementation must be closed by the
     * {@code Configuration} implementation after the {@code ValidatorFactory}
     * creation (or if an exception occurs). All streams are guaranteed to
     * adhere to the mark/reset contract (see
     * {@link InputStream#markSupported()} by the Bean Validation provider.
     *
     * @return set of input stream
     */
    Set&lt;InputStream&gt; getMappingStreams();

    /**
     * Returns the constraint validator factory of this configuration.
     * The {@code ConstraintValidatorFactory} implementation is defined in the following
     * decreasing priority:
     * &lt;ul&gt;
     * &lt;li&gt;set via the {@code Configuration} programmatic API&lt;/li&gt;
     * &lt;li&gt;defined in META-INF/validation.xml provided that ignoredXmlConfiguration
     * is false. In this case the instance is created via its no-arg constructor.&lt;/li&gt;
     * &lt;li&gt;{@code null} if undefined.&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @return factory instance or {@code null} if not defined
     */
    ConstraintValidatorFactory getConstraintValidatorFactory();

    /**
     * Returns the traversable resolver for this configuration.
     * {@code TraversableResolver} is defined in the following decreasing priority:
     * &lt;ul&gt;
     * &lt;li&gt;set via the {@code Configuration} programmatic API&lt;/li&gt;
     * &lt;li&gt;defined in META-INF/validation.xml provided that ignoredXmlConfiguration
     * is false. In this case the instance is created via its no-arg constructor.&lt;/li&gt;
     * &lt;li&gt;{@code null} if undefined.&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @return traversable resolver instance or {@code null} if not defined
     */
    TraversableResolver getTraversableResolver();

    /**
     * Returns the parameter name provider for this configuration.
     * {@code ParameterNameProvider} is defined in the following decreasing priority:
     * &lt;ul&gt;
     * &lt;li&gt;set via the {@code Configuration} programmatic API&lt;/li&gt;
     * &lt;li&gt;defined in META-INF/validation.xml provided that ignoredXmlConfiguration
     * is false. In this case the instance is created via its no-arg constructor.&lt;/li&gt;
     * &lt;li&gt;{@code null} if undefined.&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @return parameter name provider instance or {@code null} if not defined
     */
    ParameterNameProvider getParameterNameProvider();

    /**
     * Returns a map of non type-safe custom properties.
     * Properties defined via:
     * &lt;ul&gt;
     * &lt;li&gt;Configuration.addProperty(String, String)&lt;/li&gt;
     * &lt;li&gt;META-INF/validation.xml provided that ignoredXmlConfiguration&lt;/li&gt;
     * is false.
     * &lt;/ul&gt;
     * If a property is defined both programmatically and in XML,
     * the value defined programmatically has priority
     *
     * @return Map whose key is the property key and the value the property value
     */
    Map&lt;String, String&gt; getProperties();
}</programlisting>
      </example>

      <para>The requested provider implementation is resolved according to the
      following rules in the following order:</para>

      <itemizedlist>
        <listitem>
          <para>Use the provider implementation requested if
          <classname>Configuration</classname> has been created from
          <classname>Validation.byProvider(Class)</classname>.</para>
        </listitem>

        <listitem>
          <para>Use the provider implementation described in the XML
          configuration (under
          <literal>validation-config.default-provider</literal> see <xref
          linkend="xml-config"/>) if defined: the value of this element is the
          fully qualified class name of the
          <classname>ValidationProvider</classname> implementation uniquely
          identifying the provider.</para>
        </listitem>

        <listitem>
          <para>Use the first provider implementation returned by
          <classname>validationProviderResolver.getValidationProviders()</classname>.</para>
        </listitem>
      </itemizedlist>

      <para>The <classname>ValidationProviderResolver</classname> is specified
      when <classname>Configuration</classname> instances are created (see
      <classname>ValidationProvider</classname>). <phrase
      role="tck-not-testable">If no
      <classname>ValidationProviderResolver</classname> instance has been
      specified, the default <classname>ValidationProviderResolver</classname>
      is used.</phrase></para>

      <para><classname>Configuration</classname> instances are provided to the
      Bean Validation client through the <classname>Validation</classname>
      methods. <classname>Configuration</classname> instances are created by
      <classname>ValidationProvider</classname>.</para>

      <para>If a problem occurs while building the
      <classname>ValidatorFactory</classname>, a
      <classname>ValidationException</classname> is raised. This can be due to
      various reasons including:</para>

      <itemizedlist>
        <listitem>
          <para>malformed XML configuration</para>
        </listitem>

        <listitem>
          <para>malformed XML mapping</para>
        </listitem>

        <listitem>
          <para>inability to find the provider (or a provider)</para>
        </listitem>

        <listitem>
          <para>inability to instantiate extension classes provided in the XML
          configuration</para>
        </listitem>

        <listitem>
          <para>inconsistent XML mapping (entity declared more than once,
          incorrect field etc).</para>
        </listitem>

        <listitem>
          <para>invalid constraint declaration or definition</para>
        </listitem>
      </itemizedlist>

      <para>Other exception causes may occur.</para>

      <para>Here is an example of <classname>Configuration</classname>
      use.</para>

      <example>
        <title>Use Configuration</title>

        <programlisting>Configuration&lt;?&gt; configuration = ...
ValidatorFactory factory = configuration
              .messageInterpolator( new WBMessageInterpolator() )
              .traversableResolver( new JPAAwareTraversableResolver() )
              .buildValidatorFactory();</programlisting>
      </example>

      <para revisionflag="added">The following shows an example of setting up
      a <classname>Configuration</classname>, retrieving a validator factory
      from it, subsequently altering the configuration and then retrieving
      another factory:</para>

      <example id="using-configuration-several-times" revisionflag="added">
        <title>Using Configuration to create several validator
        factories</title>

        <programlisting>Configuration&lt;?&gt; configuration = ...
ValidatorFactory factory1 = configuration
              .messageInterpolator( new WBMessageInterpolator() )
              .buildValidatorFactory();

ValidatorFactory factory2 = configuration
              .traversableResolver( new JPAAwareTraversableResolver() )
              .buildValidatorFactory();</programlisting>
      </example>

      <para revisionflag="added">Here, <varname>factory1</varname> is set up
      using a custom message interpolator, while <varname>factory2</varname>
      is set up using the same message interpolator and additionally using a
      custom traversable resolver.</para>
    </section>

    <section>
      <title>ValidationProvider and ValidationProviderResolver</title>

      <para><classname>ValidationProvider</classname> is the contract between
      the bootstrap process and a specific Bean Validation provider.
      <classname>ValidationProviderResolver</classname> implements the
      discovery mechanism for Bean Validation provider implementations. Any
      Bean Validation client can implement such a discovery mechanism but it
      is typically implemented by containers having specific classloader
      structures and restrictions.</para>

      <section>
        <title>ValidationProviderResolver</title>

        <para><phrase
        role="tck-testable"><classname>ValidationProviderResolver</classname>
        returns the list of Bean Validation providers available at runtime and
        more specifically a <classname>ValidationProvider</classname> instance
        for each provider available in the context.</phrase> This service can
        be customized by implementing
        <classname>ValidationProviderResolver</classname>. <phrase
        role="tck-not-testable">Implementations must be
        thread-safe.</phrase></para>

        <example>
          <title>ValidationProviderResolver</title>

          <programlisting>/**
 * Determines the list of Bean Validation providers available in the runtime environment
 * &lt;p/&gt;
 * Bean Validation providers are identified by the presence of
 * META-INF/services/javax.validation.spi.ValidationProvider
 * files following the Service Provider pattern described
 * &lt;a href="http://java.sun.com/j2se/1.5.0/docs/guide/jar/jar.html#Service%20Provider"&gt;here&lt;/a&gt;
 * &lt;p/&gt;
 * Each META-INF/services/javax.validation.spi.ValidationProvider file contains the list of
 * &lt;code&gt;ValidationProvider&lt;/code&gt; implementations each of them representing a provider.
 * &lt;p/&gt;
 * Implementations must be thread-safe.
 *
 * @author Emmanuel Bernard
 */
public interface ValidationProviderResolver {
    /**
     * Returns a list of ValidationProviders available in the runtime environment.
     *
     * @return list of validation providers.
     */
    List&lt;ValidationProvider&lt;?&gt;&gt; getValidationProviders();
}</programlisting>
        </example>

        <para>By default, providers are resolved using the Service Provider
        pattern described in <ulink
        url="http://docs.oracle.com/javase/1.5.0/docs/guide/jar/jar.html#Service%20Provider">http://docs.oracle.com/javase/1.5.0/docs/guide/jar/jar.html#Service%20Provider</ulink>.
        <phrase role="tck-testable">Bean Validation providers must supply a
        service provider configuration file by creating a text file
        <filename>javax.validation.spi.ValidationProvider</filename> and
        placing it in the <filename>META-INF/services</filename> directory of
        one of its jar files.</phrase> The content of the file should contain
        the name of the provider implementation class of the
        <classname>javax.validation.spi.ValidationProvider</classname>
        interface.</para>

        <para>Bean Validation provider jars may be installed or made available
        in the same ways as other service providers, e.g. as extensions or
        added to the application classpath according to the guidelines in the
        JAR file specification.</para>

        <para>The default <classname>ValidationProviderResolver</classname>
        implementation will locate all the Bean Validation providers by their
        provider configuration files visible in the classpath. The default
        <classname>ValidationProviderResolver</classname> implementation is
        recommended and custom
        <classname>ValidationProviderResolver</classname> implementations
        should be rarely used. A typical use of a custom resolution is
        resolving providers in a classloader constrained container like OSGi
        or in a tool environment (IDE).</para>

        <para>The default <classname>ValidationProviderResolver</classname>
        can be accessed via
        <classname>BootStrapState.getDefaultValidationProviderResolver()</classname>.
        This method is typically used by the Bean Validation provider
        <classname>Configuration</classname> implementation.</para>
      </section>

      <section id="id-bootstrap-validationprovider">
        <title>ValidationProvider</title>

        <para><classname>ValidationProvider</classname> represents the SPI
        (Service Provider Interface) defining the contract between the
        provider discovery and initialization mechanism, and the provider. A
        <classname>ValidationProvider</classname> does:</para>

        <itemizedlist>
          <listitem>
            <para>Provide a generic <classname>Configuration</classname>
            implementation (i.e. not tied to a given provider).</para>
          </listitem>

          <listitem>
            <para>Provide a provider specific
            <classname>Configuration</classname> implementation. This
            <classname>Configuration</classname> will specifically build
            <classname>ValidatorFactory</classname> instances of the provider
            it comes from.</para>
          </listitem>

          <listitem>
            <para>Build a <classname>ValidatorFactory</classname> object from
            the configuration provided by
            <classname>ConfigurationState</classname>.</para>
          </listitem>
        </itemizedlist>

        <example>
          <title>ValidationProvider</title>

          <programlisting>package javax.validation.spi;

/**
 * Contract between the validation bootstrap mechanism and the provider engine.
 * &lt;p/&gt;
 * Implementations must have a public no-arg constructor. The construction of a provider
 * should be as "lightweight" as possible.
 *
 * &lt;code&gt;T&lt;/code&gt; represents the provider specific Configuration subclass
 * which typically host provider's additional configuration methods.
 *
 * @author Emmanuel Bernard
 * @author Hardy Ferentschik
 */
public interface ValidationProvider&lt;T extends Configuration&lt;T&gt;&gt; {

    /**
     * Returns a &lt;code&gt;Configuration&lt;/code&gt; instance implementing &lt;code&gt;T&lt;/code&gt;,
     * the &lt;code&gt;Configuration&lt;/code&gt; subinterface.
     * The returned &lt;code&gt;Configuration&lt;/code&gt; instance must use the current provider
     * (&lt;code&gt;this&lt;/code&gt;) to build the &lt;code&gt;ValidatorFactory&lt;/code&gt; instance.
     * &lt;p/&gt;
     *
     * @param state bootstrap state
     *
     * @return specific Configuration implementation
     */
    T createSpecializedConfiguration(BootstrapState state);

    /**
     * Returns a &lt;code&gt;Configuration&lt;/code&gt; instance. This instance is not bound to
     * use the current provider. The choice of provider follows the algorithm described
     * in {@link javax.validation.Configuration}
     * &lt;p/&gt;
     * The &lt;code&gt;ValidationProviderResolver&lt;/code&gt; used by &lt;code&gt;Configuration&lt;/code&gt;
     * is provided by &lt;code&gt;state&lt;/code&gt;.
     * If null, the default &lt;code&gt;ValidationProviderResolver&lt;/code&gt; is used.
     *
     * @param state bootstrap state
     *
     * @return Non specialized Configuration implementation
     */
    Configuration&lt;?&gt; createGenericConfiguration(BootstrapState state);

    /**
     * Build a &lt;code&gt;ValidatorFactory&lt;/code&gt; using the current provider implementation.
     * The &lt;code&gt;ValidatorFactory&lt;/code&gt; is assembled and follows the configuration passed
     * via &lt;code&gt;ConfigurationState&lt;/code&gt;.
     * &lt;p&gt;
     * The returned &lt;code&gt;ValidatorFactory&lt;/code&gt; is properly initialized and ready for use.
     * &lt;/p&gt;
     *
     * @param configurationState the configuration descriptor
     *
     * @return the instanciated ValidatorFactory
     * @throws javax.validation.ValidationException if the ValidatorFactory cannot be built
     */
    ValidatorFactory buildValidatorFactory(ConfigurationState configurationState);
}</programlisting>
        </example>

        <example>
          <title>BootstrapState interface</title>

          <programlisting>package javax.validation.spi;

/**
 * Defines the state used to bootstrap the &lt;code&gt;Configuration&lt;/code&gt;
 *
 * @author Emmanuel Bernard
 * @author Sebastian Thomschke 
 */
public interface BootstrapState {
    /**
     * User defined &lt;code&gt;ValidationProviderResolver&lt;/code&gt; strategy
     * instance or &lt;code&gt;null&lt;/code&gt; if undefined.
     *
     * @return ValidationProviderResolver instance or null
     */
    ValidationProviderResolver getValidationProviderResolver();

    /**
     * Specification default &lt;code&gt;ValidationProviderResolver&lt;/code&gt;
     * strategy instance.
     * 
     * @return default implementation of ValidationProviderResolver
     */
    ValidationProviderResolver getDefaultValidationProviderResolver();
}</programlisting>
        </example>

        <para><phrase role="tck-testable">A client can request a specific Bean
        Validation provider by using <classname>&lt;T extends
        Configuration&lt;T&gt;, U extends ValidationProvider&lt;T&gt;&gt;
        Validation.byProvider(Class&lt;U&gt;)</classname> or by defining the
        provider in the XML configuration file.</phrase> The key uniquely
        identifying a Bean Validation provider is the
        <classname>ValidationProvider</classname> implementation specific to
        this provider.</para>

        <para>A <classname>ValidationProvider</classname> implementation is
        linked (via it's generic parameter) to a specific sub interface of
        <classname>Configuration</classname>. The Bean Validation bootstrap
        API makes use of this link to return the specific Configuration
        subinterface implementation in a type-safe way when a specific
        provider is requested. The sub interface does not have to add any new
        method but is the natural holder for provider specific configuration
        methods.</para>

        <example>
          <title>Example of provider specific Configuration sub
          interface</title>

          <programlisting>/**
 * Unique identifier of the ACME provider
 * also hosts some provider specific configuration methods
 */
public interface ACMEConfiguration 
    extends Configuration&lt;ACMEConfiguration&gt; {

    /**
     * Enables constraints implementation dynamic reloading when using ACME
     * default to false
     */
    ACMEConfiguration enableDynamicReloading(boolean);

}

/**
 * ACME validation provider
 * Note how ACMEConfiguration and ACMEProvider are linked together 
 * via the generic parameter.
 */
public class ACMEProvider implements ValidationProvider&lt;ACMEConfiguration&gt; {
    ...
}</programlisting>
        </example>

        <note>
          <para><classname>Configuration</classname> references itself in the
          generic definition. Methods of <classname>Configuration</classname>
          will return the <classname>ACMEConfiguration</classname> making the
          API easy to use even for vendor specific extensions.</para>
        </note>

        <para role="tck-testable">The provider discovery mechanism uses the
        following algorithm: <itemizedlist>
            <listitem>
              <para>Retrieve available providers using
              <methodname>ValidationProviderResolver.getValidationProviders()</methodname>.</para>
            </listitem>

            <listitem>
              <para>The first <classname>ValidationProvider</classname>
              matching the requested provider is returned. Providers are
              evaluated in the order they are returned by
              <classname>ValidationProviderResolver</classname>. A provider
              instance is considered matching if it is assignable to the
              requested provider class.</para>
            </listitem>
          </itemizedlist></para>

        <para role="tck-testable">When the default Bean Validation provider is
        requested, the first <classname>ValidationProvider</classname>
        returned by the <classname>ValidationProviderResolver</classname>
        strategy is returned.</para>

        <para><phrase role="tck-testable">Every Bean Validation provider must
        provide a <classname>ValidationProvider</classname> implementation
        containing a public no-arg constructor</phrase> and add the
        corresponding
        <filename>META-INF/services/javax.validation.spi.ValidationProvider</filename>
        file descriptor in one of its jars.</para>

        <para><phrase role="tck-testable">If a problem occurs while building
        the <classname>ValidatorFactory</classname>, a
        <classname>ValidationException</classname> is raised.</phrase> This
        can be due to various reasons including:</para>

        <itemizedlist>
          <listitem>
            <para>malformed XML mapping</para>
          </listitem>

          <listitem>
            <para>inability to find the provider (or a provider)</para>
          </listitem>

          <listitem>
            <para>inability to instantiate extension classes provided in the
            XML configuration</para>
          </listitem>

          <listitem>
            <para>inconsistent XML mapping (entity declared more than once,
            incorrect field etc).</para>
          </listitem>

          <listitem>
            <para>invalid constraint declaration or definition</para>
          </listitem>
        </itemizedlist>
      </section>
    </section>

    <section id="boostrapping-validation">
      <title>Validation</title>

      <para>The <classname>Validation</classname> class is the entry point
      used to bootstrap Bean Validation providers. <phrase
      role="tck-testable">The first entry point,
      <methodname>buildDefaultValidatorFactory()</methodname>, is considered
      to be the default <classname>ValidatorFactory</classname> and is
      equivalent to the <classname>ValidatorFactory</classname> returned by
      <code>Validation.byDefaultProvider().configure().buildValidatorFactory()</code>.</phrase></para>

      <warning>
        <para>Should the resolver strategy be configurable by XML</para>
      </warning>

      <example>
        <title>Validation methods available</title>

        <programlisting>/**
 * This class is the entry point for Bean Validation. There are three ways
 * to bootstrap it:
 * &lt;ul&gt;
 * &lt;li&gt;
 * The easiest approach is to build the default &lt;code&gt;ValidatorFactory&lt;/code&gt;.
 * &lt;pre&gt;{@code ValidatorFactory factory = Validation.buildDefaultValidatorFactory();}&lt;/pre&gt;
 * In this case, the default validation provider resolver
 * will be used to locate available providers.
 * The chosen provider is defined as followed:
 * &lt;ul&gt;
 * &lt;li&gt;if the XML configuration defines a provider, this provider is used&lt;/li&gt;
 * &lt;li&gt;if the XML configuration does not define a provider or if no XML configuration
 * is present the first provider returned by the 
 * &lt;code&gt;ValidationProviderResolver&lt;/code&gt; instance is used.&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;/li&gt;
 * &lt;li&gt;
 * The second bootstrap approach allows to choose a custom
 * &lt;code&gt;ValidationProviderResolver&lt;/code&gt;. The chosen
 * &lt;code&gt;ValidationProvider&lt;/code&gt; is then determined in the same way
 * as in the default bootstrapping case (see above).
 * &lt;pre&gt;{@code
 * Configuration&lt;?&gt; configuration = Validation
 *    .byDefaultProvider()
 *    .providerResolver( new MyResolverStrategy() )
 *    .configure();
 * ValidatorFactory factory = configuration.buildValidatorFactory();}
 * &lt;/pre&gt;
 * &lt;/li&gt;
 * &lt;li&gt;
 * The third approach allows you to specify explicitly and in
 * a type safe fashion the expected provider.
 * &lt;p/&gt;
 * Optionally you can choose a custom &lt;code&gt;ValidationProviderResolver&lt;/code&gt;.
 * &lt;pre&gt;{@code
 * ACMEConfiguration configuration = Validation
 *    .byProvider(ACMEProvider.class)
 *    .providerResolver( new MyResolverStrategy() )  // optionally set the provider resolver
 *    .configure();
 * ValidatorFactory factory = configuration.buildValidatorFactory();}
 * &lt;/pre&gt;
 * &lt;/li&gt;
 * &lt;/ul&gt;
 * Note:&lt;br/&gt;
 * &lt;ul&gt;
 * &lt;li&gt;
 * The &lt;code&gt;ValidatorFactory&lt;/code&gt; object built by the bootstrap process should be cached
 * and shared amongst &lt;code&gt;Validator&lt;/code&gt; consumers.
 * &lt;/li&gt;
 * &lt;li&gt;
 * This class is thread-safe.
 * &lt;/li&gt;
 * &lt;/ul&gt;
 *
 * @author Emmanuel Bernard
 * @author Hardy Ferentschik
 */
public class Validation {

    /**
     * Build and return a &lt;code&gt;ValidatorFactory&lt;/code&gt; instance based on the
     * default Bean Validation provider and following the XML configuration.
     * &lt;p/&gt;
     * The provider list is resolved using the default validation provider resolver
     * logic.
     * &lt;p/&gt; The code is semantically equivalent to
     * &lt;code&gt;Validation.byDefaultProvider().configure().buildValidatorFactory()&lt;/code&gt;
     *
     * @return &lt;code&gt;ValidatorFactory&lt;/code&gt; instance.
     *
     * @throws ValidationException if the ValidatorFactory cannot be built
     */
    public static ValidatorFactory buildDefaultValidatorFactory() {
        [...]
    }

    /**
     * Build a &lt;code&gt;Configuration&lt;/code&gt;. The provider list is resolved
     * using the strategy provided to the bootstrap state.
     * &lt;pre&gt;
     * Configuration&amp;lt?&amp;gt; configuration = Validation
     *    .byDefaultProvider()
     *    .providerResolver( new MyResolverStrategy() )
     *    .configure();
     * ValidatorFactory factory = configuration.buildValidatorFactory();
     * &lt;/pre&gt;
     * The provider can be specified in the XML configuration. If the XML
     * configuration does not exsist or if no provider is specified,
     * the first available provider will be returned.
     *
     * @return instance building a generic &lt;code&gt;Configuration&lt;/code&gt;
     *         compliant with the bootstrap state provided.
     */
    public static GenericBootstrap byDefaultProvider() {
        [...]
    }

    /**
     * Build a &lt;code&gt;Configuration&lt;/code&gt; for a particular provider implementation.
     * Optionally overrides the provider resolution strategy used to determine the provider.
     * &lt;p/&gt;
     * Used by applications targeting a specific provider programmatically.
     * &lt;p/&gt;
     * &lt;pre&gt;
     * ACMEConfiguration configuration =
     *     Validation.byProvider(ACMEProvider.class)
     *             .providerResolver( new MyResolverStrategy() )
     *             .configure();
     * &lt;/pre&gt;,
     * where &lt;code&gt;ACMEConfiguration&lt;/code&gt; is the
     * &lt;code&gt;Configuration&lt;/code&gt; sub interface uniquely identifying the
     * ACME Bean Validation provider. and &lt;code&gt;ACMEProvider&lt;/code&gt; is the
     * &lt;code&gt;ValidationProvider&lt;/code&gt; implementation of the ACME provider.
     *
     * @param providerType the &lt;code&gt;ValidationProvider&lt;/code&gt; implementation type
     *
     * @return instance building a provider specific &lt;code&gt;Configuration&lt;/code&gt;
     *         sub interface implementation.
     */
    public static &lt;T extends Configuration&lt;T&gt;, U extends ValidationProvider&lt;T&gt;&gt;
            ProviderSpecificBootstrap&lt;T&gt; byProvider(Class&lt;U&gt; providerType) {
        [...]
    }

    [...]
}</programlisting>
      </example>

      <para><phrase role="tck-testable">The second entry point lets the client
      provide a custom <classname>ValidationProviderResolution</classname>
      instance. This instance is passed to
      <classname>GenericBootstrap</classname>.
      <classname>GenericBootstrap</classname> builds a generic
      <classname>Configuration</classname> using the first
      <classname>ValidationProvider</classname> returned by
      <classname>ValidationProviderResolution</classname> and calling
      <code>ValidationProvider.createGenericConfiguration(BootstrapState
      state)</code>.</phrase> <classname>BootstrapState</classname> holds the
      <classname>ValidationProviderResolution</classname> instance passed to
      <classname>GenericBootstrap</classname> and will be used by the
      <classname>Configuration</classname> instance when resolving the
      provider to use. Note that
      <code>ValidationProvider.createGenericConfiguration</code> returns a
      <classname>Configuration</classname> object not bound to any particular
      provider.</para>

      <example>
        <title>GenericBootstrap interface</title>

        <programlisting>package javax.validation.bootstrap;

/**
 * Defines the state used to bootstrap Bean Validation and
 * creates a provider agnostic &lt;code&gt;Configuration&lt;/code&gt;.
 *
 * @author Emmanuel Bernard
 */
public interface GenericBootstrap {
    /**
     * Defines the provider resolution strategy.
     * This resolver returns the list of providers evaluated
     * to build the &lt;code&gt;Configuration&lt;/code&gt;
     * &lt;p/&gt;
     * If no resolver is defined, the default &lt;code&gt;ValidationProviderResolver&lt;/code&gt;
     * implementation is used.
     *
     * @return &lt;code&gt;this&lt;/code&gt; following the chaining method pattern
     */
    GenericBootstrap providerResolver(ValidationProviderResolver resolver);

    /**
     * Returns a generic &lt;code&gt;Configuration&lt;/code&gt; implementation.
     * At this stage the provider used to build the &lt;code&gt;ValidatorFactory&lt;/code&gt; 
     * is not defined.
     * &lt;p/&gt;
     * The &lt;code&gt;Configuration&lt;/code&gt; implementation is provided by the first provider 
     * returned by the &lt;code&gt;ValidationProviderResolver&lt;/code&gt; strategy.
     *
     * @return a Configuration implementation compliant with the bootstrap state
     * @throws javax.validation.ValidationException if the Configuration object cannot be built
     *                        this is generally due to an issue with the ValidationProviderResolver
     */
    Configuration&lt;?&gt; configure();
}</programlisting>
      </example>

      <para><phrase role="tck-testable">The last entry point lets the client
      define the specific Bean Validation provider requested as well as a
      custom <classname>ValidationProviderResolver</classname> implementation
      if needed. The entry point method,
      <methodname>Validation.byProvider(Class&lt;U&gt;
      providerType)</methodname>, takes the provider specific
      <classname>ValidationProvider</classname> implementation type and
      returns a <classname>ProviderSpecificBootstrap</classname> object that
      guarantees to return an instance of the specific
      <classname>Configuration</classname> sub interface.</phrase> Thanks to
      the use of generics, the client API does not have to cast to the
      <classname>Configuration</classname> sub interface.</para>

      <para>A <classname>ProviderSpecificBootstrap</classname> object can
      optionally receive a <classname>ValidationProviderResolver</classname>
      instance.</para>

      <example>
        <title>ProviderSpecificBootstrap interface</title>

        <programlisting>package javax.validation.bootstrap;

/**
 * Defines the state used to bootstrap Bean Validation and
 * creates a provider specific &lt;code&gt;Configuration&lt;/code&gt;
 * of type&lt;code&gt;T&lt;/code&gt;.
 * &lt;p/&gt;
 * The specific &lt;code&gt;Configuration&lt;/code&gt; is linked to the provider via the generic
 * parameter of the &lt;code&gt;ValidationProvider&lt;/code&gt; implementation.
 * &lt;p/&gt;
 * The requested provider is the first provider instance assignable to
 * the requested provider type (known when &lt;code&gt;ProviderSpecificBootstrap&lt;/code&gt; is built).
 * The list of providers evaluated is returned by {@link ValidationProviderResolver}.
 * If no &lt;code&gt;ValidationProviderResolver&lt;/code&gt; is defined, the
 * default &lt;code&gt;ValidationProviderResolver&lt;/code&gt; strategy is used.
 *
 * @author Emmanuel Bernard
 */
public interface ProviderSpecificBootstrap&lt;T extends Configuration&lt;T&gt;&gt; {

    /**
     * Optionally defines the provider resolver implementation used.
     * If not defined, use the default &lt;code&gt;ValidationProviderResolver&lt;/code&gt;
     *
     * @param resolver &lt;code&gt;ValidationProviderResolver&lt;/code&gt; implementation used
     *
     * @return &lt;code&gt;this&lt;/code&gt; following the chaining method pattern
     */
    public ProviderSpecificBootstrap&lt;T&gt; providerResolver(ValidationProviderResolver resolver);

    /**
     * Determines the provider implementation suitable for &lt;code&gt;T&lt;/code&gt; and delegates
     * the creation of this specific &lt;code&gt;Configuration&lt;/code&gt; subclass to the provider.
     *
     * @return &lt;code&gt;Configuration&lt;/code&gt; sub interface implementation
     * @throws javax.validation.ValidationException if the Configuration object cannot be built
     *                        this is generally due to an issue with the ValidationProviderResolver
     */
    public T configure();
}</programlisting>
      </example>

      <para><methodname>ProviderSpecificBootstrap.configure()</methodname>
      must return the result of
      <methodname>ValidationProvider.createSpecializedConfiguration(BootstrapState
      state)</methodname>. The state parameter holds the
      <classname>ValidationProviderResolver</classname> passed to
      <classname>ProviderSpecificBootstrap</classname>. The validation
      provider instance used is the one assignable to the type passed as a
      parameter in <methodname>Validation.byProvider(Class)</methodname>. The
      validation provider is selected according to the algorithm described in
      (<xref linkend="id-bootstrap-validationprovider"/>).</para>

      <para role="tck-testable">The <classname>Validation</classname>
      implementation must not contain any non private attribute or method
      aside from the three public static bootstrap methods:</para>

      <itemizedlist>
        <listitem>
          <para><methodname>public static ValidatorFactory
          buildDefaultValidatorFactory()</methodname></para>
        </listitem>

        <listitem>
          <para><methodname>public static GenericBootstrap
          byDefaultProvider()</methodname></para>
        </listitem>

        <listitem>
          <para><methodname>public static &lt;T extends
          Configuration&lt;T&gt;, U extends ValidationProvider&lt;T&gt;&gt;
          ProviderSpecificBootstrap&lt;T&gt; byProvider(Class&lt;U&gt;
          providerType)</methodname></para>
        </listitem>
      </itemizedlist>

      <para>The bootstrap API is designed to allow complete portability
      amongst Bean Validation provider implementations. <phrase
      role="tck-testable">The bootstrap implementation must ensure it can
      bootstrap third party providers.</phrase></para>

      <para role="tck-testable">When building the
      <classname>Configuration</classname> object, if the
      <classname>ValidationProviderResolver</classname> either fails or if the
      expected provider is not found, a
      <classname>ValidationException</classname> is raised.</para>
    </section>

    <section id="xml-config">
      <title>XML Configuration: META-INF/validation.xml</title>

      <para><phrase role="tck-testable">Unless explicitly ignored by calling
      <classname>Configuration.ignoreXMLConfiguration()</classname>, a
      <classname>Configuration</classname> takes into account the
      configuration available in
      <filename>META-INF/validation.xml</filename>.</phrase> <phrase
      role="tck-testable">This configuration file is optional</phrase> but can
      be used by applications to refine some of the Bean Validation behavior.
      <phrase role="tck-not-testable">If more than one
      <filename>META-INF/validation.xml</filename> file is found in the
      classpath, a <classname>ValidationException</classname> is
      raised.</phrase></para>

      <para revisionflag="added">Implementations supporting Bean Validation
      1.1 must properly parse deployment descriptors of Bean Validation 1.0
      and 1.1.</para>

      <para><phrase role="tck-testable">Unless stated otherwise, XML based
      configuration settings are overridden by values explicitly set via the
      <classname>Configuration</classname> API.</phrase> For example, the
      <classname>MessageInterpolator</classname> defined via
      <methodname>Configuration.messageInterpolator(MessageInterpolator)</methodname>
      has priority over the <literal>message-interpolator</literal>
      definition.</para>

      <para><phrase role="tck-testable"><literal>default-provider</literal>:
      represents the class name of the provider specific
      <classname>ValidationProvider</classname> implementation class. If
      defined, the specific provider is used</phrase> (unless a specific
      provider has been chosen via the programmatic approach).</para>

      <para><phrase
      role="tck-testable"><literal>message-interpolator</literal>: represents
      the fully qualified class name of the
      <classname>MessageInterpolator</classname> implementation. When defined
      in XML, the implementation must have a public no-arg
      constructor.</phrase><phrase revisionflag="deleted"> This element is
      optional.</phrase></para>

      <para><phrase
      role="tck-testable"><literal>traversable-resolver</literal>: represents
      the fully qualified class name of the
      <classname>TraversableResolver</classname> implementation. When defined
      in XML, the implementation must have a public no-arg
      constructor.</phrase> <phrase revisionflag="deleted">This element is
      optional.</phrase></para>

      <para><phrase
      role="tck-testable"><literal>constraint-validator-factory</literal>:
      represents the fully qualified class name of the
      <classname>ConstraintValidatorFactory</classname> implementation. When
      defined in XML, the implementation must have a public no-arg
      constructor.</phrase> <phrase revisionflag="deleted">This element is
      optional.</phrase></para>

      <para revisionflag="added"
      role="tck-testable"><literal>parameter-name-provider</literal>:
      represents the fully qualified class name of the
      <classname>ParameterNameProvider</classname> implementation. When
      defined in XML, the implementation must have a public no-arg
      constructor.</para>

      <para revisionflag="added"
      role="tck-testable tck-needs-update"><literal>message-interpolator</literal>,
      <literal>traversable-resolver, constraint-validator-factory</literal>
      and <literal>parameter-name-provider</literal> are optional.</para>

      <para><phrase role="tck-testable"><literal>constraint-mapping</literal>:
      represents the resource path of an XML mapping file.</phrase> <phrase
      role="tck-testable">More than one <literal>constraint-mapping</literal>
      element can be present.</phrase> <phrase role="tck-testable">Mappings
      provided via
      <methodname>Configuration.addMapping(InputStream)</methodname> are added
      to the list of mappings described via
      <literal>constraint-mapping</literal>.</phrase></para>

      <para><literal>property</literal>: represents a key/value pair property
      providing room to provider specific configurations. Vendors should use
      vendor namespaces for properties (e.g.,
      <literal>com.acme.validation.logging</literal>). Entries that make use
      of the namespace <literal>javax.validation</literal> and its
      subnamespaces must not be used for vendor-specific information. <phrase
      role="tck-not-testable">The namespace
      <literal>javax.validation</literal> is reserved for use by this
      specification.</phrase> <phrase
      role="tck-not-testable tck-needs-update">Properties defined via
      <methodname>Configuration.addProperty(String, String)</methodname> are
      added to the properties defined via
      <literal>property</literal>.</phrase> <phrase
      role="tck-not-testable tck-needs-update">If a property with the same
      name are defined in both XML and via the programmatic API, the value
      provided via programmatic API has priority.</phrase></para>

      <para role="tck-testable">If a public no-arg constructor is missing, a
      <classname>ValidationException</classname> is raised during the
      <methodname>Configuration.buildValidatorFactory()</methodname>
      call.</para>

      <example revisionflag="changed">
        <title>Example of META-INF/validation.xml file</title>

        <programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;validation-config
        xmlns="http://jboss.org/xml/ns/javax/validation/configuration"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation=
            "http://jboss.org/xml/ns/javax/validation/configuration validation-configuration-1.1.xsd"
        version="1.1"&gt;
    &lt;default-provider&gt;com.acme.ACMEProvider&lt;/default-provider&gt;
    &lt;message-interpolator&gt;com.acme.ACMEAwareMessageInterpolator&lt;/message-interpolator&gt;

    &lt;constraint-mapping&gt;META-INF/validation/order-constraints.xml&lt;/constraint-mapping&gt;
    &lt;constraint-mapping&gt;META-INF/validation/catalog-constraints.xml&lt;/constraint-mapping&gt;
    &lt;constraint-mapping&gt;META-INF/validation/customer-constraints.xml&lt;/constraint-mapping&gt;

    &lt;property name="com.acme.validation.logging"&gt;WARN&lt;/property&gt;
    &lt;property name="com.acme.validation.safetyChecking"&gt;failOnError&lt;/property&gt;

&lt;/validation-config&gt;</programlisting>
      </example>

      <para>The XML schema is described in <xref
      linkend="xml-config-xsd"/>.</para>
    </section>

    <section id="bootstrapping-usageandcontainerexpectation">
      <title>Bootstrapping considerations</title>

      <para>The Bean Validation bootstrap API can be used directly by any
      application or made available through a container or other framework. In
      all cases, the following rules apply:</para>

      <itemizedlist>
        <listitem>
          <para
          role="tck-not-testable"><classname>ValidatorFactory</classname> is a
          thread-safe object that should be built once per deployment
          unit</para>
        </listitem>

        <listitem>
          <para revisionflag="added"><classname>ValidatorFactory</classname>
          should be closed when it is no longer needed (eg when the unit is
          undeployed or the server stopped).</para>
        </listitem>

        <listitem>
          <para role="tck-not-testable"><classname>Validator</classname> is a
          thread-safe and lightweight object which can be cached by the
          <classname>ValidatorFactory</classname> instance.</para>
        </listitem>
      </itemizedlist>
    </section>
  </section>
</chapter>
