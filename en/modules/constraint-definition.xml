<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"../../docbook-support/support/docbook-dtd/docbookx.dtd" [
<!ENTITY % BOOK_ENTITIES SYSTEM "../global.ent">
%BOOK_ENTITIES;
]>
<chapter id="constraintsdefinitionimplementation">
  <title>Constraint Definition</title>

  <para>Constraints are defined by the combination of a constraint annotation
  and a list of constraint validation implementations. The constraint
  annotation is applied on types, methods, fields or other constraint
  annotations in case of composition.</para>

  <para>Unless stated otherwise the default package name for the Bean
  Validation APIs is <classname>javax.validation</classname>.</para>

  <section id="constraintsdefinitionimplementation-constraintdefinition">
    <title>Constraint annotation</title>

    <para>A constraint on a JavaBean is expressed through one or more
    annotations. <phrase role="tck-not-testable">An annotation is considered a
    <phrase revisionflag="added">generic</phrase> constraint definition if its
    retention policy contains <literal>RUNTIME</literal> and if the annotation
    itself is annotated with
    <literal>javax.validation.Constraint</literal></phrase>.</para>

    <programlisting>/**
 * Link between a constraint annotation and its constraint validation implementations.
 * &lt;p/&gt;
 * A given constraint annotation should be annotated by a {@code @Constraint}
 * annotation which refers to its list of constraint validation implementations.
 *
 * @author Emmanuel Bernard
 * @author Gavin King
 * @author Hardy Ferentschik
 */
@Documented
@Target({ ANNOTATION_TYPE })
@Retention(RUNTIME)
public @interface Constraint {
    /**
     * {@code ConstraintValidator} classes must reference distinct target types.
     * If two {@code ConstraintValidator}s refer to the same type,
     * an exception will occur.
     *
     * @return array of (@code ConstraintValidator} classes implementing the constraint
     */
    Class&lt;? extends ConstraintValidator&lt;?, ?&gt;&gt;[] validatedBy();
}</programlisting>

    <para revisionflag="added" role="tck-not-testable">An annotation is
    considered a cross-parameter constraint definition (see section <xref
    linkend="constraintdeclarationvalidationprocess-crossparameterconstraints"/>)
    if its retention policy contains <literal>RUNTIME</literal> and if the
    annotation itself is annotated with
    <literal>javax.validation.CrossParameterConstraint</literal>.</para>

    <programlisting revisionflag="added">/**
 * Link between a cross-parameter constraint annotation and its constraint
 * validation implementation.
 *
 * @author Gunnar Morling
 */
@Documented
@Target({ ANNOTATION_TYPE })
@Retention(RUNTIME)
public @interface CrossParameterConstraint {
   /**
     * Returns the {@link ConstraintValidator} class for the annotated
     * cross-parameter constraint. The validator's type parameter {@code T} must
     * resolve to {@code Object[]}.
     *
     * @return Constraint validator class implementing the constraint
     */
    Class&lt;? extends ConstraintValidator&lt;?, ?&gt;&gt; validatedBy();
}</programlisting>

    <para revisionflag="added">A Bean Validation constraint is most of the
    time either a generic constraint (marked with
    <classname>@Constraint</classname>) or a cross-parameter constraint
    (marked with <classname>@CrossParameterConstraint</classname>). In rare
    situations, a constraint can be both.</para>

    <remark revisionflag="added">TODO: An alternative to @Constraint /
    @CrossParameterConstraint is to annotate the ConstraintValidator with a
    @Validates annotation. @Validates({ANNOTATED_ELEMENT, CROSS_PARAMETER}), A
    ConstraintValidator will by default validate the annotated element but can
    be marked as validating cross parameters or both.</remark>

    <para revisionflag="added">A generic constraint is used when validating a
    bean, a field, a getter, a method/constructor return value or a
    method/constructor parameter. A cross-parameter constraint is used when
    validating the consistency of several method/constructor
    parameters.</para>

    <para role="tck-not-testable">Generic constraint annotations can target
    any of the following <classname>ElementType</classname>s:<itemizedlist>
        <listitem>
          <para><literal>FIELD</literal> for constrained attributes</para>
        </listitem>

        <listitem>
          <para><literal>METHOD</literal> for constrained getters<phrase
          revisionflag="added"> and constrained method return
          values</phrase></para>
        </listitem>

        <listitem revisionflag="added">
          <para><classname>CONSTRUCTOR</classname> for constrained constructor
          return values</para>
        </listitem>

        <listitem revisionflag="added">
          <para><classname>PARAMETER</classname> for constrained method and
          constructor parameters</para>
        </listitem>

        <listitem>
          <para><literal>TYPE</literal> for constrained beans</para>
        </listitem>

        <listitem>
          <para><literal>ANNOTATION_TYPE</literal> for constraints composing
          other constraints</para>
        </listitem>
      </itemizedlist></para>

    <para revisionflag="added" role="tck-not-testable">Cross-parameter
    constraint annotations can target any of the following
    <classname>ElementType</classname>s: <itemizedlist>
        <listitem>
          <para><literal>METHOD</literal></para>
        </listitem>

        <listitem>
          <para><literal>CONSTRUCTOR</literal></para>
        </listitem>

        <listitem>
          <para><literal>ANNOTATION_TYPE</literal> for cross-parameter
          constraints composing other cross-parameter constraints</para>
        </listitem>
      </itemizedlist></para>

    <para revisionflag="added" role="tck-testable">A constraint annotation
    that is both can target the union of the generic and cross-parameter
    constraint annotations targets.</para>

    <para>While other <classname>ElementType</classname>s are not forbidden,
    the provider does not have to recognize and process constraints placed on
    such types. <phrase revisionflag="deleted">Built-in types do support
    <literal>PARAMETER</literal> and <literal>CONSTRUCTOR</literal> to allow
    Bean Validation provider specific extensions. It is considered good
    practice to follow the same approach for custom
    annotations.</phrase></para>

    <para>Since a given constraint definition applies to one or more specific
    Java types, the JavaDoc for the constraint annotation should clearly state
    which types are supported. <phrase role="tck-testable">Applying a
    constraint annotation to an incompatible type will raise an
    <classname>UnexpectedTypeException</classname>.</phrase> Care should be
    taken on defining the list of <classname>ConstraintValidator</classname>s.
    The type resolution algorithm (see <xref
    linkend="typevalidatorresolution"/>) could lead to exceptions if the
    <classname>ConstraintValidator</classname> list leads to
    ambiguities.</para>

    <para revisionflag="added">Likewise, the JavaDoc should clearly state if
    the constraint is a generic and / or a cross-parameter constraint.</para>

    <para><phrase role="tck-testable">If a constraint definition is not valid,
    a <classname>ConstraintDefinitionException</classname> is raised either at
    validation time or when the metadata is requested.</phrase> Invalid
    constraint definitions causes are multiple but include missing or illegal
    <methodname>message</methodname> or <methodname>groups</methodname>
    elements (see <xref
    linkend="constraintsdefinitionimplementation-constraintdefinition-properties"/>).</para>

    <note revisionflag="added">
      <para>Bean Validation defines rules for applying constraint annotations
      in inheritance hierarchies, described in <xref
      linkend="constraintdeclarationvalidationprocess-inheritance"/> and <xref
      linkend="constraintdeclarationvalidationprocess-methodlevelconstraints-inheritance"/>.
      It is therefore not recommended to specify the meta annotation
      <classname>java.lang.annotation.Inherited</classname> at constraint
      annotation types, as it is not relevant in the context of Bean
      Validation and would conflict with the proposed rules.</para>
    </note>

    <section id="constraintsdefinitionimplementation-constraintdefinition-properties">
      <title>Constraint definition properties</title>

      <para><phrase role="tck-testable">A constraint definition may have
      attributes that are specified at the time the constraint is applied to a
      JavaBean.</phrase> The properties are mapped as annotation elements. The
      annotation element names <literal>message</literal>,
      <literal>groups</literal>, <literal
      revisionflag="added">validationAppliesTo</literal> and
      <literal>payload</literal> are considered reserved names; <phrase
      role="tck-testable">annotation elements starting with
      <literal>valid</literal> are not allowed</phrase>; a constraint may use
      any other element name for its attributes.</para>

      <section id="constraintsdefinitionimplementation-constraintdefinition-parameters-message">
        <title>message</title>

        <para role="tck-testable">Every constraint annotation must define a
        <literal>message</literal> element of type
        <literal>String</literal>.</para>

        <programlisting>String message() default "{com.acme.constraint.MyConstraint.message}";</programlisting>

        <para>The <methodname>message</methodname> element value is used to
        create the error message. See <xref linkend="validationapi-message"/>
        for a detailed explanation. It is recommended to default
        <literal>message</literal> values to resource bundle keys to enable
        internationalization. It is also recommended to use the following
        convention: the resource bundle key should be the fully qualified
        class name of the constraint annotation concatenated to
        <literal>.message</literal> as shown in the previous program
        listing.</para>

        <para>Built-in Bean Validation constraints follow this
        convention.</para>
      </section>

      <section id="constraintsdefinitionimplementation-constraintdefinition-groups">
        <title>groups</title>

        <para><phrase role="tck-testable">Every constraint annotation must
        define a <literal>groups</literal> element that specifies the
        processing groups with which the constraint declaration is
        associated.</phrase><phrase revisionflag="added"
        role="tck-testable">The type of the groups parameter is
        <classname>Class&lt;?&gt;[]</classname>.</phrase></para>

        <programlisting>    Class&lt;?&gt;[] groups() default {};</programlisting>

        <para role="tck-testable">The default value must be an empty
        array.</para>

        <para role="tck-testable">If no group is specified when declaring the
        constraint on an element, the <literal>Default</literal> group is
        considered declared.</para>

        <para>See <xref linkend="validationapi-validatorapi-groups"/> for more
        information.</para>

        <para>Groups are typically used to control the order in which
        constraints are evaluated, or to perform validation of the partial
        state of a JavaBean.</para>
      </section>

      <section id="constraintsdefinitionimplementation-constraintdefinition-payload">
        <title>payload</title>

        <para role="tck-testable">Constraint annotations must define a
        <literal>payload</literal> element that specifies the payload with
        which the the constraint declaration is associated.</para>

        <programlisting>    Class&lt;? extends Payload&gt;[] payload() default {};</programlisting>

        <para role="tck-testable">The default value must be an empty
        array.</para>

        <para role="tck-testable">Each attachable payload extends
        <classname>Payload</classname>.</para>

        <programlisting>/**
 * Payload type that can be attached to a given
 * constraint declaration.
 * Payloads are typically used to carry on metadata information
 * consumed by a validation client.
 *
 * Use of payloads is not considered portable.
 *
 * @author Emmanuel Bernard
 * @author Gerhard Petracek
 */
public interface Payload {
}</programlisting>

        <para>Payloads are typically used by validation clients to associate
        some metadata information with a given constraint declaration.
        Payloads are typically non-portable. Describing payloads as interface
        extensions as opposed to a string-based approach allows an easier and
        more type-safe approach.</para>

        <para>One use case for payload shown in <xref
        linkend="example-payload"/> is to associate a severity to a
        constraint. This severity can be exploited by a presentation framework
        to adjust how a constraint failure is displayed.</para>

        <example id="example-payload">
          <title>Use of payload to associate severity to a constraint</title>

          <programlisting>package com.acme.severity;

public class Severity {
    public static class Info implements Payload {};
    public static class Error implements Payload {};
}

public class Address {
    @NotNull(message="would be nice if we had one", payload=Severity.Info.class)
    public String getZipCode() {...}

    @NotNull(message="the city is mandatory", payload=Severity.Error.class) 
    String getCity() {...}
}</programlisting>
        </example>

        <para>The <literal>payload</literal> information can be retrieved from
        error reports via the <classname>ConstraintDescriptor</classname>
        either accessed through the <classname>ConstraintViolation</classname>
        objects (see <xref linkend="validationapi-constraintviolation"/>) or
        through the metadata API (see <xref
        linkend="constraintmetadata-constraintdescriptor"/>).</para>
      </section>

      <section id="constraintsdefinitionimplementation-constraintdefinition-validationappliesto"
               revisionflag="added">
        <title>validationAppliesTo</title>

        <para><literal>validationAppliesTo</literal> is used at constraint
        declaration time to clarify what the constraint targets (ie. the
        annotated element, the method return value or the method
        parameters).</para>

        <para><phrase revision="tck-testable">The element
        <literal>validationAppliesTo</literal> must only be present for
        constraints that are both generic and cross-parameter, it is mandatory
        in this situation. A
        <classname>ConstraintDefinitionException</classname> is raised if
        these rules are violated.</phrase></para>

        <example>
          <title>validationAppliesTo and ConstraintTarget</title>

          <programlisting>    ConstraintTarget validationAppliesTo() default ConstraintTarget.IMPLICIT;</programlisting>

          <programlisting>/**
 * Defines the constraint target
 *
 * @author Emmanuel Bernard &lt;emmanuel@hibernate.org&gt;
 * @since 1.1
 */
public enum ConstraintTarget {
    /**
     * Discover the type when no ambiguity is present
     * &lt;ul&gt;
     *     &lt;li&gt;if neither on a method nor a constructor, it implies the annotated element (type, field etc).&lt;/li&gt;
     *     &lt;li&gt;if on a method or constructor with no parameter, it implies {@code RETURN_VALUE}&lt;/li&gt;
     *     &lt;li&gt;if on a method with no return value ({@code void}), it implies {@code PARAMETERS}&lt;/li&gt;
     * &lt;/ul&gt;
     * Otherwise, {@code IMPLICIT} is not accepted and either {@code RETURN_VALUE} or
     * {@code PARAMETERS} is required. This is the case for constructors with parameters
     * and methods with parameters and return value.
     */
    IMPLICIT,

    /**
     * Constraint applies to the return value of a method or a constructor.
     */
    RETURN_VALUE,

    /**
     * Constraint applies to the parameters of a method or a constructor
     */
    PARAMETERS
}</programlisting>
        </example>

        <para><phrase role="tck-testable">If a
        <classname>ConstraintTarget</classname> is used in an illegal
        situation, a <classname>ConstraintDeclarationException</classname> is
        raised either at validation time or when the metadata is
        requested.</phrase> Examples of illegal situations are:</para>

        <itemizedlist>
          <listitem>
            <para role="tck-testable">using <literal>IMPLICIT</literal> in a
            situation that cannot be inferred (see the JavaDoc for the
            detailed rules),</para>
          </listitem>

          <listitem role="tck-testable">
            <para>using <literal>PARAMETERS</literal> on a constructor or
            method that has no parameter,</para>
          </listitem>

          <listitem role="tck-testable">
            <para>using <literal>RETURN_VALUE</literal> on a method with no
            return value,</para>
          </listitem>

          <listitem role="tck-testable">
            <para>using <literal>PARAMETERS</literal> or
            <literal>RETURN_VALUE</literal> on a type - class or interface -
            or on a field.</para>
          </listitem>
        </itemizedlist>

        <note>
          <title>Question</title>

          <para>An alternative model would be to have
          <classname>ConstraintTarget</classname> support
          <literal>IMPLICIT</literal>, <literal>ANNOTATED_ELEMENT</literal>
          and <literal>PARAMETERS</literal>. In this model,
          <literal>ANNOTATED_ELEMENT</literal> can be used in all "natural
          places" like types and fields and is synonym to
          <literal>RETURN_VALUE</literal> for methods and constructors.</para>
        </note>

        <para>Constraint users are encouraged to set the explicit
        <classname>ConstraintTarget</classname> target when using a constraint
        supporting both on a method or constructor as it would improve
        readability.</para>
      </section>

      <section>
        <title>Constraint specific parameter</title>

        <para>The constraint annotation definitions may define additional
        elements to parameterize the constraint. For example, a constraint
        that validates the length of a string can use an annotation element
        named <literal>length</literal> to specify the maximum length at the
        time the constraint is declared.</para>
      </section>
    </section>

    <section>
      <title>Examples</title>

      <example id="example-definition-notnull">
        <title>Simple constraint definition</title>

        <programlisting>package com.acme.constraint;

/**
 * Mark a String as representing a well formed order number
 */
@Documented
@Constraint(validatedBy = OrderNumberValidator.class)
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
public @interface OrderNumber {
    String message() default "{com.acme.constraint.OrderNumber.message}";
    Class&lt;?&gt;[] groups() default {};
    Class&lt;? extends Payload&gt;[] payload() default {};
}</programlisting>
      </example>

      <para><xref linkend="example-definition-notnull"/> marks a String as a
      well-formed order number. The constraint validator is implemented by
      <classname>OrderNumberValidator</classname>.</para>

      <example id="example-definition-crossparameter" revisionflag="added">
        <title>Simple cross-parameter constraint definition</title>

        <programlisting>package com.acme.constraint;

/**
 * Cross-parameter constraint ensuring that two date parameters
 * of a method are in the correct order.
 */
@Documented
@CrossParameterConstraint(validatedBy = DateParametersConsistentValidator.class)
@Target({ METHOD, CONSTRUCTOR, ANNOTATION_TYPE })
@Retention(RUNTIME)
public @interface DateParametersConsistent {
    String message() default "{com.acme.constraint.DateParametersConsistent.message}";
    Class&lt;?&gt;[] groups() default {};
    Class&lt;? extends Payload&gt;[] payload() default {};
}</programlisting>
      </example>

      <para revisionflag="added"><xref
      linkend="example-definition-crossparameter"/> shows a cross-parameter
      constraint which ensures that two date parameters of a method are in the
      correct order. The constraint validator is implemented by
      <classname>DateParametersConsistentValidator</classname>.</para>

      <example id="example-definition-genericandcrossparameter"
               revisionflag="added">
        <title>Constraint that is both generic and cross parameter</title>

        <programlisting>package com.acme.constraint;

/**
 * EL expression to be validated.
 * This constraint accepts any type and can validate both the
 * annotated type or apply restrictions across parameters.
 */
@Documented
@Constraint(validatedBy=ELAssertValidator.class)
@CrossParameterConstraint(validatedBy=ELAssertValidator.class)
@Target({ METHOD, CONSTRUCTOR, ANNOTATION_TYPE, FIELD })
@Retention(RUNTIME)
public @interface ELAssert {
    String message() default "{com.acme.constraint.DateParametersConsistent.message}";
    Class&lt;?&gt;[] groups() default {};
    Class&lt;? extends Payload&gt;[] payload() default {};
    ConstraintTarget validationAppliesTo() default ConstraintTarget.IMPLICIT;

    String expression;
}</programlisting>

        <programlisting>@ELAssert(expression="param[1]==param[2]", validationAppliesTo=ConstraintType.PARAMETERS)
public User createUser(String email, String password, String repreatPassword) { ... }</programlisting>
      </example>

      <para revisionflag="added"><xref
      linkend="example-definition-genericandcrossparameter"/> shows a
      constraint that can be applied both on the annotated element and across
      parameters of a method or a constructor. Note in this case the presence
      of <methodname>validationAppliesTo</methodname>.</para>

      <example id="example-definition-length">
        <title>Constraint definition with default parameter</title>

        <programlisting>package com.acme.constraint;

/**
 * A frequency in Hz as audible to human ear.
 * Adjustable to the age of the person.
 * Accept Numbers.
 */
@Documented
@Constraint(validatedBy = AudibleValidator.class)
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
public @interface Audible {
    Age age() default Age.YOUNG;
    String message() default "{com.acme.constraint.Audible.message}";
    Class&lt;?&gt;[] groups() default {};
    Class&lt;? extends Payload&gt;[] payload() default {};

    public enum Age {
        YOUNG,
        WONDERING
        OLD
    }
}</programlisting>
      </example>

      <para><xref linkend="example-definition-length"/> ensures that a given
      frequency is within the scope of human ears. The constraint definition
      includes an optional parameter that may be specified when the constraint
      is applied.</para>

      <example id="example-definition-mandatory">
        <title>Constraint definition with mandatory parameter</title>

        <programlisting>package com.acme.constraint;

/**
 * Defines the list of values accepted
 * Accepts int or Integer objects
 */
@Documented
@Constraint(validatedBy = DiscreteListOfIntegerValidator.class)
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
public @interface Acceptable {
    int[] value();
    String message() default "{com.acme.constraint.Acceptable.message}";
    Class&lt;?&gt;[] groups() default {};
    Class&lt;? extends Payload&gt;[] payload() default {};
}</programlisting>
      </example>

      <para><xref linkend="example-definition-mandatory"/> defines a list of
      acceptable values expressed as an array: the
      <methodname>value</methodname> property must be specified when the
      constraint is applied.</para>

      <example id="example-definition-illegal" revisionflag="added">
        <title>Illegal constraint definition</title>

        <programlisting>package com.acme.constraint;

/**
 * Cross-parameter constraint ensuring that two date parameters
 * of a method are in the correct order.
 */
@Documented
@Constraint(validatedBy = DateParametersConsistentValidator.class)
@CrossParameterConstraint(validatedBy = AnotherDateParametersConsistentValidator.class)
@Target({ METHOD, CONSTRUCTOR, ANNOTATION_TYPE })
@Retention(RUNTIME)
public @interface DateParametersConsistent {
    String message() default "{com.acme.constraint.DateParametersConsistent.message}";
    Class&lt;?&gt;[] groups() default {};
    Class&lt;? extends Payload&gt;[] payload() default {};
}</programlisting>
      </example>

      <para revisionflag="added"><xref linkend="example-definition-illegal"/>
      shows an illegal constraint definition ; an annotation may either be a
      constraint annotation or a cross-parameter annotation but not
      both.</para>
    </section>
  </section>

  <section id="constraintsdefinitionimplementation-multipleconstraints">
    <title>Applying multiple constraints of the same type</title>

    <para>It is often useful to declare the same constraint more than once to
    the same target, with different properties. A common example is the
    <literal>@Pattern</literal> constraint, which validates that its target
    matches a specified regular expression. Other constraints have this
    requirement as well. The same constraint type can belong to different
    groups and have specific error messages depending on the targeted
    group.</para>

    <para>To support this requirement, <phrase role="tck-testable">the bean
    validation provider treats regular annotations (annotations not annotated
    by <classname>@Constraint</classname>) whose <literal>value</literal>
    element has a return type of an array of constraint annotations in a
    special way. Each element in the <literal>value</literal> array are
    processed by the Bean Validation implementation as regular constraint
    annotations.</phrase> This means that each constraint specified in the
    <literal>value</literal> element is applied to the target. The annotation
    must have retention <literal>RUNTIME</literal> and can be applied on a
    type, field, property or another annotation. It is recommended to use the
    same set of targets as the initial constraint.</para>

    <para>Note to constraint designers: each constraint annotation should be
    coupled with its corresponding multi-valued annotation. The specification
    recommends, though does not mandate, the definition of an inner annotation
    named <classname>List</classname>.</para>

    <example>
      <title>Multi-valued constraint definition</title>

      <programlisting>/**
 * Validate a zipcode for a given country 
 * The only supported type is String
 */
@Documented
@Constraint(validatedBy = ZipCodeValidator.class)
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
public @interface ZipCode {

    String countryCode();

    String message() default "{com.acme.constraint.ZipCode.message}";

    Class&lt;?&gt;[] groups() default {};

    Class&lt;? extends Payload&gt;[] payload() default {};

    /**
     * Defines several @ZipCode annotations on the same element
     * @see (@link ZipCode}
     */
    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
    @Retention(RUNTIME)
    @Documented
    @interface List {
        ZipCode[] value();
    }    
}</programlisting>
    </example>

    <example>
      <title>Multi-valued constraint declaration</title>

      <programlisting>public class Address {
    @ZipCode.List( {
            @ZipCode(countryCode="fr", groups=Default.class
                     message = "zip code is not valid"),
            @ZipCode(countryCode="fr", groups=SuperUser.class
                     message = "zip code invalid. Requires overriding before saving.")
            } )
    private String zipcode;
}</programlisting>
    </example>

    <para>In this example, both constraints apply to the
    <methodname>zipcode</methodname> field but with different groups and with
    different error messages.</para>

    <para>Using two different multi-constraint annotations for the same
    underlying constraint type on the same target (i.e. class or property) is
    not considered portable and is discouraged.</para>
  </section>

  <section id="constraintsdefinitionimplementation-constraintcomposition">
    <title>Constraint composition</title>

    <para>This specification allows you to compose constraints to create
    higher level constraints.</para>

    <para>Constraint composition is useful in several ways:</para>

    <itemizedlist>
      <listitem>
        <para>Avoid duplication and facilitate reuse of more primitive
        constraints.</para>
      </listitem>

      <listitem>
        <para>Expose primitive constraints as part of a composed constraint in
        the metadata API and enhance tool awareness.</para>
      </listitem>
    </itemizedlist>

    <para>Composition is done by annotating a constraint annotation with the
    composing constraint annotations.</para>

    <example>
      <title>Composition is done by annotating the composed constraint</title>

      <programlisting>@Pattern(regexp="[0-9]*")
@Size(min=5, max=5)
@Constraint(validatedBy = FrenchZipcodeValidator.class)
@Documented
@Target({ANNOTATION_TYPE, METHOD, FIELD, CONSTRUCTOR, PARAMETER})
@Retention(RUNTIME)
public @interface FrenchZipcode {
    String message() default "Wrong zipcode";
    Class&lt;?&gt;[] groups() default {};
    Class&lt;? extends Payload&gt;[] payload() default {};

    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
    @Retention(RUNTIME)
    @Documented
    @interface List {
        FrenchZipcode[] value();
    }
}</programlisting>
    </example>

    <para>Annotating an element with <classname>@FrenchZipcode</classname>
    (the composed annotation) is equivalent to annotating it with
    <classname>@Pattern(regexp="[0-9]*")</classname>, <classname>@Size(min=5,
    max=5)</classname> (the composing annotations) and
    <classname>@FrenchZipcode</classname>. <phrase
    role="tck-testable tck-needs-update">More formally, each constraint
    annotation hosted on a constraint annotation is applied to the target
    element and this is done recursively.</phrase> <phrase
    role="tck-testable">Note that the main annotation and its constraint
    validation implementation is also applied.</phrase> <phrase
    role="tck-testable">By default, each failing constraint generates an error
    report.</phrase> <phrase role="tck-testable">Groups from the main
    constraint annotation are inherited by the composing annotations.</phrase>
    <phrase role="tck-testable">Any <methodname>groups</methodname> definition
    on a composing annotation is ignored. </phrase><phrase
    role="tck-testable">Payload from the main constraint annotation is
    inherited by the composing annotations.</phrase> <phrase
    role="tck-testable">Any <methodname>payload</methodname> definition on a
    composing annotation is ignored. </phrase><phrase revisionflag="added"
    role="tck-testable">the constraint target from the main constraint
    annotation is inherited by the composing annotations.</phrase><phrase
    revisionflag="added" role="tck-testable"> Any
    <methodname>validationAppliesTo</methodname> definition on a composing
    annotation is ignored.</phrase></para>

    <para><phrase role="tck-testable">The <phrase
    revisionflag="deleted">property</phrase> type upon which composed
    constraint is placed must be compatible with all constraints (composing
    and composed).</phrase> A constraint designer should ensure that such a
    type exists and list in the JavaDoc all the compatible types.</para>

    <para revisionflag="added">Both composed and composing constraints should
    share the same constraint type. In particular, it is not legal to mix a
    pure generic <classname>@Constraint</classname> and a pure cross-parameter
    <classname>@CrossParameterConstraint</classname>.</para>

    <para>It is possible to ensure that composing annotations do not raise
    individual error reports. In this scenario, if one or more composing
    annotations are invalid, the main constraint is automatically considered
    invalid and the corresponding error report is generated. To mark a
    constraint as raising a single constraint error report if either the
    composed or one of the composing constraints fail, use the
    <classname>@ReportAsSingleViolation</classname> annotation.</para>

    <example>
      <title>If any of the composing constraints fail, the error report
      corresponding to @FrenchZipcode is raised and none other.</title>

      <programlisting>@Pattern(regexp="[0-9]*")
@Size(min=5, max=5)
@ReportAsSingleViolation
@Constraint(validatedBy = FrenchZipcodeValidator.class)
@Documented
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
public @interface FrenchZipcode {
    String message() default "Wrong zipcode";
    Class&lt;?&gt;[] groups() default {};
    Class&lt;? extends Payload&gt;[] payload() default {};

    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
    @Retention(RUNTIME)
    @Documented
    @interface List {
        FrenchZipcode[] value();
    }
}</programlisting>
    </example>

    <para>The definition of <classname>@ReportAsSingleViolation</classname> is
    as follows.</para>

    <programlisting revisionflag="changed">/**
 * A constraint annotation hosting this annotation will return the
 * composed annotation error report if any of the composing annotations fail.
 * The error reports of each individual composing constraint are ignored.
 *
 * &lt;p&gt;
 * Note: Evaluation of composed constraints stops on the first validation
 * error in case the composing constraint is annotated with
 * {@code @ReportAsSingleViolation}.
 * &lt;/p&gt;
 *
 * @author Emmanuel Bernard
 */
@Target({ ANNOTATION_TYPE })
@Retention(RUNTIME)
public @interface ReportAsSingleViolation {
}</programlisting>

    <para revisionflag="changed" role="tck-testable">More specifically, if a
    composed constraint is marked as
    <classname>@ReportAsSingleViolation</classname>, the evaluation of the
    composing constraints stops at the first failing constraint and the error
    report corresponding to the composed constraint is generated and
    returned.</para>

    <para role="tck-testable">Composing annotations can define the value of
    <literal>message</literal> and custom attributes (excluding
    <methodname>groups</methodname> and <methodname>payload</methodname>) but
    these are fixed in the composed constraint definition.</para>

    <example>
      <title>Composing annotations can use attributes. They are fixed for a
      given main annotation. All @FrenchZipcode constraints have a @Size
      restricted to 5.</title>

      <programlisting>@Pattern(regexp="[0-9]*")
@Size(min=5, max=5)
@Constraint(validatedBy = FrenchZipcodeValidator.class)
@Documented
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
public @interface FrenchZipcode {
    String message() default "Wrong zipcode";
    Class&lt;?&gt;[] groups() default {};
    Class&lt;? extends Payload&gt;[] payload() default {};

    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
    @Retention(RUNTIME)
    @Documented
    @interface List {
        FrenchZipcode[] value();
    }
}</programlisting>
    </example>

    <para role="tck-testable">It is possible to override attributes and
    messages defined on a composing annotation. An attribute from the main
    annotation is used to override one or more attributes of the composing
    annotations. Such an attribute is annotated with the
    <classname>@OverridesAttribute</classname> annotation or its multivalued
    equivalent <classname>@OverridesAttribute.List</classname>.</para>

    <example id="example-composing-overridden">
      <title>Attributes from composing annotations can be overridden by
      attributes from the composed annotation.</title>

      <programlisting>@Pattern(regexp="[0-9]*")
@Size
@Constraint(validatedBy = FrenchZipcodeValidator.class)
@Documented
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
public @interface FrenchZipcode {
    String message() default "Wrong zipcode";
    Class&lt;?&gt;[] groups() default {};
    Class&lt;? extends Payload&gt;[] payload() default {};

    @OverridesAttribute.List( {
        @OverridesAttribute(constraint=Size.class, name="min"),
        @OverridesAttribute(constraint=Size.class, name="max") } )
    int size() default 5;

    @OverridesAttribute(constraint=Size.class, name="message")
    String sizeMessage() default "{com.acme.constraint.FrenchZipcode.zipcode.size}";

    @OverridesAttribute(constraint=Pattern.class, name="message")
    String numberMessage() default "{com.acme.constraint.FrenchZipcode.number.size}";

    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
    @Retention(RUNTIME)
    @Documented
    @interface List {
        FrenchZipcode[] value();
    }
}</programlisting>
    </example>

    <para>The value of the composed constraint attribute annotated with
    <classname>@OverridesAttribute</classname>
    (<methodname>@FrenchZipcode.sizeMessage</methodname>) is applied to the
    composing constraint attribute named after
    <methodname>OverridesAttribute.name</methodname> and hosted on the
    composing constraint of type
    <methodname>OverridesAttribute.constraint</methodname>
    (<methodname>@Size.message</methodname>). Similarly,
    <classname>@FrenchZipcode.numberMessage</classname> value is mapped to
    <classname>@Pattern.message</classname>.</para>

    <para>If left undefined, the default value for
    <methodname>@OverridesAttribute.name</methodname> is the name of the
    composed constraint attribute hosting the
    <classname>@OverridesAttribute</classname> annotation.</para>

    <para role="tck-testable">The types of the overridden and overriding
    attributes must be identical.</para>

    <note>
      <para><phrase role="tck-testable">A composing constraint can itself be a
      composed constraint. In this case, attribute values are overridden
      recursively according to the described rules.</phrase> Note however,
      that a forwarding rule (as defined by
      <classname>@OverridesAttribute</classname>) is only applied to the
      direct composing constraints.</para>
    </note>

    <para>Using <xref linkend="example-composing-overridden"/>,</para>

    <programlisting>@FrenchZipcode(size=9, sizeMessage="Zipcode should be of size {max}")</programlisting>

    <para>is equivalent to</para>

    <programlisting>@FrenchZipcode</programlisting>

    <para>if <classname>@FrenchZipcode</classname> is defined as</para>

    <programlisting>@Pattern(regexp="[0-9]*")
@Size(min=9, max=9, message="Zipcode should be of size {max}")
@Constraint(validatedBy = FrenchZipcodeValidator.class)
@Documented
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
public @interface FrenchZipcode {
    String message() default "Wrong zipcode";
    Class&lt;?&gt;[] groups() default {};
    Class&lt;? extends Payload&gt;[] payload() default {};

    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
    @Retention(RUNTIME)
    @Documented
    @interface List {
        FrenchZipcode[] value();
    }
}</programlisting>

    <para><phrase role="tck-testable">If a constraint is used more than once
    as a composing constraint, the multi value constraints model as described
    in <xref
    linkend="constraintsdefinitionimplementation-multipleconstraints"/> is
    used.</phrase> <phrase role="tck-testable">To select a specific composing
    constraint, <methodname>OverridesAttribute.constraintIndex</methodname> is
    used. It represents the constraint index in the
    <methodname>value</methodname> array.</phrase> <phrase
    role="tck-testable">If <literal>index</literal> is undefined, the single
    constraint declaration is targeted.</phrase></para>

    <example>
      <title>Use of constraintIndex in @OverridesAttribute</title>

      <programlisting>@Pattern.List( {
    @Pattern(regexp="[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,4}"), //email
    @Pattern(regexp=".*?emmanuel.*?") //emmanuel
} )
@Constraint(validatedBy={})
@Documented
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
public @interface EmmanuelsEmail {
    String message() default "Not emmanuel's email";

    @OverridesAttribute(constraint=Pattern.class, name="message", constraintIndex=0)
    String emailMessage() default "Not an email";

    @OverridesAttribute(constraint=Pattern.class, name="message", constraintIndex=1)
    String emmanuelMessage() default "Not Emmanuel";

    Class&lt;?&gt;[] groups() default {};
    Class&lt;? extends Payload&gt;[] y() default {};

    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
    @Retention(RUNTIME)
    @Documented
    @interface List {
        EmmanuelsEmail[] value();
    }
}</programlisting>
    </example>

    <para><classname>@OverridesAttribute</classname> definition is as
    follows:</para>

    <programlisting>/**
 * Mark an attribute as overriding the attribute of a composing constraint.
 * Both attributes must share the same type.
 *
 * @author Emmanuel Bernard
 */
@Retention(RUNTIME)
@Target({ METHOD })
public @interface OverridesAttribute {
    /**
     * @return Constraint type the attribute is overriding
     */
    Class&lt;? extends Annotation&gt; constraint();

    /**
     * Name of the Constraint attribute overridden.
     * Defaults to the name of the attribute hosting &lt;code&gt;@OverridesAttribute&lt;/code&gt;.
     *
     * @return name of constraint attribute overridden.
     */
    String name();

    /**
     * The index of the targeted constraint declaration when using
     * multiple constraints of the same type.
     * The index represents the index of the constraint in the value() array.
     *
     * By default, no index is defined and the single constraint declaration
     * is targeted
     *
     * @return constraint declaration index if multivalued annotation is used
     */
    int constraintIndex() default -1;

    /**
     * Defines several @OverridesAttribute annotations on the same element
     * @see javax.validation.OverridesAttribute
     */
    @Documented
    @Target({ METHOD })
    @Retention(RUNTIME)
    public @interface List {
        OverridesAttribute[] value();
    }
}</programlisting>

    <para>The following elements uniquely identify an overridden constraint
    attribute:</para>

    <itemizedlist>
      <listitem>
        <para><methodname>OverridesAttribute.constraint</methodname></para>
      </listitem>

      <listitem>
        <para><methodname>OverridesAttribute.name</methodname></para>
      </listitem>

      <listitem>
        <para><methodname>OverridesAttribute.constraintIndex</methodname></para>
      </listitem>
    </itemizedlist>

    <para role="tck-testable tck-needs-update">If the composition is invalid,
    e.g. <itemizedlist>
        <listitem>
          <para>infinitely recursive composition</para>
        </listitem>

        <listitem>
          <para>wrong attribute overriding</para>
        </listitem>

        <listitem>
          <para>a single attribute mapped to more than one source
          attribute</para>
        </listitem>

        <listitem>
          <para revisionflag="added">A composing and composed constraint
          marked as different constraint types (i.e., generic with
          <classname>@Constraint</classname> and cross-parameter with
          <classname>@CrossParameterConstraint</classname>)</para>
        </listitem>

        <listitem>
          <para>etc.</para>
        </listitem>
      </itemizedlist>a <classname>ConstraintDefinitionException</classname> is
    raised either at validation time or when the metadata is requested.</para>

    <para>Constraint designers are encouraged to make use of composition
    (recursively or not) based on the built-in constraints defined by the
    specification. The composing constraints are exposed through the Bean
    Validation metadata API (<xref
    linkend="constraintmetadata-constraintdescriptor"/>). This metadata is
    particularly useful for third-party metadata consumers like persistence
    frameworks generating database schemas (such as Java Persistence) or
    presentation frameworks.</para>
  </section>

  <section id="constraintsdefinitionimplementation-validationimplementation">
    <title>Constraint validation implementation</title>

    <para><phrase role="tck-testable">A constraint validation implementation
    performs the validation of a given constraint annotation for a given
    type.</phrase> <phrase role="tck-testable tck-needs-update">The
    implementation classes are specified by the <literal>validatedBy</literal>
    element of the <classname>@Constraint</classname> <phrase
    revisionflag="added">respectively
    <classname>@CrossParameterConstraint</classname></phrase> annotation that
    decorates the constraint definition.</phrase> <phrase
    role="tck-not-testable">The constraint validation implementation
    implements the <classname>ConstraintValidator</classname>
    interface.</phrase></para>

    <programlisting>/**
 * Defines the logic to validate a given constraint A
 * for a given object type T.
 * Implementations must comply to the following restriction:
 * &lt;ul&gt;
 * &lt;li&gt;T must resolve to a non parameterized type&lt;/li&gt;
 * &lt;li&gt;or generic parameters of T must be unbounded
 * wildcard types&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * @author Emmanuel Bernard
 * @author Hardy Ferentschik
 */
public interface ConstraintValidator&lt;A extends Annotation, T&gt; {
    /**
     * Initialize the validator in preparation for isValid calls.
     * The constraint annotation for a given constraint declaration
     * is passed.
     * &lt;p/&gt;
     * This method is guaranteed to be called before any use of this instance for
     * validation.
     *
     * @param constraintAnnotation annotation instance for a given constraint declaration
     */
    void initialize(A constraintAnnotation);

    /**
     * Implement the validation logic.
     * The state of &lt;code&gt;value&lt;/code&gt; must not be altered.
     *
     * This method can be accessed concurrently, thread-safety must be ensured
     * by the implementation.
     *
     * @param value object to validate
     * @param context context in which the constraint is evaluated
     *
     * @return false if &lt;code&gt;value&lt;/code&gt; does not pass the constraint
     */
    boolean isValid(T value, ConstraintValidatorContext context);
}</programlisting>

    <para role="tck-not-testable">Some restrictions apply on the generic type
    <classname>T</classname> (used in the <methodname>isValid</methodname>
    method). <classname>T</classname> must <itemizedlist>
        <listitem>
          <para>resolve to a non parameterized type (i.e. because the type is
          not using generics or because the raw type is used instead of the
          generic version)</para>
        </listitem>

        <listitem>
          <para>or generic parameters of <classname>T</classname> must be
          unbounded wildcard types (i.e. <literal>&lt;?&gt;</literal>).</para>
        </listitem>
      </itemizedlist></para>

    <para revisionflag="added" role="tck-testable">If <classname>A</classname>
    is a cross-parameter constraint annotation type, <classname>T</classname>
    must resolve to <classname>Object[]</classname> in order to have the array
    of parameter values passed to the <methodname>isValid()</methodname>
    method.</para>

    <para><xref
    linkend="example-constraintsdefinitionimplementation-validationimplementation-validdef"/>
    shows some examples of valid definitions.</para>

    <example id="example-constraintsdefinitionimplementation-validationimplementation-validdef"
             revisionflag="changed">
      <title>Valid ConstraintValidator definitions</title>

      <programlisting>//String is not making use of generics
public class SizeValidatorForString implements&lt;Size, String&gt; {...}

//Collection uses generics but the raw type is used
public class SizeValidatorForCollection implements&lt;Size, Collection&gt; {...}

//Collection uses generics and unbounded windcard type
public class SizeValidatorForCollection implements&lt;Size, Collection&lt;?&gt;&gt; {...}

//Validator for cross-parameter constraint
public class DateParametersConsistentValidator implements&lt;DateParametersConsistent, Object[]&gt; {...}</programlisting>
    </example>

    <para>And some invalid definitions in <xref
    linkend="example-constraintsdefinitionimplementation-validationimplementation-invaliddef"/>.</para>

    <example id="example-constraintsdefinitionimplementation-validationimplementation-invaliddef">
      <title>Invalid ConstraintValidator definitions</title>

      <programlisting>//parameterized type
public class SizeValidatorForString implements&lt;Size, Collection&lt;String&gt;&gt; {...}

//parameterized type using bounded wildcard
public class SizeValidatorForCollection implements&lt;Size, Collection&lt;? extends Address&gt;&gt; {...}</programlisting>
    </example>

    <note>
      <para>This restriction is not a theoretical limitation and a future
      version of the specification will likely allow it.</para>
    </note>

    <para revisionflag="changed">The life cycle of a constraint validation
    implementation instance is undefined. Bean Validation providers are
    allowed to cache <classname>ConstraintValidator</classname> instances
    retrieved from the
    <classname>ConstraintValidatorFactory</classname>.</para>

    <!--EBE should we make explicit that instances cannot be shared if the annotations attributes are not the same?-->

    <para role="tck-testable">The <methodname>initialize</methodname> method
    is called by the Bean validation provider prior to any use of the
    constraint implementation.</para>

    <para><phrase role="tck-testable">The <methodname>isValid</methodname>
    method is evaluated by the Bean Validation provider each time a given
    value is validated.</phrase> <phrase role="tck-not-testable">It returns
    <literal>false</literal> if the value is not valid,
    <literal>true</literal> otherwise.</phrase> <phrase
    role="tck-not-testable"><literal>isValid</literal> implementations must be
    thread-safe.</phrase></para>

    <para><phrase role="tck-testable">If the property is of an unanticipated
    type, an <literal>UnexpectedTypeException</literal> is raised.</phrase>
    <classname>ConstraintValidator</classname> implementations raise this
    exception themselves if they receive an unsupported type. However,
    constraint designers are encouraged to make use of specialized
    <classname>ConstraintValidator</classname> implementations and delegate
    the type resolution to the Bean Validation provider (see the type matching
    algorithm described in <xref linkend="typevalidatorresolution"/>).</para>

    <para role="tck-testable">If an exception occurs either in the
    <classname>initialize</classname> or <classname>isValid</classname>
    method, the runtime exception is wrapped into a
    <classname>ValidationException</classname> by the Bean Validation
    engine.</para>

    <para role="tck-not-testable">The constraint validation implementation is
    not allowed to change the state of the value passed to
    <methodname>isValid</methodname>.</para>

    <note>
      <para>While not mandatory, it is considered a good practice to split the
      core constraint validation from the not null constraint validation (for
      example, an <classname>@Email</classname> constraint will return true on
      a null object, i.e. will not take care of the
      <classname>@NotNull</classname> validation)</para>

      <para><code>null</code> can have multiple meanings but is commonly used
      to express that a value does not make sense, is not available or is
      simply unknown. Those constraints on the value are orthogonal in most
      cases to other constraints. For example a String, if present, must be an
      email but can be null. Separating both concerns is a good
      practice.</para>
    </note>

    <para>The <classname>ConstraintValidatorContext</classname> object passed
    to the <methodname>isValid</methodname> method carries information and
    operations available in the context the constraint is validated to.</para>

    <programlisting revisionflag="changed">/**
 * Provide contextual data and operation when applying a given constraint validator.
 *
 * At least one {@code ConstraintViolation} must be defined (either the default one,
 * of if the default {@code ConstraintViolation} is disabled, a custom one).
 *
 * @author Emmanuel Bernard
 */
public interface ConstraintValidatorContext {
    /**
     * Disable the default {@code ConstraintViolation} object generation (which
     * is using the message template declared on the constraint).
     * Useful to set a different violation message or generate a {@code ConstraintViolation}
     * based on a different property.
     */
    void disableDefaultConstraintViolation();

    /**
     * @return the current un-interpolated default message.
     */
    String getDefaultConstraintMessageTemplate();

    /**
     * Return an constraint violation builder building an violation report
     * allowing to optionally associate it to a sub path.
     * The violation message will be interpolated.
     * &lt;p/&gt;
     * To create the {@code ConstraintViolation}, one must call either one of
     * the #addConstraintViolation() methods available in one of the
     * interfaces of the fluent API.
     * If another method is called after #addConstraintViolation() on
     * {@code ConstraintViolationBuilder} or any of its associated nested interfaces
     * an {@code IllegalStateException} is raised.
     * &lt;p/&gt;
     * If {@code isValid} returns {@code false}, a {@code ConstraintViolation}
     * object will be built per ConstraintViolation report including the default one (unless
     * {@link #disableDefaultConstraintViolation()} has been called).
     * &lt;p/&gt;
     * {@code ConstraintViolation} objects generated from such a call
     * contain the same contextual information (root bean, path and so on) unless
     * the path has been overridden.
     * &lt;p/&gt;
     * To create a different {@code ConstraintViolation}, a new constraint violation builder
     * has to be retrieved from {@code ConstraintValidatorContext}
     *
     * Here are a few usage examples:
     * &lt;pre&gt;
     * {@code
     * //assuming the following domain model
     * public class User {
     *     public Map&lt;String,Address&gt; getAddresses() { ... }
     * }
     *
     * public class Address {
     *     public String getStreet() { ... }
     *     public Country getCountry() { ... }
     * }
     *
     * public class Country {
     *     public String getName() { ... }
     * }
     *
     * //From a property-level constraint on User.addresses
     * //Build a constraint violation on the default path - ie. the "addresses" property
     * context.buildConstraintViolationWithTemplate( "this detail is wrong" )
     *             .addConstraintViolation();
     *
     * //From a class level constraint on Address
     * //Build a constraint violation on the default path + "street"
     * //ie. the street property of Address
     * context.buildConstraintViolationWithTemplate( "this detail is wrong" )
     *             .addPropertyNode( "street" )
     *             .addConstraintViolation();
     *
     * //From a property-level constraint on  User.addresses
     * //Build a constraint violation on the default path + the bean stored
     * //under the "home" key in the map
     * context.buildConstraintViolationWithTemplate( "Incorrect home address" )
     *             .addBeanNode()
     *                 .inIterable().atKey( "home" )
     *             .addConstraintViolation();
     *
     * //From a class level constraint on User
     * //Build a constraint violation on the default path + addresses["home"].country.name
     * //ie. property "country.name" on the object stored under "home" in the map
     * context.buildConstraintViolationWithTemplate( "this detail is wrong" )
     *             .addPropertyNode( "addresses" )
     *             .addPropertyNode( "country" )
     *                 .inIterable().atKey( "home" )
     *             .addPropertyNode( "name" )
     *             .addConstraintViolation();
     * }
     * &lt;/pre&gt;
     * &lt;p/&gt;
     * Cross-parameter constraints on a method can create a node specific
     * to a particular parameter if required. Let's explore a few examples:
     * &lt;p/&gt;
     * &lt;pre&gt;{@code
     * //Cross-parameter constraint on method createUser(String password, String passwordRepeat)
     * //Build a constraint violation on the default path + "passwordRepeat"
     * context.buildConstraintViolationWithTemplate("Passwords do not match")
     *                 .addParameterNode(1)
     *                 .addConstraintViolation();
     *
     * //Cross-parameter constraint on a method
     * //mergeAddresses(Map&lt;String,Address&gt; addresses, Map&lt;String,Address&gt; otherAddresses)
     * //Build a constraint violation on the default path + "otherAddresses["home"]
     * //ie. the Address bean hosted in the "home" key of the "otherAddresses" map parameter
     * context.buildConstraintViolationWithTemplate(
     *         "Map entry home present in both and does not match")
     *                 .addParameterNode(1)
     *                 .addBeanNode()
     *                     .inIterable().atKey("home")
     *                 .addConstraintViolation();
     *
     * //Cross-parameter constraint on a method
     * //mergeAddresses(Map&lt;String,Address&gt; addresses, Map&lt;String,Address&gt; otherAddresses)
     * //Build a constraint violation on the default path + "otherAddresses["home"].city
     * //ie. on the "city" property of the Address bean hosted in
     * //the "home" key of the "otherAddresses" map
     * context.buildConstraintViolationWithTemplate(
     *         "Map entry home present in both but city does not match")
     *                 .addParameterNode(1)
     *                 .addPropertyNode("city")
     *                     .inIterable().atKey("home")
     *                 .addConstraintViolation();
     * }
     * &lt;/pre&gt;
     *
     * @param messageTemplate new un-interpolated constraint message.
     * @return Returns an constraint violation builder
     */
    ConstraintViolationBuilder buildConstraintViolationWithTemplate(String messageTemplate);

    /**
     * Return an instance of the specified type allowing access to
     * provider-specific APIs. If the Bean Validation provider
     * implementation does not support the specified class,
     * {@code ValidationException} is thrown.
     *
     * @param type the class of the object to be returned.
     *
     * @return an instance of the specified class
     *
     * @throws ValidationException if the provider does not support the call.
     *
     * @since 1.1
     */
    &lt;T&gt; T unwrap(Class&lt;T&gt; type);

    /**
     * {@code ConstraintViolation} builder allowing to optionally associate
     * the violation report to a sub path.
     *
     * To create the {@code ConstraintViolation}, one must call either one of
     * the #addConstraintViolation() methods available in one of the
     * interfaces of the fluent API.
     * If another method is called after #addConstraintViolation() on
     * {@code ConstraintViolationBuilder} or any of its associated objects
     * an {@code IllegalStateException} is raised.
     * 
     */
    interface ConstraintViolationBuilder {
        /**
         * Add a node to the path the {@code ConstraintViolation} will be associated to.
         *
         * {@code name} describes a single property. In particular,
         * dot (.) is not allowed.
         *
         * @param name property name
         * @return a builder representing node {@code name}
         * @deprecated since 1.1 - replaced by {@code addPropertyNode}, {@code addBeanNode} and {@code addParameterNode}
         */
        @Deprecated
        NodeBuilderDefinedContext addNode(String name);

        /**
         * Add a property node to the path the {@code ConstraintViolation} will be associated to.
         *
         * {@code name} describes a single property. In particular,
         * dot (.) is not allowed.
         *
         * @param name property name
         * @return a builder representing node {@code name}
         * @throws IllegalArgumentException if the name is null
         *
         * @since 1.1
         */
        NodeBuilderCustomizableContext addPropertyNode(String name);

        /**
         * Add a bean node (class-level) to the path the {@code ConstraintViolation} will be associated to.
         * Note that bean nodes are always leaf nodes.
         *
         * @return a builder representing the bean node
         *
         * @since 1.1
         */
        LeafNodeBuilderCustomizableContext addBeanNode();

        /**
         * Add a method parameter node to the path the {@code ConstraintViolation} will be associated to.
         * The parameter index must be valid (ie. within the boundaries of the method parameter indexes).
         *
         * @param index the parameter index
         * @return a builder representing the index-th parameter node
         * @throws IllegalArgumentException if the index is not valid
         *
         * @since 1.1
         */
        NodeBuilderDefinedContext addParameterNode(int index);

        /**
         * Add the new {@code ConstraintViolation} to be generated if the
         * constraint validator marks the value as invalid.
         * Methods of this {@code ConstraintViolationBuilder} instance and its nested
         * objects throw {@code IllegalStateException} from now on.
         *
         * @return the {@code ConstraintValidatorContext} instance the
         *           {@code ConstraintViolationBuilder} comes from
         */
        ConstraintValidatorContext addConstraintViolation();

        /**
         * Represent a node whose context is known
         * (ie. index, key and isInIterable)
         * and that is a leaf node (ie. no subnode can be added).
         *
         * @since 1.1
         */
        interface LeafNodeBuilderDefinedContext {

            /**
             * Add the new {@code ConstraintViolation} to be generated if the
             * constraint validator marks the value as invalid.
             * Methods of the {@code ConstraintViolationBuilder} instance this object
             * comes from and the constraint violation builder nested
             * objects throw {@code IllegalStateException} after this call.
             *
             * @return {@code ConstraintValidatorContext} instance the
             *           {@code ConstraintViolationBuilder} comes from
             */
            ConstraintValidatorContext addConstraintViolation();
        }

        /**
         * Represent a node whose context is
         * configurable (ie. index, key and isInIterable)
         * and that is a leaf node (ie. no subnode can be added).
         *
         * @since 1.1
         */
        interface LeafNodeBuilderCustomizableContext {

            /**
             * Mark the node as being in an {@code Iterable} or a {@code Map}
             * 
             * @return a builder representing iterable details
             */
            LeafNodeContextBuilder inIterable();

            /**
             * Add the new {@code ConstraintViolation} to be generated if the
             * constraint validator mark the value as invalid.
             * Methods of the {@code ConstraintViolationBuilder} instance this object
             * comes from and the constraint violation builder nested
             * objects throw {@code IllegalStateException} after this call.
             *
             * @return {@code ConstraintValidatorContext} instance the
             *           {@code ConstraintViolationBuilder} comes from
             */
            ConstraintValidatorContext addConstraintViolation();
        }

        /**
         * Represent refinement choices for a node which is
         * in an {@code Iterator} or {@code Map}.
         * If the iterator is an indexed collection or a map,
         * the index or the key should be set.
         * The node is a leaf node (ie. no subnode can be added).
         *
         * @since 1.1
         */
        interface LeafNodeContextBuilder {

            /**
             * Define the key the object is into the {@code Map}
             *
             * @param key map key
             * @return a builder representing the current node
             */
            LeafNodeBuilderDefinedContext atKey(Object key);

            /**
             * Define the index the object is into the {@code List} or array
             *
             * @param index index
             * @return a builder representing the current node
             */
            LeafNodeBuilderDefinedContext atIndex(Integer index);

            /**
             * Add the new {@code ConstraintViolation} to be generated if the
             * constraint validator mark the value as invalid.
             * Methods of the {@code ConstraintViolationBuilder} instance this object
             * comes from and the constraint violation builder nested
             * objects throw {@code IllegalStateException} after this call.
             *
             * @return {@code ConstraintValidatorContext} instance the
             *           {@code ConstraintViolationBuilder} comes from
             */
            ConstraintValidatorContext addConstraintViolation();
        }

        /**
         * Represent a node whose context is known
         * (ie. index, key and isInIterable)
         * and that is not necessarily a leaf node (ie. subnodes can
         * be added).
         */
        interface NodeBuilderDefinedContext {

            /**
             * Add a node to the path the {@code ConstraintViolation} will be associated to.
             *
             * {@code name} describes a single property. In particular,
             * dot (.) is not allowed.
             *
             * @param name property name
             * @return a builder representing node {@code name}
             * @deprecated since 1.1 - replaced by {@code addPropertyNode} and {@code addBeanNode}
             */
            @Deprecated
            NodeBuilderCustomizableContext addNode(String name);

            /**
             * Add a property node to the path the {@code ConstraintViolation} will be associated to.
             *
             * {@code name} describes a single property. In particular,
             * dot (.) is not allowed.
             *
             * @param name property name
             * @return a builder representing node {@code name}
             * @throws IllegalArgumentException if the name is null
             *
             * @since 1.1
             */
            NodeBuilderCustomizableContext addPropertyNode(String name);

            /**
             * Add a bean node (class-level) to the path the {@code ConstraintViolation} will be associated to.
             * Note that bean nodes are always leaf nodes.
             *
             * @return a builder representing the bean node
             *
             * @since 1.1
             */
            LeafNodeBuilderCustomizableContext addBeanNode();

            /**
             * Add the new {@code ConstraintViolation} to be generated if the
             * constraint validator marks the value as invalid.
             * Methods of the {@code ConstraintViolationBuilder} instance this object
             * comes from and the constraint violation builder nested
             * objects throw {@code IllegalStateException} after this call.
             *
             * @return {@code ConstraintValidatorContext} instance the
             *           {@code ConstraintViolationBuilder} comes from
             */
            ConstraintValidatorContext addConstraintViolation();
        }

        /**
         * Represent a node whose context is
         * configurable (ie. index, key and isInIterable)
         * and that is not necessarily a leaf node (ie. subnodes can
         * be added).
         */
        interface NodeBuilderCustomizableContext {

            /**
             * Mark the node as being in an {@code Iterable} or a {@code Map}
             *
             * @return a builder representing iterable details
             */
            NodeContextBuilder inIterable();

            /**
             * Add a node to the path the {@code ConstraintViolation} will be associated to.
             *
             * {@code name} describes a single property. In particular,
             * dot (.) is not allowed.
             *
             * @param name property name
             * @return a builder representing node {@code name}
             * @deprecated since 1.1 - replaced by {@code addPropertyNode} and {@code addBeanNode}
             */
            @Deprecated
            NodeBuilderCustomizableContext addNode(String name);

            /**
             * Add a property node to the path the {@code ConstraintViolation} will be associated to.
             *
             * {@code name} describes a single property. In particular,
             * dot (.) is not allowed.
             *
             * @param name property name
             * @return a builder representing node {@code name}
             * @throws IllegalArgumentException if the name is null
             *
             * @since 1.1
             */
            NodeBuilderCustomizableContext addPropertyNode(String name);

            /**
             * Add a bean node (class-level) to the path the {@code ConstraintViolation} will be associated to.
             * Note that bean nodes are always leaf nodes.
             *
             * @return a builder representing the bean node
             *
             * @since 1.1
             */
            LeafNodeBuilderCustomizableContext addBeanNode();

            /**
             * Add the new {@code ConstraintViolation} to be generated if the
             * constraint validator mark the value as invalid.
             * Methods of the {@code ConstraintViolationBuilder} instance this object
             * comes from and the constraint violation builder nested
             * objects throw {@code IllegalStateException} after this call.
             *
             * @return {@code ConstraintValidatorContext} instance the
             *           {@code ConstraintViolationBuilder} comes from
             */
            ConstraintValidatorContext addConstraintViolation();
        }

        /**
         * Represent refinement choices for a node which is
         * in an {@code Iterator} or {@code Map}.
         * If the iterator is an indexed collection or a map,
         * the index or the key should be set.
         * The node is not necessarily a leaf node (ie. subnodes can
          * be added).
         */
        interface NodeContextBuilder {
            
            /**
             * Define the key the object is into the {@code Map}
             *
             * @param key map key
             * @return a builder representing the current node
             */
            NodeBuilderDefinedContext atKey(Object key);

            /**
             * Define the index the object is into the {@code List} or array
             *
             * @param index index
             * @return a builder representing the current node
             */
            NodeBuilderDefinedContext atIndex(Integer index);

            /**
             * Add a node to the path the {@code ConstraintViolation} will be associated to.
             *
             * {@code name} describes a single property. In particular,
             * dot (.) is not allowed.
             *
             * @param name property name
             * @return a builder representing node {@code name}
             * @deprecated since 1.1 - replaced by {@code addPropertyNode} and {@code addBeanNode}
             */
            @Deprecated
            NodeBuilderCustomizableContext addNode(String name);

            /**
             * Add a property node to the path the {@code ConstraintViolation} will be associated to.
             *
             * {@code name} describes a single property. In particular,
             * dot (.) is not allowed.
             *
             * @param name property name
             * @return a builder representing node {@code name}
             * @throws IllegalArgumentException if the name is null
             *
             * @since 1.1
             */
            NodeBuilderCustomizableContext addPropertyNode(String name);

            /**
             * Add a bean node (class-level) to the path the {@code ConstraintViolation} will be associated to.
             * Note that bean nodes are always leaf nodes.
             *
             * @return a builder representing the bean node
             *
             * @since 1.1
             */
            LeafNodeBuilderCustomizableContext addBeanNode();

            /**
             * Add the new {@code ConstraintViolation} to be generated if the
             * constraint validator mark the value as invalid.
             * Methods of the {@code ConstraintViolationBuilder} instance this object
             * comes from and the constraint violation builder nested
             * objects throw {@code IllegalStateException} after this call.
             *
             * @return {@code ConstraintValidatorContext} instance the
             *           {@code ConstraintViolationBuilder} comes from
             */
            ConstraintValidatorContext addConstraintViolation();
        }
    }
}</programlisting>

    <para>The <classname>ConstraintValidatorContext</classname> interface
    allows redefinition of the default constraint message generated when a
    constraint is not valid. <phrase role="tck-testable">By default, each
    invalid constraint leads to the generation of one error object represented
    by a <classname>ConstraintViolation</classname> object. This object is
    built from the default constraint message template as defined by the
    constraint declaration and the context in which the constraint declaration
    is placed (bean, property, attribute, <phrase revisionflag="added">method
    or constructor parameter, method or constructor return
    value</phrase>).</phrase></para>

    <para><phrase role="tck-testable">The
    <classname>ConstraintValidatorContext</classname> methods let the
    constraint implementation disable the default
    <classname>ConstraintViolation</classname> generation and create one or
    more custom ones.</phrase> <phrase role="tck-testable">The
    non-interpolated message passed as a parameter is used to build the
    <classname>ConstraintViolation</classname> message (the message
    interpolation operation is applied to it).</phrase></para>

    <para><phrase role="tck-testable tck-needs-update">By default, the
    <classname>Path</classname> exposed on the
    <classname>ConstraintViolation</classname> represents the path to the
    bean, property, <phrase revisionflag="added">parameter or return
    value</phrase> hosting the constraint (see <xref
    linkend="validationapi-constraintviolation"/> for more
    information).</phrase> <phrase role="tck-testable">You can point it to a
    subpath of this default path by using the constraint violation builder
    fluent API.</phrase></para>

    <para><xref
    linkend="example-constraintsdefinitionimplementation-validationimplementation-errorbuilder"/>
    shows a few examples.</para>

    <example id="example-constraintsdefinitionimplementation-validationimplementation-errorbuilder"
             revisionflag="changed">
      <title>Using the fluent API to build custom constraint
      violations</title>

      <programlisting>//assuming the following domain model
public class User {
    public Map&lt;String,Address&gt; getAddresses() { ... }
}

public class Address {
    public String getStreet() { ... }
    public Country getCountry() { ... }
}

public class Country {
   public String getName() { ... }
}

//From a property-level constraint on User.addresses
//Build a constraint violation on the default path - ie the "addresses" property
context.buildConstraintViolationWithTemplate( "this detail is wrong" )
            .addConstraintViolation();

//From a class level constraint on Address
//Build a constraint violation on the default path + "street"
//ie the street property of Address
context.buildConstraintViolationWithTemplate( "this detail is wrong" )
            .addPropertyNode( "street" )
            .addConstraintViolation();

//From a property-level constraint on  User.addresses
//Build a constraint violation on the default path + the bean stored
//under the "home" key in the map
context.buildConstraintViolationWithTemplate( "Incorrect home address" )
            .addBeanNode()
                .inIterable().atKey( "home" )
            .addConstraintViolation();

//From a class level constraint on User
//Build a constraint violation on the default path + addresses["home"].country.name
//ie property "country.name" on the object stored under "home" in the map
context.buildConstraintViolationWithTemplate( "this detail is wrong" )
            .addPropertyNode( "addresses" )
            .addPropertyNode( "country" )
                .inIterable().atKey( "home" )
            .addPropertyNode( "name" )
            .addConstraintViolation();

//To create a subnode representing a method parameter from a cross-parameter constraint violation

//Cross-parameter constraint on method createUser(String password, String passwordRepeat)
//Build a constraint violation on the default path + "passwordRepeat"
context.buildConstraintViolationWithTemplate("Passwords do not match")
                .addParameterNode(1)
                .addConstraintViolation();

//Cross-parameter constraint on a method
//mergeAddresses(Map&lt;String,Address&gt; addresses, Map&lt;String,Address&gt; otherAddresses)
//Build a constraint violation on the default path + "otherAddresses["home"]
//ie. the Address bean hosted in the "home" key of the "otherAddresses" map parameter
context.buildConstraintViolationWithTemplate(
        "Map entry home present in both and does not match")
                .addParameterNode(1)
                .addBeanNode()
                    .inIterable().atKey("home")
                .addConstraintViolation();

//Cross-parameter constraint on a method
//mergeAddresses(Map&lt;String,Address&gt; addresses, Map&lt;String,Address&gt; otherAddresses)
//Build a constraint violation on the default path + "otherAddresses["home"].city
//ie. on the "city" property of the Address bean hosted in
//the "home" key of the "otherAddresses" map
context.buildConstraintViolationWithTemplate(
        "Map entry home present in both but city does not match")
                .addParameterNode(1)
                .addPropertyNode("city")
                    .inIterable().atKey("home")
                .addConstraintViolation();</programlisting>
    </example>

    <para role="tck-testable">If
    <methodname>disableDefaultConstraintViolation</methodname> is called, no
    custom error is added (using the error builder) and if the constraint is
    not valid, a <classname>ValidationException</classname> is raised.</para>

    <section id="constraintsdefinitionimplementation-validationimplementation-example">
      <title revisionflag="changed">Examples</title>

      <example>
        <title>ConstraintValidator implementation</title>

        <programlisting>/**
 * Check that a text is within the authorized syntax
 */
public class SyntaxValidator implements ConstraintValidator&lt;Syntax, String&gt; {
    private Set&lt;Format&gt; allowedFormats;

    /**
     * Configure the constraint validator based on the elements
     * specified at the time it was defined.
     * @param constraint the constraint definition
     */
    public void initialize(Syntax constraint) {
        allowedFormats = new HashSet( Arrays.asList( constraint.value() ) );
    }

    /**
     * Validate a specified value.
     * returns false if the specified value does not conform to the definition
     */
    public boolean isValid(String value, ConstraintValidatorContext context) {
        if ( value == null ) return true;

        return allowedFormats.size() == 0 
            || (! Collections.disjoint( guessFormat(value), allowedFormats ) );
    }

    Set&lt;Format&gt; guessFormats(String text) { ... }
}</programlisting>
      </example>

      <para>This <classname>ConstraintValidator</classname> checks that a text
      is within the accepted syntax. It also demonstrates an interesting best
      practice: return <literal>true</literal> on a null parameter.</para>

      <para revisionflag="added">The following listing shows a validator
      implementing the validation logic for a cross-parameter
      constraint.</para>

      <example revisionflag="added">
        <title>cross-parameter validator implementation</title>

        <programlisting>/**
 * Check that two date parameters of a method are in the expected order. Expects the
 * 2nd and 3rd parameter of the validated method to be of type java.util.Date.
 */
public class DateParametersConsistentValidator implements&lt;DateParametersConsistent, Object[]&gt; {

    /**
     * Configure the constraint validator based on the elements
     * specified at the time it was defined.
     * @param constraint the constraint definition
     */
    public void initialize(DateParametersConsistent constraint) {
    }

    /**
     * Validate a specified value.
     * returns false if the specified value does not conform to the definition
     */
    public boolean isValid(Object[] value, ConstraintValidatorContext context) {
        if ( value.length != 3 ) {
            throw new IllegalStateException( "Unexpected method signature" );
        }
        // one or both limits are unbounded =&gt; always consistent
        if ( value[1] == null || value[2] == null ) return true;
        return ( (Date) value[1] ).before( (Date) value[2] );
    }
}</programlisting>
      </example>

      <para>The next example shows how to use
      <classname>ConstraintValidatorContext</classname>.</para>

      <example>
        <title>Use of ConstraintValidatorContext</title>

        <programlisting>/**
 * Check that a text is within the authorized syntax
 * Error messages are using either key:
 *  - com.acme.constraint.Syntax.unknown if no particular syntax is detected
 *  - com.acme.constraint.Syntax.unauthorized if the syntax is not allowed
 */
public class FineGrainedSyntaxValidator implements ConstraintValidator&lt;Syntax, String&gt; {
    private Set&lt;Format&gt; allowedFormats;

    /**
     * Configure the constraint validator based on the elements
     * specified at the time it was defined.
     * @param constraint the constraint definition
     */
    public void initialize(Syntax constraint) {
        allowedFormats = new HashSet( Arrays.asList( constraint.value() ) );
    }

    /**
     * Validate a specified value.
     * returns false if the specified value does not conform to the definition
     */
    public boolean isValid(String value, ConstraintValidatorContext context) {
        if ( value == null ) return true;
        Set&lt;Format&gt; guessedFormats = guessFormats(value);

        context.disableDefaultConstraintViolation();
        if ( guessedFormats.size() == 0 ) {
            String unknown = "{com.acme.constraint.Syntax.unknown}";
            context.buildConstraintViolationWithTemplate(unknown)
                       .addConstraintViolation();
            return false;
        }
        if ( allowedFormats.size() != 0 
            &amp;&amp; Collections.disjoint( guessedFormats, allowedFormats ) ) {

            String unauthorized = "{com.acme.constraint.Syntax.unauthorized}";
            context.buildConstraintViolationWithTemplate(unauthorized)
                       .addConstraintViolation();
            return false;
        }
        return true;
    }

    Set&lt;Format&gt; guessFormats(String text) { ... }
}</programlisting>
      </example>

      <para>The default error message is disabled and replaced by a specific
      error message depending on the type of constraint violation detected. In
      this case, only one error report is returned at a given time but a
      constraint validation implementation can return several error
      reports.</para>
    </section>
  </section>

  <section id="constraintsdefinitionimplementation-constraintfactory">
    <title>The ConstraintValidatorFactory</title>

    <para>Constraint validation implementation instances are created by a
    <classname>ConstraintValidatorFactory</classname>.</para>

    <para revisionflag="added">The life cycle of
    <classname>ConstraintValidator</classname> instances is fully dependent of
    the Bean Validation provider and piloted by the
    <classname>ConstraintValidatorFactory</classname> methods. Therefore,
    <classname>ConstraintValidatorFactory</classname> implementations (such as
    dependency injection frameworks) must consider these instances as
    belonging to a dependent scope. Bean Validation Provider must release each
    instance retrieved. This is typically done when the
    <classname>ValidatorFactory</classname> is being closed.</para>

    <example revisionflag="changed">
      <title>ConstraintValidatorFactory interface</title>

      <programlisting>/**
 * Instantiate a &lt;code&gt;ConstraintValidator&lt;/code&gt; instance based off its class.
 * The &lt;code&gt;ConstraintValidatorFactory&lt;/code&gt; is &lt;b&gt;not&lt;/b&gt; responsible
 * for calling {@link ConstraintValidator#initialize(java.lang.annotation.Annotation)}.
 *
 * @author Dhanji R. Prasanna
 * @author Emmanuel Bernard
 * @author Hardy Ferentschik
 */
public interface ConstraintValidatorFactory {

    /**
     * @param key The class of the constraint validator to instantiate.
     *
     * @return A new constraint validator instance of the specified class.
     */
    &lt;T extends ConstraintValidator&lt;?,?&gt;&gt; T getInstance(Class&lt;T&gt; key);
    
    /**
     * Signal ConstraintValidatorFactory that the instance is no longer
     * being used by the Bean Validation provider
     *
     * @param instance validator being released
     */
    void releaseInstance(ConstraintValidator&lt;?,?&gt; instance);
}</programlisting>
    </example>

    <para revisionflag="changed"><phrase role="tck-testable">The default
    <classname>ConstraintValidatorFactory</classname> provided by the Bean
    Validation provider implementation uses the public no-arg constructor of
    the <classname>ConstraintValidator</classname> class.</phrase> A custom
    <classname>ConstraintValidatorFactory</classname> can be provided; for
    example it may benefit from dependency injection control in constraint
    implementations (see <xref
    linkend="bootstrapping-usageandcontainerexpectation"/>). Any constraint
    implementation relying on
    <classname>ConstraintValidatorFactory</classname> behaviors specific to an
    implementation (dependency injection, no no-arg constructor and so on) are
    not portable, hence great care should be given before walking that path.
    Make sure to configure the Bean Validation provider to honor any specific
    needs your <classname>ConstraintValidator</classname> has. As constraint
    designer and writer, make sure to document any specific non compliant
    requirements.</para>

    <para><classname>ConstraintValidatorFactory</classname> should not cache
    instances as the state of each instance can be altered in the
    <methodname>initialize</methodname> method.</para>

    <para><phrase role="tck-testable">If an exception occurs in the factory
    while retrieving the <classname>ConstraintValidator</classname> instance,
    the runtime exception is wrapped in a
    <classname>ValidationException</classname>.</phrase> <phrase
    role="tck-testable">If the instance returned by the factory is null, a
    <classname>ValidationException</classname> is raised.</phrase></para>
  </section>
</chapter>
